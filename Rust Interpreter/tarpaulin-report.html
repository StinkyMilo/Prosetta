<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","commands.rs"],"content":"use std::ops::Index;\r\n\r\nuse crate::parser::multi_lit_num::VarOrInt;\r\nuse crate::parser::string_lit::VarOrStr;\r\nuse crate::parser::{End, SubStrData, Title};\r\n\r\n#[derive(PartialEq, Debug, Clone, Copy)]\r\npub enum OperatorType {\r\n    Add,\r\n    Sub,\r\n    Mult,\r\n    Div,\r\n    Mod,\r\n    Exp,\r\n    Log,\r\n    LessThan,\r\n    GreaterThan,\r\n    And,\r\n    Or,\r\n    Equals,\r\n    Not,\r\n}\r\n\r\n#[derive(PartialEq, Debug)]\r\npub enum Expr {\r\n    NoneStat,\r\n    NoneExpr,\r\n    //stats\r\n    Title {\r\n        data: Title,\r\n    },\r\n    Arc {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 4],\r\n        end: End,\r\n    },\r\n    Bezier {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Line {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 4],\r\n        end: End,\r\n    },\r\n    Rect {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 4],\r\n        end: End,\r\n    },\r\n    Assign {\r\n        locs: Vec\u003cusize\u003e,\r\n        var: SubStrData,\r\n        first: bool,\r\n        value_index: usize,\r\n        end: End,\r\n    },\r\n    Print {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        single_word: Option\u003cVec\u003cu8\u003e\u003e,\r\n        single_word_start: usize,\r\n        end: End,\r\n    },\r\n    If {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        else_index: usize,\r\n        end: End,\r\n    },\r\n    While {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Else {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    //expr\r\n    Var {\r\n        var: SubStrData,\r\n    },\r\n    WordNum {\r\n        locs: Vec\u003cusize\u003e,\r\n        str_start: usize,\r\n        str_len: usize,\r\n        end: End,\r\n    },\r\n    Operator {\r\n        locs: Vec\u003cusize\u003e,\r\n        func_type: OperatorType,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    LitNum {\r\n        str_start: usize,\r\n        str_length: usize,\r\n        value: i64,\r\n    },\r\n    //TODO: Could make a compiler optimization to pre-evaluate this if there are no variables\r\n    MultiLitNum {\r\n        str_start: usize,\r\n        locs: Vec\u003cusize\u003e,\r\n        values: Vec\u003cVarOrInt\u003e,\r\n        single_value: Option\u003ci64\u003e,\r\n        end: End,\r\n    },\r\n    Color {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Fill {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Stroke {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    LitCol {\r\n        str_start: usize,\r\n        str_length: usize,\r\n        value: Vec\u003cu8\u003e,\r\n    },\r\n    LitString {\r\n        str_start: usize,\r\n        str_end: usize,\r\n        str: Vec\u003cVarOrStr\u003e,\r\n    },\r\n    MoveTo {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    LineWidth {\r\n        locs: Vec\u003cusize\u003e,\r\n        child_index: usize,\r\n        end: End,\r\n    },\r\n    Rotate {\r\n        locs: Vec\u003cusize\u003e,\r\n        index: usize,\r\n        end: End,\r\n    },\r\n    Function {\r\n        locs: Vec\u003cusize\u003e,\r\n        func: SubStrData,\r\n        args: Vec\u003cSubStrData\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    FunctionCall {\r\n        locs: Vec\u003cusize\u003e,\r\n        func: SubStrData,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Return {\r\n        locs: Vec\u003cusize\u003e,\r\n        index: Option\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Append {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Delete {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    Replace {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Find {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    Index {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    List {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    ForEach {\r\n        var: SubStrData,\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Length {\r\n        locs: Vec\u003cusize\u003e,\r\n        index: usize,\r\n        end: End,\r\n    },\r\n    Not {\r\n        locs: Vec\u003cusize\u003e,\r\n        word: Vec\u003cu8\u003e,\r\n        str_start: usize,\r\n        str_len: usize,\r\n        end: End,\r\n    },\r\n}\r\n\r\nimpl Expr {\r\n    pub fn is_none(\u0026self) -\u003e bool {\r\n        match self {\r\n            Expr::NoneStat =\u003e true,\r\n            Expr::NoneExpr =\u003e true,\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n    // pub fn is_stat(\u0026self) -\u003e bool {\r\n    //     match self {\r\n    //         Expr::Arc { .. } | Expr::Line { .. } | Expr::Rect { .. } =\u003e true,\r\n    //         Expr::Assign { .. } | Expr::Print { .. } =\u003e true,\r\n    //         Expr::If { .. } | Expr::Else { .. } | Expr::While { .. } =\u003e true,\r\n    //         _ =\u003e false,\r\n    //     }\r\n    // }\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct ExprArena {\r\n    pub vec: Vec\u003cExpr\u003e,\r\n}\r\nimpl Index\u003cusize\u003e for ExprArena {\r\n    type Output = Expr;\r\n\r\n    fn index(\u0026self, index: usize) -\u003e \u0026Self::Output {\r\n        if index \u003c self.vec.len() {\r\n            \u0026self.vec[index]\r\n        } else {\r\n            \u0026Expr::NoneExpr\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":220,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":221,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":222,"address":[],"length":0,"stats":{"Line":15780613094306217965}},{"line":223,"address":[],"length":0,"stats":{"Line":5764607523034234897}},{"line":224,"address":[],"length":0,"stats":{"Line":8358680908399640578}},{"line":244,"address":[],"length":0,"stats":{"Line":2377900603251621899}},{"line":245,"address":[],"length":0,"stats":{"Line":2377900603251621899}},{"line":246,"address":[],"length":0,"stats":{"Line":2377900603251621892}},{"line":248,"address":[],"length":0,"stats":{"Line":7}}],"covered":9,"coverable":9},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","lib.rs"],"content":"#![cfg(feature = \"wasm\")]\r\n\r\nuse crate::parser::{Parser, ParserFlags};\r\n\r\n// #[path = \"testing/testing.rs\"]\r\n// mod testing;\r\n\r\nmod parser_runner;\r\n\r\nmod commands;\r\nmod parser;\r\nmod writers;\r\n\r\nuse crate::parser::{ParsedData, ParserResult};\r\nuse parser::ParserSource;\r\n\r\nuse crate::writers::javascript_writer;\r\nuse crate::writers::syntax_lint::SyntaxLinter;\r\nuse crate::writers::syntax_renderers::{\r\n    html_renderer::HTMLRenderer,\r\n    line_renderer::{Highlight, LineRenderer},\r\n};\r\nuse cap::Cap;\r\nuse std::alloc;\r\n\r\n// // When the `wee_alloc` feature is enabled, use `wee_alloc` as the global\r\n// // allocator.\r\n// #[global_allocator]\r\n// static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\r\n\r\n// fn setup() {\r\n//     console_error_panic_hook::set_once();\r\n// }\r\nuse wasm_bindgen::prelude::*;\r\n\r\n#[global_allocator]\r\nstatic ALLOCATOR: Cap\u003calloc::System\u003e = Cap::new(alloc::System, usize::max_value());\r\n\r\n#[wasm_bindgen]\r\npub fn get_heap_size() -\u003e usize {\r\n    ALLOCATOR.allocated()\r\n}\r\n\r\n#[wasm_bindgen]\r\npub struct ParserRunner;\r\n\r\n#[wasm_bindgen]\r\npub struct ParserRunnerData {\r\n    data: ParsedData\u003c'static\u003e,\r\n}\r\n\r\n#[wasm_bindgen]\r\nimpl ParserRunner {\r\n    #[wasm_bindgen(constructor)]\r\n    pub fn new() -\u003e Self {\r\n        Self\r\n    }\r\n\r\n    pub fn run_to_completion(\u0026mut self, source: \u0026str) -\u003e ParserRunnerData {\r\n        let mut parser = Parser::new(\r\n            ParserSource::from_string(source.as_bytes().to_vec()),\r\n            ParserFlags { title: true },\r\n        );\r\n\r\n        loop {\r\n            if parser.step() == ParserResult::NoInput {\r\n                break;\r\n            };\r\n        }\r\n\r\n        ParserRunnerData {\r\n            data: parser.into_data(),\r\n        }\r\n    }\r\n}\r\n\r\n#[wasm_bindgen]\r\nimpl ParserRunnerData {\r\n    pub fn get_javascript(\u0026self) -\u003e String {\r\n        javascript_writer::write(\u0026self.data.exprs, \u0026self.data.stat_starts)\r\n    }\r\n    pub fn get_html(\u0026self) -\u003e String {\r\n        let iter = self.data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cHTMLRenderer\u003e::new();\r\n        lint.write(\u0026self.data.exprs, \u0026self.data.stat_starts, iter);\r\n        String::from_utf8_lossy(\u0026lint.into_data()).to_string()\r\n    }\r\n    pub fn get_highlights(\u0026self) -\u003e Vec\u003cHighlight\u003e {\r\n        let iter = self.data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cLineRenderer\u003e::new();\r\n        lint.write(\u0026self.data.exprs, \u0026self.data.stat_starts, iter);\r\n        lint.into_data()\r\n    }\r\n}\r\n\r\n//wasm-pack build . -F wasm\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","main.rs"],"content":"#![cfg(not(feature = \"wasm\"))]\r\n\r\nuse std::{\r\n    collections::HashSet,\r\n    io::{self, Read},\r\n    mem,\r\n};\r\n\r\nuse crate::parser::{Parser, ParserFlags};\r\n\r\n#[path = \"testing/testing.rs\"]\r\nmod testing;\r\n//mod playground;\r\n\r\nmod parser_runner;\r\n\r\nmod commands;\r\nmod parser;\r\nmod writers;\r\n\r\nuse bstr::ByteSlice;\r\nuse itertools::Itertools;\r\nuse parser::ParserSource;\r\nuse parser_runner::{run_parser, RunnerFlags};\r\n\r\nfn main() {\r\n    // test_incorrect_colors();\r\n    // let t = Test;\r\n    // let ta: Box\u003cdyn Any\u003e = Box::new(Test);\r\n    // let ta2: Box\u003cdyn Test2\u003e = Box::new(Test);\r\n    // println!(\"{:?}\", t.type_id());\r\n    // println!(\"{:?}\", ta.type_id());\r\n    // println!(\"{:?}\", (*ta).type_id());\r\n    // println!(\"{:?}\", ta2.type_id());\r\n    // println!(\"{:?}\", (*(\u0026*ta2 as \u0026dyn Any)).type_id());\r\n    //playground::print_test();\r\n    //return;\r\n\r\n    println!(\"size of parser: {}\", mem::size_of::\u003cParser\u003e());\r\n\r\n    let mut args: Vec\u003cString\u003e = std::env::args().skip(1).collect();\r\n\r\n    for e in \u0026mut args {\r\n        e.make_ascii_lowercase();\r\n    }\r\n\r\n    args.sort();\r\n\r\n    let parser_flags = ParserFlags {\r\n        title: !cfg!(feature = \"no-title\"), //args.binary_search(\u0026\"not\".to_string()).is_ok(),\r\n    };\r\n\r\n    let vis_flags: RunnerFlags = RunnerFlags {\r\n        assert_steps: true,\r\n        input: true,\r\n        whole_program: true,\r\n        linted: true,\r\n        line_rendered: true,\r\n    };\r\n\r\n    run_parser(\r\n        parser_flags,\r\n        vis_flags,\r\n        ParserSource::from_stdin(), //ParserSource::from_string(MILO_POEM_2[0].to_vec())\r\n    );\r\n\r\n    let _ = io::stdin().read(\u0026mut [0u8]).unwrap();\r\n}\r\n\r\n#[allow(dead_code)]\r\nstatic MILO_POEM: [\u0026[u8]; 2] = [\r\n    b\"\r\nThe wizards utter 'paint iambically.'\r\nThe peasants hadn't choice but to obey.\r\n\\\r\nThe wizards' cruel entertainments chant\r\nand utter utter nonsense, void of weight.\r\n\\\r\nThe wizards' cursed victims utter trash;\r\nthe mages stand offended that despite\r\nintent most fair, the peasants: they dissent!\r\n\\\r\nThe wizards thought it boon to speak in verse\r\nbut overestimate the peasant's skill;\r\n'there is no point to it' the peasants thought.\r\n'What cruel poetry they thrust on us.'\r\nAnd so the peasants organized revolt.\r\n\\\r\nThey searched for mages speaking just in verse;\r\nthey thought and thought and thought 'where could they be?'\",\r\n    b\"\r\nBut long had passed; magicians marched away\r\nfrom cruel bitter thought and cursed man.\r\n\\\r\nAnd so in lack of overlords but yet\r\nstill wrought by curse the agriculturists\r\nadmitted thought that life is not so bad.\r\nDespite new vocal eccentricities,\r\ntheir burdens lifted free of mages cruel.\r\nThey thought that they were cursed, but in fact\r\n\\\r\nthe wizards had abandonded cruel thought,\r\nand left the peasants free of emperor.\r\n\\\r\nAnd so their revolution had achieved\r\na world where peasants had to speak in verse\r\nbut answered not to any cruel lord\r\nfor they had long since gone, with nothing left\r\nbut a society that slowly learned\r\nrestriction fosters creativity.\",\r\n];\r\n\r\n#[allow(dead_code)]\r\nstatic MILO_POEM_2: [\u0026[u8]; 1] = [b\"\r\n    was name les int marioooo. int luigi.!\r\n    was name2 mor int marioooo. int luigi.!\r\n    \"];\r\n\r\n// while !matches!(\r\n//     result,\r\n//     ParserResult::NoInput | ParserResult::MatchedLine(_) | ParserResult::FailedLine(_)\r\n// ) {\r\n//     result = parser.step();\r\n// }\r\n// //print!(\"{:?},\", result);\r\n// print!(\r\n//     \"{}\",\r\n//     linq_like_writer::write(\u0026parser.exprs, \u0026parser.stat_starts)\r\n// );\r\n// std::io::stdout().flush().unwrap();\r\n\r\n// println!(\r\n//     \"name of eq: {}\",\r\n//     format!(\"{:#?}\",(\u0026commands::Expr::Eq {\r\n//         locs: vec![0, 1],\r\n//         name_start: 7,\r\n//         name: \"inch\".as_bytes().to_vec(),\r\n//         value_index: 1\r\n//     }))\r\n// );\r\n//let mut buf= Vec::new();\r\n//testing::test_ast1();\r\n// let mut input =io::stdin().lock();\r\n//let stats = parser_state::parse(\u0026mut input);\r\n//println!(\"{}\",processing_writer::write(\u0026stats))\r\n//let s:String = Default::default();\r\n\r\n//parser.vars.insert(\"inch\".as_bytes().to_vec());\r\n//crate::testing::add_vars!(parser, \"inch\", \"miles\", \"furlongs\", \"longer\");\r\n//let mut result = parser.step();\r\n\r\n// loop {\r\n//     match parser.step() {\r\n//         ParserResult::MatchedLine =\u003e print(\u0026parser),\r\n//         ParserResult::FailedLine =\u003e println!(\"   parse failed\"),\r\n//         ParserResult::NoInput =\u003e break,\r\n//         _ =\u003e {}\r\n//     }\r\n// }\r\n\r\n// loop {\r\n//     match parser.step() {\r\n//         ParserResult::NoInput =\u003e break,\r\n//         state =\u003e println!(\r\n//             \"assert_step!(parser, {:?}, \\\"{}\\\", \\\"{}\\\");\",\r\n//             state,\r\n//             parser.get_state(),\r\n//             std::str::from_utf8(parser.get_word()).unwrap()\r\n//         ),\r\n//     }\r\n// }\r\n\r\n// let data = parser.into_data();\r\n// let iter = data.source.get_iter();\r\n// println!(\r\n//     \"    text input:\\n\\\"{}\\\"\",\r\n//     std::str::from_utf8(iter.cloned().collect::\u003cVec\u003c_\u003e\u003e().as_slice()).unwrap()\r\n// );\r\n// let iter = data.source.get_iter();\r\n// //input.seek(SeekFrom::Start);\r\n// //println!();\r\n// //println!(\"== {:?}\", parser.exprs.vec);\r\n// println!(\r\n//     \"   whole program:\\n{}\",\r\n//     linq_like_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n// );\r\n// let mut lint = writers::syntax_lint::SyntaxLinter::\u003c\r\n//     writers::syntax_renderers::wind_renderer::WindowsRenderer,\r\n// \u003e::new();\r\n// lint.write(\u0026data.exprs, \u0026data.stat_starts, iter);\r\n// println!(\r\n//     \"   linted:\\n{}\",\r\n//     std::str::from_utf8(\u0026lint.into_string()).unwrap()\r\n// );\r\n// println!(\r\n//     \"   java program:\\n{}\",\r\n//     processing_writer::write(\u0026parser.exprs, \u0026parser.stat_starts)\r\n// );\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","alias.rs"],"content":"use super::*;\r\nuse alias_data::*;\r\n\r\n///the state of the matching state machine\r\n#[derive(Debug, PartialEq)]\r\nenum MatchState {\r\n    Var,\r\n    Num,\r\n    Color,\r\n    StringLit,\r\n    FunctionCallExpr,\r\n    FunctionCallStat,\r\n    FindAliases,\r\n}\r\n\r\n/// used for both NoneStat and NoneExpr\r\n/// finds next command\r\n#[derive(Debug)]\r\npub struct NoneState {\r\n    ///a reference to the static data of the aliases\r\n    data: \u0026'static StaticAliasData,\r\n    ///the progress of each alias\r\n    progress: Vec\u003cu8\u003e,\r\n    ///the already parsed locs (the locations of alias characters)\r\n    locs: Vec\u003cOption\u003cVec\u003cusize\u003e\u003e\u003e,\r\n    ///the offset into the word\r\n    offset: usize,\r\n    ///the number of currently matched aliases\r\n    matched: u16,\r\n    ///the next state of the state machine\r\n    next_match_state: MatchState,\r\n}\r\n\r\nimpl ParseState for NoneState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        let aliases = (self.data.aliases)(env.aliases);\r\n        debug_assert!(aliases.len() \u003c u16::MAX as usize);\r\n\r\n        // reset on new word\r\n        self.reset(aliases.len());\r\n\r\n        self.run_match_state(env, word, rest)\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if child_index.is_some() {\r\n            // child matched successfully\r\n            MatchResult::Matched(word.pos, false)\r\n        } else {\r\n            // child did not match - continue searching\r\n            self.run_match_state(env, word, rest)\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        self.data.state_name\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::None\r\n    }\r\n}\r\n\r\nimpl NoneState {\r\n    fn new(data: \u0026'static StaticAliasData) -\u003e Self {\r\n        Self {\r\n            data,\r\n            progress: Vec::new(),\r\n            locs: Vec::new(),\r\n            offset: 0,\r\n            matched: 0,\r\n            next_match_state: MatchState::FindAliases,\r\n        }\r\n    }\r\n    ///reset state back to defaults for a new word\r\n    fn reset(\u0026mut self, length: usize) {\r\n        self.progress = vec![0u8; length];\r\n        self.locs = vec![Some(Vec::new()); length];\r\n        self.offset = 0;\r\n        self.matched = 0;\r\n        // if expr need to check if var or num\r\n        self.next_match_state = if self.data.is_expr {\r\n            //Expression\r\n            MatchState::StringLit\r\n        } else {\r\n            //Statement\r\n            MatchState::FunctionCallStat\r\n        }\r\n    }\r\n    pub fn new_stat() -\u003e Self {\r\n        Self::new(\u0026AliasData::STAT)\r\n    }\r\n    pub fn new_stat_cont() -\u003e Self {\r\n        Self::new(\u0026AliasData::STAT_CONT)\r\n    }\r\n    pub fn new_expr() -\u003e Self {\r\n        Self::new(\u0026AliasData::EXPR)\r\n    }\r\n    pub fn new_expr_cont() -\u003e Self {\r\n        Self::new(\u0026AliasData::EXPR_CONT)\r\n    }\r\n}\r\n\r\nimpl NoneState {\r\n    ///matches based on MatchState\r\n    ///Expr starts at Var, to check if it is a varible, then it checks if it is a number,\r\n    ///then it tries to find aliases in the word\r\n    ///Stat starts at the aliases directly\r\n    fn run_match_state(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        let (new_state, ret) = match self.next_match_state {\r\n            MatchState::StringLit =\u003e (\r\n                MatchState::Var,\r\n                MatchResult::ContinueWith(word.pos, get_state!(string_lit::LitStrState::new()))\r\n            ),\r\n            // is word a varible\r\n            MatchState::Var =\u003e (\r\n                MatchState::FunctionCallExpr,\r\n                MatchResult::ContinueWith(word.pos, get_state!(var::VarState::new())),\r\n            ),\r\n            // is word a function\r\n            MatchState::FunctionCallExpr =\u003e (\r\n                MatchState::Num,\r\n                MatchResult::ContinueWith(word.pos, get_state!(call_func::FunctionCallState::new()))\r\n            ),\r\n            // is word a literal number\r\n            MatchState::Num =\u003e (\r\n                MatchState::Color,\r\n                MatchResult::ContinueWith(\r\n                    word.pos,\r\n                    get_state!(num_literal::LiteralNumState::new()),\r\n                ),\r\n            ),\r\n            // is word a color\r\n            MatchState::Color =\u003e (\r\n                MatchState::FindAliases,\r\n                MatchResult::ContinueWith(word.pos, get_state!(litcolor::LiteralColorState::new())),\r\n            ),\r\n            MatchState::FunctionCallStat =\u003e (\r\n                MatchState::FindAliases,\r\n                MatchResult::ContinueWith(word.pos, get_state!(call_func::FunctionCallState::new()))\r\n            ),\r\n            \r\n            // else check aliases\r\n            MatchState::FindAliases =\u003e (MatchState::FindAliases, self.match_alias(env, word, rest)),\r\n        };\r\n        self.next_match_state = new_state;\r\n        ret\r\n    }\r\n\r\n    ///matches buildin functions based on self.data\r\n    fn match_alias(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        let aliases = (self.data.aliases)(env.aliases);\r\n\r\n        // run until end of word\r\n        for offset in self.offset..word.len() {\r\n            self.match_letters(\u0026aliases, word, offset);\r\n\r\n            // try match\r\n            while self.matched != 0 {\r\n                self.matched -= 1;\r\n                return self.find_best_match(env, \u0026aliases, offset, rest.pos);\r\n            }\r\n        }\r\n\r\n        // if default continue\r\n        if self.data.default_continue {\r\n            MatchResult::Continue(0)\r\n        // else fail\r\n        } else {\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n    ///finds the bast match of the ones to have just matched\r\n    ///Done by:\r\n    ///1. Implicitly the first to match\r\n    ///2. least length between first and last letter\r\n    ///3. then on least total location value\r\n    fn find_best_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        aliases: \u0026AliasNames,\r\n        offset: usize,\r\n        rest: usize,\r\n    ) -\u003e MatchResult {\r\n        let mut min_size = usize::MAX;\r\n        let mut min_locations = usize::MAX;\r\n        let mut min_index = u16::MAX;\r\n        for j in 0..aliases.len() {\r\n            // has finished matching\r\n            if self.progress[j] == aliases[j].len() as u8 \u0026\u0026 self.locs[j].is_some() {\r\n                let matching_locs = self.locs[j].as_ref().unwrap();\r\n\r\n                let size = matching_locs.last().unwrap() - matching_locs[0];\r\n                let location_sum: usize = matching_locs.iter().sum();\r\n\r\n                // is best match\r\n                // match on least length between first and last letter\r\n                // then on least total location value\r\n                if size \u003c min_size || (size == min_size \u0026\u0026 location_sum \u003c min_locations) {\r\n                    min_index = j as u16;\r\n                    min_size = size;\r\n                    min_locations = location_sum;\r\n                }\r\n            }\r\n        }\r\n        self.offset = offset;\r\n        env.locs = self.locs[min_index as usize].take();\r\n        for index in env.locs.as_mut().unwrap() {\r\n            *index += env.global_index;\r\n        }\r\n        //set up stack\r\n        (self.data.func)(\r\n            aliases[min_index as usize],\r\n            rest,\r\n            // move locs out of state without copy\r\n        )\r\n    }\r\n\r\n    ///match current letter at offset to all aliases\r\n    fn match_letters(\u0026mut self, aliases: \u0026AliasNames, word: \u0026Slice\u003c'_\u003e, offset: usize) {\r\n        // does letter match any commands\r\n        for i in 0..aliases.len() {\r\n            // does letter match\r\n            if self.progress[i] \u003c aliases[i].len() as u8\r\n                \u0026\u0026 word.str[offset].to_ascii_lowercase() == aliases[i][self.progress[i] as usize]\r\n            {\r\n                self.progress[i] += 1;\r\n                // add locations to locations (locs)\r\n                self.locs[i].as_mut().unwrap().push(word.pos + offset);\r\n                if self.progress[i] == aliases[i].len() as u8 {\r\n                    self.matched += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":36,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567622}},{"line":40,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":42,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":45,"address":[],"length":0,"stats":{"Line":4827858800541171718}},{"line":52,"address":[],"length":0,"stats":{"Line":4827858800541171718}},{"line":54,"address":[],"length":0,"stats":{"Line":2954361355555045393}},{"line":57,"address":[],"length":0,"stats":{"Line":1873497444986126325}},{"line":61,"address":[],"length":0,"stats":{"Line":17582052945254416388}},{"line":62,"address":[],"length":0,"stats":{"Line":17582052945254416388}},{"line":65,"address":[],"length":0,"stats":{"Line":3602879701896396829}},{"line":66,"address":[],"length":0,"stats":{"Line":3602879701896396829}},{"line":71,"address":[],"length":0,"stats":{"Line":3170534137668829190}},{"line":74,"address":[],"length":0,"stats":{"Line":3170534137668829190}},{"line":75,"address":[],"length":0,"stats":{"Line":3170534137668829190}},{"line":82,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":83,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":84,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":85,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":86,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":88,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":90,"address":[],"length":0,"stats":{"Line":4539628424389459974}},{"line":93,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":96,"address":[],"length":0,"stats":{"Line":1297036692682702850}},{"line":97,"address":[],"length":0,"stats":{"Line":1297036692682702850}},{"line":99,"address":[],"length":0,"stats":{"Line":16789419410837209088}},{"line":100,"address":[],"length":0,"stats":{"Line":16789419410837209088}},{"line":102,"address":[],"length":0,"stats":{"Line":2882303761517117443}},{"line":103,"address":[],"length":0,"stats":{"Line":2882303761517117443}},{"line":105,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":106,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":115,"address":[],"length":0,"stats":{"Line":11313042263954685954}},{"line":121,"address":[],"length":0,"stats":{"Line":4179340454199820292}},{"line":122,"address":[],"length":0,"stats":{"Line":4539628424389459969}},{"line":123,"address":[],"length":0,"stats":{"Line":4539628424389459969}},{"line":124,"address":[],"length":0,"stats":{"Line":4539628424389459969}},{"line":127,"address":[],"length":0,"stats":{"Line":4251398048237748196}},{"line":128,"address":[],"length":0,"stats":{"Line":4251398048237748196}},{"line":129,"address":[],"length":0,"stats":{"Line":4251398048237748196}},{"line":132,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":133,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":134,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":137,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":138,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":139,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":140,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":141,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":145,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":146,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":147,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":149,"address":[],"length":0,"stats":{"Line":4899916394579099650}},{"line":150,"address":[],"length":0,"stats":{"Line":4899916394579099650}},{"line":151,"address":[],"length":0,"stats":{"Line":4899916394579099650}},{"line":155,"address":[],"length":0,"stats":{"Line":10304235947423694852}},{"line":162,"address":[],"length":0,"stats":{"Line":10304235947423694852}},{"line":163,"address":[],"length":0,"stats":{"Line":10304235947423694852}},{"line":166,"address":[],"length":0,"stats":{"Line":6269010681299730438}},{"line":167,"address":[],"length":0,"stats":{"Line":14411518807585587202}},{"line":170,"address":[],"length":0,"stats":{"Line":14411518807585587202}},{"line":171,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":172,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":177,"address":[],"length":0,"stats":{"Line":6485183463413514244}},{"line":178,"address":[],"length":0,"stats":{"Line":4467570830351532034}},{"line":181,"address":[],"length":0,"stats":{"Line":2017612633061982210}},{"line":189,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":196,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":197,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":198,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":199,"address":[],"length":0,"stats":{"Line":8358680908399640585}},{"line":201,"address":[],"length":0,"stats":{"Line":8646911284551352368}},{"line":202,"address":[],"length":0,"stats":{"Line":3819052484010180652}},{"line":204,"address":[],"length":0,"stats":{"Line":3819052484010180652}},{"line":205,"address":[],"length":0,"stats":{"Line":3819052484010180652}},{"line":210,"address":[],"length":0,"stats":{"Line":7638104968020361306}},{"line":211,"address":[],"length":0,"stats":{"Line":3819052484010180612}},{"line":212,"address":[],"length":0,"stats":{"Line":3819052484010180612}},{"line":213,"address":[],"length":0,"stats":{"Line":3819052484010180612}},{"line":217,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":218,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":219,"address":[],"length":0,"stats":{"Line":8286623314361712642}},{"line":220,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":224,"address":[],"length":0,"stats":{"Line":3819052484010180614}},{"line":225,"address":[],"length":0,"stats":{"Line":3819052484010180614}},{"line":231,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":233,"address":[],"length":0,"stats":{"Line":7854277750134145031}},{"line":235,"address":[],"length":0,"stats":{"Line":11889503016258109447}},{"line":236,"address":[],"length":0,"stats":{"Line":9871890383196127394}},{"line":238,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":240,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":241,"address":[],"length":0,"stats":{"Line":1080863910568919184}},{"line":242,"address":[],"length":0,"stats":{"Line":3819052484010180752}}],"covered":92,"coverable":92},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","alias_data.rs"],"content":"use std::collections::HashSet;\r\n\r\nuse super::*;\r\n\r\nconst BASE_EXPR_ALIASES: \u0026[\u0026'static [u8]] = \u0026[\r\n    b\"int\", b\"lit\", // number makers\r\n    b\"add\", b\"sub\", b\"tim\", b\"ide\", b\"mod\", b\"log\", b\"exp\", // number operators\r\n    b\"les\", b\"mor\", b\"als\", b\"oth\", b\"par\", b\"inv\", // boolean operators\r\n];\r\n\r\nconst LIST_EXPR_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"lis\", b\"fin\", b\"ind\", b\"cou\"];\r\nconst GRAPH_EXPR_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"col\"];\r\n\r\nconst BASE_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"was\", b\"pri\", b\"whe\", b\"whi\", b\"els\", b\"not\"];\r\n\r\nconst LIST_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"fre\", b\"del\", b\"app\", b\"rep\"];\r\nconst FUNC_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"fun\", b\"ret\"];\r\nconst GRAPH_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[\r\n    b\"arc\", b\"rec\", //shapes\r\n    b\"mov\", b\"tur\", b\"lin\", b\"bez\", //turtle\r\n    b\"sto\", b\"fil\", b\"pen\", // shape modifiers\r\n];\r\n\r\n///match alias to expr\r\nfn get_expr_state(alias: \u0026'static [u8], index: usize) -\u003e MatchResult {\r\n    MatchResult::ContinueWith(\r\n        index,\r\n        match alias {\r\n            b\"add\" =\u003e get_state!(operator::OperatorState::new_add()),\r\n            b\"sub\" =\u003e get_state!(operator::OperatorState::new_sub()),\r\n            b\"tim\" =\u003e get_state!(operator::OperatorState::new_mult()),\r\n            b\"ide\" =\u003e get_state!(operator::OperatorState::new_div()),\r\n            b\"mod\" =\u003e get_state!(operator::OperatorState::new_mod()),\r\n            b\"log\" =\u003e get_state!(operator::OperatorState::new_log()),\r\n            b\"exp\" =\u003e get_state!(operator::OperatorState::new_exp()),\r\n            b\"les\" =\u003e get_state!(operator::OperatorState::new_less_than()),\r\n            b\"mor\" =\u003e get_state!(operator::OperatorState::new_greater_than()),\r\n            b\"als\" =\u003e get_state!(operator::OperatorState::new_and()),\r\n            b\"oth\" =\u003e get_state!(operator::OperatorState::new_or()),\r\n            b\"par\" =\u003e get_state!(operator::OperatorState::new_equals()),\r\n            b\"inv\" =\u003e get_state!(operator::OperatorState::new_not()),\r\n\r\n            b\"lit\" =\u003e get_state!(multi_lit_num::MultiLitNumState::new()),\r\n            b\"int\" =\u003e get_state!(word_num::WordNumState::new()),\r\n            b\"col\" =\u003e get_state!(color::ColorState::new()),\r\n            b\"lis\" =\u003e get_state!(list::ListState::new()),\r\n            b\"fin\" =\u003e get_state!(find::FindState::new()),\r\n            b\"ind\" =\u003e get_state!(index::IndexState::new()),\r\n            b\"cou\" =\u003e get_state!(len::LengthState::new()),\r\n            _ =\u003e unreachable!(\"Got unknown alias {}\", std::str::from_utf8(alias).unwrap()),\r\n        },\r\n    )\r\n}\r\n\r\n/// match alias to stat\r\nfn get_stat_state(alias: \u0026'static [u8], index: usize) -\u003e MatchResult {\r\n    MatchResult::ContinueWith(\r\n        index,\r\n        match alias {\r\n            b\"arc\" =\u003e get_state!(circle::CircleState::new()),\r\n            b\"lin\" =\u003e get_state!(line::LineState::new()),\r\n            b\"bez\" =\u003e get_state!(bezier::BezierState::new()),\r\n            b\"was\" =\u003e get_state!(assign::AssignState::new()),\r\n            b\"rec\" =\u003e get_state!(rect::RectState::new()),\r\n            b\"pri\" =\u003e get_state!(print::PrintState::new()),\r\n            b\"whe\" =\u003e get_state!(if_stat::IfState::new()),\r\n            b\"whi\" =\u003e get_state!(while_stat::WhileState::new()),\r\n            b\"els\" =\u003e get_state!(else_stat::ElseState::new()),\r\n            b\"sto\" =\u003e get_state!(stroke::StrokeState::new()),\r\n            b\"fil\" =\u003e get_state!(fill::FillState::new()),\r\n            b\"mov\" =\u003e get_state!(move_to::MoveToState::new()),\r\n            b\"pen\" =\u003e get_state!(line_width::LineWidthState::new()),\r\n            b\"tur\" =\u003e get_state!(rotate::RotateState::new()),\r\n            b\"fun\" =\u003e get_state!(function::FunctionState::new()),\r\n            b\"ret\" =\u003e get_state!(return_stat::ReturnState::new()),\r\n            b\"app\" =\u003e get_state!(append::AppendState::new()),\r\n            b\"del\" =\u003e get_state!(delete::DeleteState::new()),\r\n            b\"rep\" =\u003e get_state!(replace::ReplaceState::new()),\r\n            b\"fre\" =\u003e get_state!(foreach::ForEachState::new()),\r\n            b\"not\" =\u003e get_state!(not::NotState::new()),\r\n            _ =\u003e unreachable!(\"Got unknown alias {}\", std::str::from_utf8(alias).unwrap()),\r\n        },\r\n    )\r\n}\r\n///A vector of alias strings\r\npub type AliasNames = Vec\u003c\u0026'static [u8]\u003e;\r\n///function to get alias strings from AliasData\r\ntype AliasSelector = fn(\u0026AliasData) -\u003e \u0026AliasNames;\r\n///fn to get the continueWith state with the corresponding string\r\ntype AliasToState = fn(alias: \u0026'static [u8], index: usize) -\u003e MatchResult;\r\n///static alias\r\n#[derive(Debug)]\r\npub struct StaticAliasData {\r\n    ///function to get alias strings from AliasData\r\n    pub aliases: AliasSelector,\r\n    ///function to get the matching continueWith state\r\n    pub func: AliasToState,\r\n    ///is this a expr alias data\r\n    pub is_expr: bool,\r\n    ///should this continue on failure of a word\r\n    pub default_continue: bool,\r\n    ///the name of the corresponding state\r\n    pub state_name: \u0026'static str,\r\n}\r\n\r\n///holds lists of all alias strings\r\n#[derive(Debug)]\r\npub struct AliasData {\r\n    pub expr: AliasNames,\r\n    pub stat: AliasNames,\r\n}\r\n\r\n///static alias data\r\nimpl AliasData {\r\n    pub const EXPR: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.expr,\r\n        func: get_expr_state,\r\n        is_expr: true,\r\n        default_continue: false,\r\n        state_name: \"NoneExpr\",\r\n    };\r\n    pub const EXPR_CONT: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.expr,\r\n        func: get_expr_state,\r\n        is_expr: true,\r\n        default_continue: true,\r\n        state_name: \"NoneExprCont\",\r\n    };\r\n\r\n    pub const STAT: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.stat,\r\n        func: get_stat_state,\r\n        is_expr: false,\r\n        default_continue: false,\r\n        state_name: \"NoneStat\",\r\n    };\r\n    pub const STAT_CONT: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.stat,\r\n        func: get_stat_state,\r\n        is_expr: false,\r\n        default_continue: true,\r\n        state_name: \"NoneStatCont\",\r\n    };\r\n}\r\n\r\nimpl AliasData {\r\n    pub fn new(imports: \u0026mut dyn Iterator\u003cItem = \u0026Import\u003e) -\u003e Self {\r\n        let mut added = HashSet::new();\r\n        let mut expr_vec = Vec::from(BASE_EXPR_ALIASES);\r\n        let mut stat_vec = Vec::from(BASE_STAT_ALIASES);\r\n\r\n        for import in imports {\r\n            if !added.contains(import) {\r\n                added.insert(*import);\r\n                let (exprs_aliases, stat_aliases) = Self::get_aliases(*import);\r\n                expr_vec.extend_from_slice(\u0026exprs_aliases);\r\n                stat_vec.extend_from_slice(\u0026stat_aliases);\r\n            }\r\n        }\r\n\r\n        Self {\r\n            expr: expr_vec,\r\n            stat: stat_vec,\r\n        }\r\n    }\r\n\r\n    pub fn all() -\u003e Self {\r\n        Self::new(\u0026mut Import::get_all().into_iter().map(|e| \u0026e.0))\r\n    }\r\n\r\n    pub fn none() -\u003e Self {\r\n        Self::new(\u0026mut std::iter::empty())\r\n    }\r\n\r\n    fn get_aliases(import: Import) -\u003e (\u0026'static [\u0026'static [u8]], \u0026'static [\u0026'static [u8]]) {\r\n        match import {\r\n            Import::List =\u003e (LIST_EXPR_ALIASES, LIST_STAT_ALIASES),\r\n            Import::Func =\u003e (\u0026[], FUNC_STAT_ALIASES),\r\n            Import::Graph =\u003e (\u0026GRAPH_EXPR_ALIASES, GRAPH_STAT_ALIASES),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":1873497444986126337}},{"line":27,"address":[],"length":0,"stats":{"Line":1873497444986126337}},{"line":28,"address":[],"length":0,"stats":{"Line":1873497444986126337}},{"line":29,"address":[],"length":0,"stats":{"Line":1873497444986126337}},{"line":30,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":58,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":59,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":60,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":65,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":66,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":123,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":131,"address":[],"length":0,"stats":{"Line":2810246167479189506}},{"line":138,"address":[],"length":0,"stats":{"Line":7638104968020361216}},{"line":147,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":148,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":149,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":150,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":152,"address":[],"length":0,"stats":{"Line":1801439850948198397}},{"line":153,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":154,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":155,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":156,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":157,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":167,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":168,"address":[],"length":0,"stats":{"Line":6557241057451442186}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":176,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":177,"address":[],"length":0,"stats":{"Line":16068843470457929722}},{"line":178,"address":[],"length":0,"stats":{"Line":16068843470457929733}},{"line":179,"address":[],"length":0,"stats":{"Line":16068843470457929729}}],"covered":49,"coverable":72},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","append.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct AppendState {\r\n    count: u8,\r\n}\r\nimpl BasicState for AppendState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Append\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Append {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Append { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=1 =\u003e CloseType::Unable,\r\n            2 =\u003e CloseType::Able,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Append { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl AppendState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","assign.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct AssignState {\r\n    first: bool,\r\n}\r\nimpl ParseState for AssignState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // set expr\r\n        if self.first {\r\n            *env.expr = Expr::Assign {\r\n                var: SubStrData::new(),\r\n                value_index: usize::MAX,\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                end: End::none(),\r\n                first: false,\r\n            };\r\n            self.first = false;\r\n        }\r\n\r\n        // dont make closes varibles\r\n        let var_word = try_get_symbol_word(word, env.global_index);\r\n        if let Some(new_var) = var_word {\r\n            //set name\r\n            if let Expr::Assign { var, first, .. } = env.expr {\r\n                *first = !env.symbols.contains(\u0026new_var.name);\r\n                *var = new_var;\r\n            } else {\r\n                unreachable!()\r\n            }\r\n            // setup child state\r\n            MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        } else {\r\n            MatchResult::Continue(0)\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Some(index) = child_index {\r\n            // find ending close\r\n            let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n            match close {\r\n                // will never be a period to find even on future words\r\n                None =\u003e MatchResult::Failed,\r\n                Some(slice) =\u003e {\r\n                    if let Expr::Assign {\r\n                        var,\r\n                        value_index,\r\n                        end,\r\n                        ..\r\n                    } = env.expr\r\n                    {\r\n                        *value_index = index;\r\n                        *end = End::from_slice(\u0026slice.0, env.global_index);\r\n                        env.symbols.insert_var(var.name.to_owned());\r\n                    } else {\r\n                        unreachable!();\r\n                    }\r\n                    MatchResult::Matched(slice.0.pos, true)\r\n                }\r\n            }\r\n        } else {\r\n            // child expr failed\r\n            // if child match fail, I can never succeed\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Assign\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl AssignState {\r\n    pub fn new() -\u003e Self {\r\n        Self { first: true }\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":15564440312192434177}},{"line":47,"address":[],"length":0,"stats":{"Line":12538021362599460865}},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855873}},{"line":73,"address":[],"length":0,"stats":{"Line":144115188075855873}},{"line":77,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":78,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":81,"address":[],"length":0,"stats":{"Line":15564440312192434181}},{"line":82,"address":[],"length":0,"stats":{"Line":15564440312192434181}},{"line":87,"address":[],"length":0,"stats":{"Line":15564440312192434177}}],"covered":10,"coverable":10},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","basic_func.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse super::*;\r\n\r\n/// a super state that wants between n and m arguments and a close\r\npub trait BasicState {\r\n    /// Can this be used here. True by default\r\n    fn can_happen(\u0026self, _env: \u0026mut Environment) -\u003e bool {\r\n        true\r\n    }\r\n    /// get the name\r\n    fn get_name(\u0026self) -\u003e \u0026'static str;\r\n\r\n    /// set expr and return whether it is first\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool;\r\n\r\n    /// add children at index to self\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize);\r\n\r\n    /// can I be closed\r\n    fn can_close(\u0026self) -\u003e CloseType;\r\n\r\n    /// set end to index\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End);\r\n\r\n    fn get_type(\u0026self) -\u003e StateType;\r\n}\r\n\r\nimpl\u003cT: BasicState + Debug\u003e ParseState for T {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if !self.can_happen(env) {\r\n            MatchResult::Failed\r\n        } else {\r\n            let is_first = self.do_first(env.expr, env.locs.take().unwrap_or_default());\r\n            if is_first {\r\n                let can_close = self.can_close();\r\n                match can_close {\r\n                    CloseType::Able =\u003e {\r\n                        if is_mandatory_close(word) {\r\n                            self.set_end(env.expr, End::from_slice(\u0026word, env.global_index));\r\n                            MatchResult::Matched(word.pos, true)\r\n                            // succeeded - continue again with noncont expr\r\n                        } else {\r\n                            MatchResult::ContinueWith(\r\n                                word.pos,\r\n                                get_state!(alias::NoneState::new_expr_cont()),\r\n                            )\r\n                        }\r\n                    }\r\n                    CloseType::Force =\u003e {\r\n                        let close =\r\n                            find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                        match close {\r\n                            // will never be a period to find even on future words\r\n                            None =\u003e MatchResult::Failed,\r\n                            Some(slice) =\u003e {\r\n                                self.set_end(env.expr, End::from_slice(\u0026slice.0, env.global_index));\r\n                                MatchResult::Matched(slice.0.pos, true)\r\n                            }\r\n                        }\r\n                    }\r\n                    CloseType::Unable =\u003e {\r\n                        // cont - has required arguments\r\n                        MatchResult::ContinueWith(\r\n                            word.pos,\r\n                            get_state!(alias::NoneState::new_expr_cont()),\r\n                        )\r\n                    }\r\n                }\r\n            } else {\r\n                // not cont - may have more arguments but may not - need to find close if there\r\n                MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_expr()))\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Some(index) = child_index {\r\n            self.add_child(env.expr, index);\r\n        }\r\n\r\n        let can_close = self.can_close();\r\n\r\n        match can_close {\r\n            CloseType::Unable =\u003e {\r\n                if child_index.is_some() {\r\n                    // continue again\r\n                    MatchResult::ContinueWith(\r\n                        word.pos,\r\n                        get_state!(alias::NoneState::new_expr_cont()),\r\n                    )\r\n                } else {\r\n                    // exprcont failed on the entire rest of string - I will never match\r\n                    MatchResult::Failed\r\n                }\r\n            }\r\n            CloseType::Able =\u003e {\r\n                // I can close so I close\r\n                if is_mandatory_close(word) {\r\n                    self.set_end(env.expr, End::from_slice(\u0026word, env.global_index));\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont expr\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_expr()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n            CloseType::Force =\u003e {\r\n                // forced to close\r\n                let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                match close {\r\n                    // will never be a period to find even on future words\r\n                    None =\u003e MatchResult::Failed,\r\n                    Some(slice) =\u003e {\r\n                        self.set_end(env.expr, End::from_slice(\u0026slice.0, env.global_index));\r\n                        MatchResult::Matched(slice.0.pos, true)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \u003cSelf as BasicState\u003e::get_name(\u0026self)\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        \u003cSelf as BasicState\u003e::get_type(\u0026self)\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":1585267068834414625}},{"line":9,"address":[],"length":0,"stats":{"Line":1585267068834414625}},{"line":30,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":31,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":35,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":36,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":37,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":66,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":84,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":90,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":106,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":107,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":109,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":110,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":123,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":131,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":132,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":135,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":136,"address":[],"length":0,"stats":{"Line":1801439850948198400}}],"covered":34,"coverable":55},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","bezier.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct BezierState {\r\n    count: u8,\r\n}\r\nimpl BasicState for BezierState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Bezier\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Bezier {\r\n                locs,\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Bezier { indexes, .. } = expr {\r\n            indexes.push(index);\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        if self.count \u003c 4 {\r\n            return CloseType::Unable;\r\n        }\r\n        if self.count % 2 == 0 {\r\n            return CloseType::Able;\r\n        }\r\n        return CloseType::Unable;\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Bezier { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl BezierState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","call_func.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct FunctionCallState {\r\n    // is_first: bool,\r\n    count: u8,\r\n}\r\nimpl ParseState for FunctionCallState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // is varible in scope\r\n        if let Some(func) = env.symbols.try_get_func(\u0026word, env.global_index) {\r\n            // if func exists it should have function arguments\r\n            let arg_count = env.symbols.get_func_arg_count(\u0026func.name).unwrap();\r\n\r\n            // if args are 0 then find end\r\n            let end = if arg_count == 0 {\r\n                let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                match close {\r\n                    None =\u003e return MatchResult::Failed,\r\n                    Some(slice) =\u003e End::from_slice(\u0026slice.0, env.global_index),\r\n                }\r\n            } else {\r\n                End::none()\r\n            };\r\n\r\n            // set\r\n            *env.expr = Expr::FunctionCall {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                func,\r\n                indexes: Vec::new(),\r\n                end,\r\n            };\r\n\r\n            // match if args are 0\r\n            if arg_count == 0 {\r\n                MatchResult::Matched(end.index, true)\r\n            } else {\r\n                MatchResult::ContinueWith(rest.pos, get_state!(alias::NoneState::new_expr_cont()))\r\n            }\r\n        } else {\r\n            // did not find function\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::FunctionCall {\r\n            func, indexes, end, ..\r\n        } = env.expr\r\n        {\r\n            if let Some(index) = child_index {\r\n                indexes.push(index);\r\n                self.count += 1;\r\n            }\r\n            if let Some(arg_total) = env.symbols.get_func_arg_count(\u0026func.name) {\r\n                let can_close = self.count \u003e= arg_total;\r\n                if can_close {\r\n                    let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                    return match close {\r\n                        None =\u003e MatchResult::Failed,\r\n                        Some(slice) =\u003e {\r\n                            *end = End::from_slice(\u0026slice.0, env.global_index);\r\n                            MatchResult::Matched(slice.0.pos, true)\r\n                        }\r\n                    };\r\n                } else {\r\n                    if child_index.is_some() {\r\n                        MatchResult::ContinueWith(\r\n                            word.pos,\r\n                            get_state!(alias::NoneState::new_expr_cont()),\r\n                        )\r\n                    } else {\r\n                        MatchResult::Failed\r\n                    }\r\n                }\r\n            } else {\r\n                //varible should not have dissapeared from symbols\r\n                unreachable!()\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"FunctionCall\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl FunctionCallState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            // is_first: true,\r\n            count: 0,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":7421932185906577408}},{"line":11,"address":[],"length":0,"stats":{"Line":7998392938210000890}},{"line":16,"address":[],"length":0,"stats":{"Line":576460752303423482}},{"line":17,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":18,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711738}},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711750}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":42,"address":[],"length":0,"stats":{"Line":6845471433603153926}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":55,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":57,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":61,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":64,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":92,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":95,"address":[],"length":0,"stats":{"Line":8142508126285856780}},{"line":96,"address":[],"length":0,"stats":{"Line":8142508126285856780}},{"line":100,"address":[],"length":0,"stats":{"Line":8142508126285856774}}],"covered":29,"coverable":31},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","circle.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct CircleState {\r\n    count: u8,\r\n}\r\nimpl BasicState for CircleState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Circle\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Arc {\r\n                locs,\r\n                indexes: [usize::MAX; 4],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Arc { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1..=3 =\u003e CloseType::Able,\r\n            /*\r\n                1-argument: diameter of circle from current position\r\n                2-argument: width and height of ellipse from current position\r\n                3-argument: x and y coordinates then diameter of circle\r\n                4-argument: x and y coordinate then width and height of ellipse\r\n                Draw from the middle\r\n            */\r\n            4 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Arc { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl CircleState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1}},{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","color.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct ColorState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for ColorState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Color\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Color {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Color { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Color { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl ColorState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","delete.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct DeleteState {\r\n    count: u8,\r\n}\r\nimpl BasicState for DeleteState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Delete\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Delete {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Delete { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Delete { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl DeleteState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","else_stat.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct ElseState {\r\n    first: bool,\r\n    if_index: usize,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for ElseState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            //get some(index) if it is an \"if\"\r\n            let if_index = env.last_stat_index.and_then(|index| {\r\n                matches!(env.before.get(index), Some(Expr::If { .. })).then_some(index)\r\n            });\r\n\r\n            if let Some(index) = if_index {\r\n                if !env\r\n                    .parents\r\n                    .into_iter()\r\n                    .rev()\r\n                    .take_while(|state| state.expr_index \u003e index)\r\n                    .any(|state| state.state.get_type() == StateType::Stat)\r\n                {\r\n                    *env.expr = Expr::Else {\r\n                        locs: env.locs.take().unwrap_or_default(),\r\n                        indexes: Vec::new(),\r\n                        end: End::none(),\r\n                    };\r\n                    // go up layer\r\n                    env.symbols.add_layer();\r\n                    self.if_index = index;\r\n                }\r\n            }\r\n        }\r\n        // if \"if\" wasnt found\r\n        if self.if_index == usize::MAX {\r\n            MatchResult::Failed\r\n        // non cont stat for seeing closes\r\n        } else if self.has_stat {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n            // need a first stat - cont\r\n        } else {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        self.first = false;\r\n        if let Expr::If { else_index, .. } = \u0026mut env.before[self.if_index] {\r\n            if let Expr::Else { end, indexes, .. } = env.expr {\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if is_mandatory_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    *else_index = env.expr_index;\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            } else {\r\n                unreachable!()\r\n            }\r\n        } else {\r\n            // should be guarenteed that if_index points to if\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Else\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl ElseState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            if_index: usize::MAX,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":13,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":15,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":16,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":19,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":24,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":25,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":33,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":39,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":40,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":87,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":88,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":91,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":92,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":97,"address":[],"length":0,"stats":{"Line":792633534417207296}}],"covered":23,"coverable":23},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","fill.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct FillState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for FillState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Fill\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Fill {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Fill { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Fill { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl FillState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":21}},{"line":13,"address":[],"length":0,"stats":{"Line":21}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","find.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct FindState {\r\n    count: u8,\r\n}\r\nimpl BasicState for FindState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Find\"\r\n    }\r\n    \r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Find {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Find {indexes, ..} = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count+=1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=1 =\u003e CloseType::Unable,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!()\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Find {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl FindState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","foreach.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct ForEachState {\r\n    first: bool,\r\n    has_list: bool,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for ForEachState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            *env.expr = Expr::ForEach {\r\n                var: SubStrData::new(),\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            self.first = false;\r\n            // setup child state\r\n            // MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        }\r\n        let var_word = try_get_symbol_word(word, env.global_index);\r\n        if let Some(new_var) = var_word {\r\n            if !self.has_list {\r\n                if let Expr::ForEach { var, .. } = env.expr {\r\n                    *var = new_var;\r\n                    env.symbols.add_layer();\r\n                    env.symbols.insert_var(var.name.to_owned());\r\n                } else {\r\n                    unreachable!()\r\n                }\r\n                MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n            } else if self.has_stat {\r\n                MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n            } else {\r\n                MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n            }\r\n        } else {\r\n            MatchResult::Continue(0)\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::ForEach { indexes, end, .. } = env.expr {\r\n            if !self.has_list {\r\n                //add child and find stats\r\n                if let Some(index) = child_index {\r\n                    self.has_list = true;\r\n                    indexes.push(index);\r\n                    MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n                } else {\r\n                    // if child match fail, I can never succeed\r\n                    MatchResult::Failed\r\n                }\r\n            } else {\r\n                //and stat child\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if self.has_stat \u0026\u0026 is_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"While\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl ForEachState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            has_list: false,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":87,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":96,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":5,"coverable":5},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","function.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct FunctionState {\r\n    first: bool,\r\n    has_name: bool,\r\n    is_parsing_body: bool,\r\n    has_stat: bool,\r\n    args_count: u8,\r\n}\r\nimpl ParseState for FunctionState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            *env.expr = Expr::Function {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                func: SubStrData::new(),\r\n                args: Vec::new(),\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            self.first = false;\r\n        }\r\n\r\n        // reached the end of the string\r\n        if word.len() == 0 {\r\n            env.symbols.remove_layer();\r\n            MatchResult::Failed\r\n        } else if let Expr::Function { func, args, .. } = env.expr {\r\n            // if parsing stats in body\r\n            if self.is_parsing_body {\r\n                MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_stat()))\r\n            // if doesn't yet have name\r\n            } else if !self.has_name {\r\n                if let Some(func_data) = try_get_symbol_word(word, env.global_index) {\r\n                    *func = func_data;\r\n                    //put func into new layer\r\n                    env.symbols.add_layer();\r\n                    env.symbols.insert_func(func.name.to_owned(), 0);\r\n                    self.has_name = true;\r\n                }\r\n                MatchResult::Continue(0)\r\n            //if doesn't yet have arg\r\n            } else {\r\n                if is_mandatory_close(word) {\r\n                    self.is_parsing_body = true;\r\n                    env.symbols\r\n                        .insert_func(func.name.to_owned(), self.args_count);\r\n                    return MatchResult::ContinueWith(\r\n                        rest.pos,\r\n                        Box::new(alias::NoneState::new_stat_cont()),\r\n                    );\r\n                    // if word can be a varible\r\n                } else if let Some(arg_data) = try_get_symbol_word(word, env.global_index) {\r\n                    // funtion can only have 255 arguments\r\n                    if self.args_count != 255 \u0026\u0026 !env.symbols.contains(\u0026arg_data.name) {\r\n                        env.symbols.insert_var(arg_data.name.to_owned());\r\n                        args.push(arg_data);\r\n                        self.args_count += 1;\r\n                    }\r\n                    //let arg_name = word.str.to_ascii_lowercase();\r\n                    // arg_names.push(arg_name.to_owned());\r\n                    // env.vars.insert(arg_name.to_owned());\r\n                    //env.funcs.inc_arg_count(\u0026func.name);\r\n                }\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // reached the end of the string\r\n        if word.len() == 0 {\r\n            env.symbols.remove_layer();\r\n            MatchResult::Failed\r\n        } else if let Expr::Function {\r\n            func, indexes, end, ..\r\n        } = env.expr\r\n        {\r\n            //and stat child\r\n            if let Some(index) = child_index {\r\n                indexes.push(index);\r\n            }\r\n\r\n            // close if have close\r\n            if is_mandatory_close(word) {\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                env.symbols.remove_layer();\r\n                env.symbols\r\n                    .insert_func(func.name.to_owned(), self.args_count);\r\n                MatchResult::Matched(word.pos, true)\r\n                // succeeded - continue again with noncont stat\r\n            } else if child_index.is_some() {\r\n                MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat_cont()))\r\n                // failed - pass word\r\n            } else {\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Function\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl FunctionState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            has_name: false,\r\n            is_parsing_body: false,\r\n            has_stat: false,\r\n            args_count: 0,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":13,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":14,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":15,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":16,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":17,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":18,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":19,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":21,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":25,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":34,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":38,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":39,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":41,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":44,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":48,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":49,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":55,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":111,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":112,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":115,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":116,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":121,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":36,"coverable":39},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","if_stat.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct IfState {\r\n    has_condition: bool,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for IfState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if !self.has_condition {\r\n            *env.expr = Expr::If {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                else_index: usize::MAX,\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            env.symbols.add_layer();\r\n            // setup child state\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        } else if self.has_stat {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n        } else {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::If { indexes, end, .. } = env.expr {\r\n            if !self.has_condition {\r\n                //add child and find stats\r\n                if let Some(index) = child_index {\r\n                    self.has_condition = true;\r\n                    indexes.push(index);\r\n                    MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n                } else {\r\n                    // if child match fail, I can never succeed\r\n                    MatchResult::Failed\r\n                }\r\n            } else {\r\n                //and stat child\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if self.has_stat \u0026\u0026 is_mandatory_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"If\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl IfState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            has_condition: false,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":12,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":13,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":14,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":15,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":16,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":17,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":19,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":21,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":22,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":72,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":73,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":76,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":77,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":82,"address":[],"length":0,"stats":{"Line":648518346341351424}}],"covered":17,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","index.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct IndexState {\r\n    count: u8,\r\n}\r\nimpl BasicState for IndexState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Index\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Index {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Index {indexes, ..} = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count+=1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=1 =\u003e CloseType::Unable,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!()\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Index {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl IndexState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":11,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":16,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","len.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct LengthState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for LengthState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Length\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Length {\r\n                locs,\r\n                index: usize::MAX,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, idx: usize) {\r\n        if let Expr::Length { index, .. } = expr {\r\n            *index = idx;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Length { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl LengthState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","line.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct LineState {\r\n    count: u8,\r\n}\r\nimpl BasicState for LineState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Line\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Line {\r\n                locs,\r\n                indexes: [usize::MAX; 4],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Line { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Able,\r\n            3 =\u003e CloseType::Able,\r\n            4 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Line { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl LineState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":11,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":40,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":20,"coverable":20},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","line_width.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct LineWidthState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for LineWidthState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Line Width\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::LineWidth {\r\n                locs,\r\n                child_index: usize::MAX,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::LineWidth { child_index, .. } = expr {\r\n            *child_index = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::LineWidth { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl LineWidthState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","list.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct ListState {\r\n    count: u8,\r\n}\r\nimpl BasicState for ListState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"List\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::List {\r\n                locs,\r\n                indexes: Vec::new(),\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::List {indexes, ..} = expr {\r\n            indexes.push(index);\r\n            self.count += 1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        CloseType::Able\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::List {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl ListState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":11,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":40,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":15,"coverable":15},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","litcolor.rs"],"content":"use super::*;\r\nuse litcolor_data::{get_color_word, LitColorFoundResult};\r\n#[derive(Debug)]\r\n\r\npub struct LiteralColorState {\r\n    wsf: Vec\u003cu8\u003e,\r\n}\r\n\r\nimpl ParseState for LiteralColorState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        let value = get_color_word(\u0026self.wsf, word.str);\r\n        if self.wsf == b\"\" {\r\n            match value {\r\n                LitColorFoundResult::Found =\u003e {\r\n                    *env.expr = Expr::LitCol {\r\n                        str_start: word.pos + env.global_index,\r\n                        str_length: word.len(),\r\n                        value: word.str.to_owned(),\r\n                    };\r\n                    MatchResult::Matched(rest.pos, false)\r\n                }\r\n                LitColorFoundResult::CouldFind =\u003e {\r\n                    *env.expr = Expr::LitCol {\r\n                        str_start: word.pos + env.global_index,\r\n                        str_length: usize::MAX,\r\n                        value: Vec::new(),\r\n                    };\r\n                    self.wsf\r\n                        .append(\u0026mut word.str.to_owned().to_ascii_lowercase());\r\n                    MatchResult::Continue(0)\r\n                }\r\n                LitColorFoundResult::Failed =\u003e MatchResult::Failed,\r\n                LitColorFoundResult::FoundOnLast =\u003e {\r\n                    unreachable!();\r\n                }\r\n            }\r\n        } else {\r\n            match value {\r\n                //Finishes a color name\r\n                LitColorFoundResult::Found =\u003e {\r\n                    if let Expr::LitCol {\r\n                        str_start,\r\n                        str_length,\r\n                        value,\r\n                    } = env.expr\r\n                    {\r\n                        if let Some(len) =\r\n                            (word.pos + word.len() + env.global_index).checked_sub(*str_start)\r\n                        {\r\n                            *str_length = len;\r\n                            self.wsf\r\n                                .append(\u0026mut word.str.to_owned().to_ascii_lowercase());\r\n                            *value = self.wsf.to_owned();\r\n                        } else {\r\n                            panic!(\"Expression is ending before it started!\")\r\n                        }\r\n                    } else {\r\n                        unreachable!()\r\n                    }\r\n                    MatchResult::Matched(rest.pos, false)\r\n                }\r\n                //Last word could have had more color words after it but didn't.\r\n                LitColorFoundResult::FoundOnLast =\u003e {\r\n                    if let Expr::LitCol {\r\n                        str_start,\r\n                        str_length,\r\n                        value,\r\n                    } = env.expr\r\n                    {\r\n                        if let Some(len) = (word.pos + env.global_index).checked_sub(*str_start) {\r\n                            *str_length = len;\r\n                            *value = self.wsf.to_owned();\r\n                        } else {\r\n                            panic!(\"Expression is ending before it started!\")\r\n                        }\r\n                    } else {\r\n                        unreachable!()\r\n                    }\r\n                    MatchResult::Matched(word.pos, false)\r\n                }\r\n                //Beginning of a color name, keep searching\r\n                LitColorFoundResult::CouldFind =\u003e {\r\n                    self.wsf\r\n                        .append(\u0026mut word.str.to_owned().to_ascii_lowercase());\r\n                    MatchResult::Continue(0)\r\n                }\r\n                //Cannot be a color\r\n                LitColorFoundResult::Failed =\u003e MatchResult::Failed,\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"ColorLit\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl LiteralColorState {\r\n    pub fn new() -\u003e Self {\r\n        Self { wsf: Vec::new() }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2954361355555045377}},{"line":11,"address":[],"length":0,"stats":{"Line":2954361355555045377}},{"line":12,"address":[],"length":0,"stats":{"Line":2954361355555045377}},{"line":13,"address":[],"length":0,"stats":{"Line":17726168133330272259}},{"line":15,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":16,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":17,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":18,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":20,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":24,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":32,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":38,"address":[],"length":0,"stats":{"Line":3674937295934324734}},{"line":83,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":84,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":85,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":104,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":107,"address":[],"length":0,"stats":{"Line":17726168133330272259}},{"line":108,"address":[],"length":0,"stats":{"Line":17726168133330272259}},{"line":113,"address":[],"length":0,"stats":{"Line":17726168133330272257}},{"line":114,"address":[],"length":0,"stats":{"Line":17726168133330272257}}],"covered":27,"coverable":28},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","litcolor_data.rs"],"content":"pub enum LitColorFoundResult {\r\n    ///found a color\r\n    Found,\r\n    ///found color on last word\r\n    FoundOnLast,\r\n    ///may find complete color on next word\r\n    CouldFind,\r\n    ///failed to find color\r\n    Failed,\r\n}\r\n\r\n#[rustfmt::skip]\r\npub fn get_color_word(word_so_far: \u0026[u8], word: \u0026[u8]) -\u003e LitColorFoundResult {\r\n    let cleaned_word = \u0026*word.to_ascii_lowercase();\r\n    match \u0026*word_so_far {\r\n        b\"\" =\u003e match cleaned_word {\r\n            b\"black\" | b\"silver\" | b\"gray\" | b\"maroon\" | b\"red\" | b\"purple\" | b\"fuchsia\"\r\n            | b\"navy\" | b\"teal\"\r\n            | b\"aquamarine\" | b\"azure\" | b\"beige\" | b\"bisque\" | b\"brown\" | b\"chartreuse\" | b\"chocolate\"\r\n            | b\"coral\" | b\"crimson\" | b\"cornsilk\" | b\"cyan\" | b\"firebrick\" | b\"gainsboro\"\r\n            | b\"gold\" | b\"goldenrod\" | b\"grey\" | b\"honeydew\" | b\"indigo\" | b\"ivory\" | b\"khaki\" \r\n            | b\"lawngreen\" | b\"linen\" | b\"magenta\" | b\"moccasin\" | b\"orchid\"\r\n            | b\"aliceblue\" | b\"antiquewhite\" | b\"blanchedalmond\" | b\"blueviolet\" | b\"burlywood\"\r\n            | b\"cadetblue\" | b\"cornflowerblue\" | b\"darkblue\" | b\"darkcyan\" | b\"darkgoldenrod\" \r\n            | b\"darkgray\" | b\"darkgreen\" | b\"darkgrey\" | b\"darkkhaki\" | b\"darkmagenta\"\r\n            | b\"darkolivegreen\" | b\"darkorange\" | b\"darkorchid\" | b\"darkred\" | b\"darksalmon\"\r\n            | b\"darkseagreen\" | b\"darkslateblue\" | b\"darkslategray\" | b\"darkslategrey\" | b\"darkturquoise\"\r\n            | b\"darkviolet\" | b\"deeppink\" | b\"deepskyblue\" | b\"dimgray\" | b\"dimgrey\" | b\"dodgerblue\"\r\n            | b\"floralwhite\" | b\"forestgreen\" | b\"ghostwhite\" | b\"greenyellow\"\r\n            | b\"hotpink\" | b\"indianred\" | b\"lavenderblush\" | b\"lemonchiffon\"\r\n            | b\"lightblue\" | b\"lightcoral\" | b\"lightcyan\" | b\"lightgoldenrodyellow\" | b\"lightgray\"\r\n            | b\"lightgreen\" | b\"lightgrey\" | b\"lightpink\" | b\"lightsalmon\" | b\"lightseagreen\"\r\n            | b\"lightskyblue\" | b\"lightslategray\" | b\"lightslategrey\" | b\"lightsteelblue\" | b\"lightyellow\"\r\n            | b\"limegreen\" | b\"mediumaquamarine\" | b\"mediumblue\" | b\"mediumorchid\" | b\"mediumpurple\"\r\n            | b\"mediumseagreen\" | b\"mediumslateblue\" | b\"mediumspringgreen\" | b\"mediumturquoise\"\r\n            | b\"mediumvioletred\" | b\"midnightblue\" | b\"mintcream\" | b\"mistyrose\" | b\"navajowhite\"\r\n            | b\"oldlace\" | b\"olivedrab\" | b\"orangered\" | b\"palegoldenrod\" | b\"palegreen\" | b\"paleturquoise\"\r\n            | b\"palevioletred\" | b\"papayawhip\" | b\"peachpuff\" | b\"peru\" | b\"pink\" | b\"plum\" | b\"powderblue\"\r\n            | b\"rebeccapurple\" | b\"rosybrown\" | b\"royalblue\" | b\"saddlebrown\" | b\"salmon\"\r\n            | b\"sandybrown\" | b\"seagreen\" | b\"seashell\" | b\"sienna\" | b\"skyblue\" | b\"slateblue\"\r\n            | b\"slategray\" | b\"slategrey\" | b\"snow\" | b\"springgreen\" | b\"steelblue\" | b\"tan\"\r\n            | b\"thistle\" | b\"tomato\" | b\"transparent\" | b\"turquoise\" | b\"violet\" | b\"wheat\"\r\n            | b\"whitesmoke\" | b\"yellowgreen\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"alice\" | b\"antique\" | b\"blanched\" | b\"blue\" | b\"burly\" | b\"cadet\" | b\"cornflower\"\r\n            | b\"corn\" | b\"dark\" | b\"deep\" | b\"dim\" | b\"dodger\" | b\"fire\" | b\"floral\" | b\"forest\"\r\n            | b\"ghost\" | b\"golden\" | b\"green\" | b\"honey\" | b\"hot\" | b\"indian\" | b\"lavender\"\r\n            | b\"lawn\" | b\"lemon\" | b\"light\" | b\"lime\" | b\"medium\" | b\"midnight\" | b\"mint\"\r\n            | b\"misty\" | b\"navajo\" | b\"old\" | b\"olive\" | b\"orange\" | b\"pale\" | b\"papaya\"\r\n            | b\"peach\" | b\"powder\" | b\"rebecca\" | b\"rosy\" | b\"royal\" | b\"saddle\" | b\"sandy\"\r\n            | b\"sea\" | b\"sky\" | b\"slate\" | b\"spring\" | b\"steel\" | b\"white\" | b\"yellow\" | b\"aqua\"\r\n            | b\"darkgolden\" | b\"darkolive\" | b\"darksea\" | b\"darkslate\" | b\"deepsky\"\r\n            | b\"lightgolden\" | b\"lightgoldenrod\" | b\"lightsea\" | b\"lightsky\" | b\"lightslate\"\r\n            | b\"mediumaqua\" | b\"mediumsea\" | b\"mediumslate\" | b\"mediumspring\"\r\n            | b\"mediumviolet\" | b\"palegolden\" | b\"paleviolet\" | b\"lightsteel\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"alice\" =\u003e  match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"antique\" =\u003e  match cleaned_word {\r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"aqua\" =\u003e match cleaned_word {\r\n            b\"marine\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"blanched\" =\u003e  match cleaned_word {\r\n            b\"almond\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"blue\" =\u003e  match cleaned_word {\r\n            b\"violet\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"burly\" =\u003e  match cleaned_word {\r\n            b\"wood\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"cadet\" =\u003e  match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"cornflower\" =\u003e  match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"corn\" =\u003e match cleaned_word {\r\n            b\"flower\" =\u003e LitColorFoundResult::CouldFind,\r\n            b\"silk\" =\u003e LitColorFoundResult::Found,\r\n            b\"flowerblue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"dark\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"cyan\" | b\"goldenrod\" | b\"gray\" | b\"green\" | b\"grey\" | b\"khaki\"\r\n            | b\"magenta\" | b\"olivegreen\" | b\"orange\" | b\"orchid\" | b\"red\" | b\"salmon\"\r\n            | b\"seagreen\" | b\"slateblue\" | b\"slategray\" | b\"slategrey\" | b\"turquoise\"\r\n            | b\"violet\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"golden\" | b\"olive\" | b\"sea\" | b\"slate\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"deep\" =\u003e match cleaned_word {\r\n            b\"pink\" | b\"skyblue\" =\u003e LitColorFoundResult::Found,\r\n            b\"sky\" =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"dim\" =\u003e match cleaned_word {\r\n            b\"gray\" | b\"grey\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"dodger\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"fire\" =\u003e match cleaned_word {\r\n            b\"brick\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"floral\" =\u003e match cleaned_word {\r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"forest\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"ghost\" =\u003e match cleaned_word { \r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"golden\" =\u003e match cleaned_word {\r\n            b\"rod\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"green\" =\u003e  match cleaned_word {\r\n            b\"yellow\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"honey\" =\u003e match cleaned_word {\r\n            b\"dew\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"hot\" =\u003e match cleaned_word {\r\n            b\"pink\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"indian\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lavender\" =\u003e match cleaned_word {\r\n            b\"blush\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"lawn\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lemon\" =\u003e match cleaned_word {\r\n            b\"chiffon\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"light\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"coral\" | b\"cyan\" | b\"goldenrodyellow\" | b\"gray\" | b\"green\" | b\"grey\"\r\n            | b\"pink\" | b\"salmon\" | b\"seagreen\" | b\"skyblue\" | b\"slategray\" | b\"slategrey\"\r\n            | b\"steelblue\" | b\"yellow\" \r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"goldenrod\" | b\"golden\" | b\"sea\" | b\"sky\" | b\"slate\" | b\"steel\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"steel\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lime\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"medium\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"orchid\" | b\"purple\" | b\"seagreen\" | b\"slateblue\" | b\"springgreen\"\r\n            | b\"turquoise\" | b\"violetred\"  | b\"aquamarine\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"sea\" | b\"slate\" | b\"spring\" | b\"violet\" | b\"aqua\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"spring\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"midnight\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mint\" =\u003e match cleaned_word {\r\n            b\"cream\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"misty\" =\u003e match cleaned_word {\r\n            b\"rose\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"navajo\" =\u003e match cleaned_word {\r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"old\" =\u003e match cleaned_word {\r\n            b\"lace\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"olive\" =\u003e match cleaned_word {\r\n            b\"drab\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"orange\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"pale\" =\u003e match cleaned_word {\r\n            b\"goldenrod\" | b\"green\" | b\"turquoise\" | b\"violetred\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"golden\" | b\"violet\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"papaya\" =\u003e match cleaned_word {\r\n            b\"whip\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"peach\" =\u003e match cleaned_word {\r\n            b\"puff\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"powder\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"rebecca\" =\u003e match cleaned_word {\r\n            b\"purple\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darkgolden\" =\u003e match cleaned_word {\r\n            b\"rod\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darkolive\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darksea\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darkslate\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"gray\" | b\"grey\" \r\n                =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        }\r\n        b\"deepsky\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightgolden\" =\u003e match cleaned_word {\r\n            b\"rodyellow\" =\u003e LitColorFoundResult::Found,\r\n            b\"rod\" =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightgoldenrod\" =\u003e match cleaned_word {\r\n            b\"yellow\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightsea\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightsky\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightslate\" =\u003e match cleaned_word {\r\n            b\"gray\" | b\"grey\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightsteel\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumsea\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumslate\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumspring\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumviolet\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumaqua\" =\u003e match cleaned_word {\r\n            b\"marine\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        }\r\n        b\"palegolden\" =\u003e match cleaned_word {\r\n            b\"rod\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"paleviolet\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"rosy\" =\u003e match cleaned_word {\r\n            b\"brown\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"royal\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"saddle\" =\u003e match cleaned_word {\r\n            b\"brown\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"sandy\" =\u003e match cleaned_word {\r\n            b\"brown\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"sea\" =\u003e match cleaned_word {\r\n            b\"green\" | b\"shell\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"sky\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"slate\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"gray\" | b\"grey\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"white\" =\u003e match cleaned_word {\r\n            b\"smoke\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"yellow\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        }\r\n        _ =\u003e LitColorFoundResult::Failed\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":14,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":15,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":16,"address":[],"length":0,"stats":{"Line":2233785415175766019}},{"line":17,"address":[],"length":0,"stats":{"Line":6557241057451442191}},{"line":19,"address":[],"length":0,"stats":{"Line":2810246167479189510}},{"line":20,"address":[],"length":0,"stats":{"Line":6773413839565225987}},{"line":23,"address":[],"length":0,"stats":{"Line":9655717601082343430}},{"line":24,"address":[],"length":0,"stats":{"Line":3891110078048108547}},{"line":25,"address":[],"length":0,"stats":{"Line":3170534137668829187}},{"line":31,"address":[],"length":0,"stats":{"Line":2089670227099910147}},{"line":34,"address":[],"length":0,"stats":{"Line":2017612633061982211}},{"line":35,"address":[],"length":0,"stats":{"Line":3674937295934324742}},{"line":44,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":57,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":59,"address":[],"length":0,"stats":{"Line":3819052484010180605}},{"line":60,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":16645304222761353212}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":16212958658533785596}},{"line":68,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":10016005571271983100}},{"line":72,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":84,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":9079256848778919932}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":92,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":93,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":98,"address":[],"length":0,"stats":{"Line":7926335344172072960}},{"line":99,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":102,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":104,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":108,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":7421932185906577404}},{"line":113,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":6269010681299730428}},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":125,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":133,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":141,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":142,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":144,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":145,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":149,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":153,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":157,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":160,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":161,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":165,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":169,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":170,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":172,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":173,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":174,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":178,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":182,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":183,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":185,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":186,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":187,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":188,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":189,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":190,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":194,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":198,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":202,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":206,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":210,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":214,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":218,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":219,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":221,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":222,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":223,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":225,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":226,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":227,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":228,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":229,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":233,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":237,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":241,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":249,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":2666130979403333628}},{"line":253,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":257,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":261,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":262,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":266,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":1729382256910270460}},{"line":270,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":271,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":1152921504606846972}},{"line":275,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":279,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":283,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":287,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":291,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":295,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":299,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":648518346341351420}},{"line":303,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":307,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":311,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":315,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":319,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":323,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":327,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":331,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":335,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":339,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":340,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":344,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":348,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":349,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":353,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":354,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":356,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":357,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":358,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":360,"address":[],"length":0,"stats":{"Line":0}}],"covered":183,"coverable":246},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","move_to.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct MoveToState {\r\n    count: u8,\r\n}\r\nimpl BasicState for MoveToState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"MoveTo\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::MoveTo {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::MoveTo { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::MoveTo { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl MoveToState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","multi_lit_num.rs"],"content":"use super::*;\r\nuse num_literal::get_number;\r\n\r\n#[derive(Debug, PartialEq)]\r\npub enum VarOrInt {\r\n    Var(SubStrData),\r\n    Int(i64),\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct MultiLitNumState {\r\n    first: bool,\r\n    any_vars: bool,\r\n}\r\n\r\nimpl ParseState for MultiLitNumState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            let locs = env.locs.take().unwrap_or_default();\r\n            self.first = false;\r\n\r\n            let (end, single_value) = if is_mandatory_close(word) {\r\n                (End::from_slice(\u0026word, env.global_index), Some(0))\r\n            } else {\r\n                (End::none(), None)\r\n            };\r\n\r\n            *env.expr = Expr::MultiLitNum {\r\n                str_start: word.pos + env.global_index,\r\n                locs,\r\n                end,\r\n                single_value,\r\n                values: Vec::new(),\r\n            };\r\n\r\n            if single_value.is_some() {\r\n                return MatchResult::Matched(word.pos, true);\r\n            }\r\n        }\r\n        if let Expr::MultiLitNum {\r\n            values,\r\n            end,\r\n            single_value,\r\n            ..\r\n        } = env.expr\r\n        {\r\n            if is_mandatory_close(word) {\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                if !self.any_vars {\r\n                    *single_value = Self::get_final_value(values);\r\n                }\r\n\r\n                MatchResult::Matched(word.pos, true)\r\n            } else {\r\n                //let lower = word.str.to_ascii_lowercase();\r\n                if let Some(var) = env.symbols.try_get_var(word, env.global_index) {\r\n                    self.any_vars = true;\r\n                    values.push(VarOrInt::Var(var));\r\n                } else if let Some(num_value) = get_number(word.str) {\r\n                    values.push(VarOrInt::Int(num_value % 10));\r\n                } else {\r\n                    values.push(VarOrInt::Int((word.len() as i64) % 10));\r\n                }\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"MultiLitNum\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl MultiLitNumState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            any_vars: false,\r\n        }\r\n    }\r\n    pub fn get_final_value(values: \u0026Vec\u003cVarOrInt\u003e) -\u003e Option\u003ci64\u003e {\r\n        let mut val = Some(0i64);\r\n        for i in values.into_iter() {\r\n            if let VarOrInt::Int(i_val) = *i {\r\n                if let Some(var) = val {\r\n                    val = var\r\n                        .checked_mul(10_i64)\r\n                        .and_then(|val| val.checked_add(i_val))\r\n                } else {\r\n                    //overflowed\r\n                    return None;\r\n                }\r\n            } else {\r\n                unreachable!()\r\n            }\r\n        }\r\n\r\n        val\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":3026418949592973313}},{"line":18,"address":[],"length":0,"stats":{"Line":3026418949592973313}},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":31,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":32,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":33,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":37,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":82,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":91,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":97,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":99,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":100,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":101,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":104,"address":[],"length":0,"stats":{"Line":1801439850948198401}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":28,"coverable":28},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","not.rs"],"content":"use super::*;\r\n\r\n/// state for num\r\n#[derive(Debug)]\r\npub struct NotState;\r\nimpl ParseState for NotState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // wait for non . word to start\r\n        if is_close(word) {\r\n            MatchResult::Continue(0)\r\n        } else {\r\n            // find close\r\n            let close = find_close_slice(rest, 0);\r\n            //close exists - match\r\n            if let Some(close) = close {\r\n                *env.expr = Expr::Not {\r\n                    locs: env.locs.take().unwrap_or_default(),\r\n                    str_start: word.pos + env.global_index,\r\n                    str_len: word.len(),\r\n                    word:word.str.to_ascii_lowercase(),\r\n                    end: End::from_slice(\u0026close.0, env.global_index),\r\n                };\r\n                env.nots.insert(word.str.to_ascii_lowercase());\r\n                MatchResult::Matched(close.0.pos, true)\r\n            } else {\r\n                // did not find close - fail\r\n                MatchResult::Failed\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Num\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl NotState {\r\n    pub fn new() -\u003e Self {\r\n        Self\r\n    }\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","num_literal.rs"],"content":"use core::str;\r\n\r\nuse super::*;\r\n#[derive(Debug)]\r\n\r\npub struct LiteralNumState {}\r\n\r\nimpl ParseState for LiteralNumState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // try parse number\r\n        let value = get_number(word.str);\r\n\r\n        // if value exists - match\r\n        if let Some(value) = value {\r\n            *env.expr = Expr::LitNum {\r\n                str_start: word.pos + env.global_index,\r\n                str_length: word.len(),\r\n                value,\r\n            };\r\n            MatchResult::Matched(rest.pos, false)\r\n        } else {\r\n            // word is not a number\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"NumLit\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl LiteralNumState {\r\n    pub fn new() -\u003e Self {\r\n        Self {}\r\n    }\r\n}\r\n\r\npub fn get_number(word: \u0026[u8]) -\u003e Option\u003ci64\u003e {\r\n    get_number_word(word).or_else(|| get_number_literal(word))\r\n}\r\n\r\nfn get_number_literal(mut word: \u0026[u8]) -\u003e Option\u003ci64\u003e {\r\n    let mut neg = 1i64;\r\n    if word.starts_with(b\"-\") {\r\n        neg = -1;\r\n        word = \u0026word[1..]\r\n    }\r\n\r\n    let number = || String::from_utf8(word[2..].to_vec()).ok();\r\n    let num = {\r\n        if word.starts_with(b\"0x\") {\r\n            i64::from_str_radix(\u0026number()?, 16)\r\n        } else if word.starts_with(b\"0o\") {\r\n            i64::from_str_radix(\u0026number()?, 8)\r\n        } else if word.starts_with(b\"0b\") {\r\n            i64::from_str_radix(\u0026number()?, 2)\r\n        } else {\r\n            let number = String::from_utf8(word.to_vec()).ok()?;\r\n            i64::from_str_radix(\u0026number, 10)\r\n        }\r\n    };\r\n    num.ok().and_then(|num| Some(num * neg))\r\n}\r\n\r\nfn get_number_word(word: \u0026[u8]) -\u003e Option\u003ci64\u003e {\r\n    let first_binding = word.to_ascii_lowercase();\r\n    let temp_binding = String::from_utf8_lossy(\u0026*\u0026first_binding);\r\n    let split_match: Vec\u003c\u0026str\u003e = temp_binding.split(\"-\").collect();\r\n    let mut rev_values = Vec::new();\r\n    //TODO: Enforce that each number must be less than the last, and you can't do like eleven-one\r\n    for item in split_match {\r\n        let next_value: i64 = match item {\r\n            \"and\" =\u003e continue,\r\n            \"zero\" =\u003e 0,\r\n            \"one\" =\u003e 1,\r\n            \"two\" =\u003e 2,\r\n            \"three\" =\u003e 3,\r\n            \"four\" =\u003e 4,\r\n            \"five\" =\u003e 5,\r\n            \"six\" =\u003e 6,\r\n            \"seven\" =\u003e 7,\r\n            \"eight\" =\u003e 8,\r\n            \"nine\" =\u003e 9,\r\n            \"ten\" =\u003e 10,\r\n            \"eleven\" =\u003e 11,\r\n            \"dozen\" =\u003e 12,\r\n            \"twelve\" =\u003e 12,\r\n            \"thirteen\" =\u003e 13,\r\n            \"fourteen\" =\u003e 14,\r\n            \"fifteen\" =\u003e 15,\r\n            \"sixteen\" =\u003e 16,\r\n            \"seventeen\" =\u003e 17,\r\n            \"eighteen\" =\u003e 18,\r\n            \"nineteen\" =\u003e 19,\r\n            \"twenty\" =\u003e 20,\r\n            \"score\" =\u003e 20,\r\n            \"thirty\" =\u003e 30,\r\n            \"forty\" =\u003e 40,\r\n            \"fifty\" =\u003e 50,\r\n            \"sixty\" =\u003e 60,\r\n            \"seventy\" =\u003e 70,\r\n            \"eighty\" =\u003e 80,\r\n            \"ninety\" =\u003e 90,\r\n            \"hundred\" =\u003e 100,\r\n            \"thousand\" =\u003e 1000,\r\n            \"million\" =\u003e 1000000,\r\n            \"billion\" =\u003e 1000000000,\r\n            _ =\u003e return None,\r\n        };\r\n        rev_values.push(next_value);\r\n    }\r\n    if rev_values.len() == 0 {\r\n        return None;\r\n    }\r\n    get_number_word_from_list(\u0026rev_values, 0, rev_values.len())\r\n}\r\n\r\nfn get_number_word_from_list(values: \u0026Vec\u003ci64\u003e, min_index: usize, max_index: usize) -\u003e Option\u003ci64\u003e {\r\n    let mut max_val = min_index;\r\n    for i in min_index + 1..max_index {\r\n        if values[i] \u003e values[max_val] {\r\n            max_val = i;\r\n        }\r\n    }\r\n    if max_index - min_index \u003e 1 {\r\n        match values[max_val] {\r\n            20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100 | 1000 | 10000 | 100000 | 1000000\r\n            | 1000000000 =\u003e (),\r\n            _ =\u003e return None,\r\n        }\r\n    }\r\n    let left_side_val = if max_val == min_index {\r\n        1\r\n    } else {\r\n        match get_number_word_from_list(values, min_index, max_val) {\r\n            Some(value) =\u003e value,\r\n            _ =\u003e return None,\r\n        }\r\n    };\r\n    let right_side_val = if max_val == max_index - 1 {\r\n        0\r\n    } else {\r\n        match get_number_word_from_list(values, max_val + 1, max_index) {\r\n            Some(value) =\u003e value,\r\n            _ =\u003e return None,\r\n        }\r\n    };\r\n    Some(left_side_val * values[max_val] + right_side_val)\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":11,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":14,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":23,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":38,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":39,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":42,"address":[],"length":0,"stats":{"Line":3242591731706757124}},{"line":43,"address":[],"length":0,"stats":{"Line":3242591731706757124}},{"line":48,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":53,"address":[],"length":0,"stats":{"Line":5980780305148018690}},{"line":54,"address":[],"length":0,"stats":{"Line":14123288431433875460}},{"line":57,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":58,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":59,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927938}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927938}},{"line":64,"address":[],"length":0,"stats":{"Line":2161727821137838084}},{"line":65,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":66,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":74,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":80,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":81,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":82,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":83,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":84,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":86,"address":[],"length":0,"stats":{"Line":18158513697557839876}},{"line":87,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189639682}},{"line":89,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":90,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":91,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":92,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":93,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":94,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":95,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":96,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":97,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":98,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":99,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":100,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":101,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":102,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":103,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":104,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":105,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":106,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":107,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":108,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":109,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":110,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":111,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":112,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":113,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":114,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":115,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":116,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":117,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":118,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":119,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":120,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":121,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":122,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":123,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":127,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":130,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":133,"address":[],"length":0,"stats":{"Line":4683743612465315842}},{"line":134,"address":[],"length":0,"stats":{"Line":4683743612465315842}},{"line":135,"address":[],"length":0,"stats":{"Line":5980780305148018690}},{"line":136,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":137,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":140,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":141,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":143,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":147,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":148,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":150,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":151,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":156,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":158,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":159,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":160,"address":[],"length":0,"stats":{"Line":0}}],"covered":88,"coverable":92},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","operator.rs"],"content":"use basic_func::BasicState;\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug)]\r\npub struct OperatorState {\r\n    fn_type: OperatorType,\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for OperatorState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        match self.fn_type {\r\n            OperatorType::Add =\u003e \"Add\",\r\n            OperatorType::Mult =\u003e \"Mult\",\r\n            OperatorType::Sub =\u003e \"Sub\",\r\n            OperatorType::Div =\u003e \"Div\",\r\n            OperatorType::Mod =\u003e \"Mod\",\r\n            OperatorType::Exp =\u003e \"Exp\",\r\n            OperatorType::Log =\u003e \"Log\",\r\n            OperatorType::LessThan =\u003e \"LessThan\",\r\n            OperatorType::GreaterThan =\u003e \"GreaterThan\",\r\n            OperatorType::And =\u003e \"And\",\r\n            OperatorType::Or =\u003e \"Or\",\r\n            OperatorType::Equals =\u003e \"Equals\",\r\n            OperatorType::Not =\u003e \"Not\",\r\n        }\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Operator {\r\n                locs,\r\n                func_type: self.fn_type,\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Operator { indexes, .. } = expr {\r\n            indexes.push(index);\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    // this is a mess\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match (self.fn_type, self.count) {\r\n            (OperatorType::Add, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Sub, 1) =\u003e CloseType::Able,\r\n            (OperatorType::Sub, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Mult, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Div, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Mod, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Exp, 1) =\u003e CloseType::Able,\r\n            (OperatorType::Exp, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Log, 1) =\u003e CloseType::Able,\r\n            (OperatorType::Log, 2) =\u003e CloseType::Force,\r\n            (OperatorType::LessThan, 2) =\u003e CloseType::Force,\r\n            (OperatorType::GreaterThan, 2) =\u003e CloseType::Force,\r\n            (OperatorType::And, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Or, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Equals, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Not, 1) =\u003e CloseType::Force,\r\n            _ =\u003e CloseType::Unable,\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Operator { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl OperatorState {\r\n    fn new(fn_type: OperatorType) -\u003e Self {\r\n        Self { fn_type, count: 0 }\r\n    }\r\n\r\n    pub fn new_add() -\u003e Self {\r\n        Self::new(OperatorType::Add)\r\n    }\r\n\r\n    pub fn new_sub() -\u003e Self {\r\n        Self::new(OperatorType::Sub)\r\n    }\r\n\r\n    pub fn new_mult() -\u003e Self {\r\n        Self::new(OperatorType::Mult)\r\n    }\r\n\r\n    pub fn new_div() -\u003e Self {\r\n        Self::new(OperatorType::Div)\r\n    }\r\n\r\n    pub fn new_mod() -\u003e Self {\r\n        Self::new(OperatorType::Mod)\r\n    }\r\n\r\n    pub fn new_exp() -\u003e Self {\r\n        Self::new(OperatorType::Exp)\r\n    }\r\n\r\n    pub fn new_log() -\u003e Self {\r\n        Self::new(OperatorType::Log)\r\n    }\r\n\r\n    pub fn new_less_than() -\u003e Self {\r\n        Self::new(OperatorType::LessThan)\r\n    }\r\n\r\n    pub fn new_greater_than() -\u003e Self {\r\n        Self::new(OperatorType::GreaterThan)\r\n    }\r\n\r\n    pub fn new_and() -\u003e Self {\r\n        Self::new(OperatorType::And)\r\n    }\r\n\r\n    pub fn new_or() -\u003e Self {\r\n        Self::new(OperatorType::Or)\r\n    }\r\n\r\n    pub fn new_equals() -\u003e Self {\r\n        Self::new(OperatorType::Equals)\r\n    }\r\n\r\n    pub fn new_not() -\u003e Self {\r\n        Self::new(OperatorType::Not)\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":13,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":31,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":34,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":35,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":36,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":37,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":38,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":39,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":40,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":41,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":44,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":57,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":58,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":89,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":98,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}}],"covered":24,"coverable":72},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","print.rs"],"content":"use alias::NoneState;\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct PrintState {\r\n    count: usize\r\n}\r\n\r\nimpl ParseState for PrintState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        let found_close = is_mandatory_close(word);\r\n\r\n        if self.count == 0 {\r\n            let mut end = End::none();\r\n\r\n            // \"pri .\" - useful for newline? - can change later\r\n            if found_close {\r\n                end = End::from_slice(\u0026word, env.global_index)\r\n            }\r\n\r\n            *env.expr = Expr::Print {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                indexes: Vec::new(),\r\n                single_word: None,\r\n                single_word_start: usize::MAX,\r\n                end,\r\n            };\r\n        }\r\n\r\n        if let Expr::Print { single_word, end, single_word_start, .. } = env.expr {\r\n            if found_close {\r\n                // set end\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                MatchResult::Matched(word.pos, true)\r\n            } else {\r\n                //get first word for \"pri hi.\"\r\n                if self.count == 0 {\r\n                   *single_word = Some(word.str.to_vec());\r\n                   *single_word_start = word.pos;\r\n                }\r\n                self.count += 1;\r\n                MatchResult::ContinueWith(word.pos, get_state!(NoneState::new_expr()))\r\n            }\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::Print { indexes, end, single_word, .. } = env.expr {\r\n            if let Some(index) = child_index {\r\n                indexes.push(index);\r\n                *single_word = None;\r\n            }else if self.count == 1 {\r\n                self.count+=1;\r\n                return MatchResult::Continue(0);\r\n            }else{\r\n                *single_word = None;\r\n            }\r\n            self.count+=1;\r\n            if is_mandatory_close(word){\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                MatchResult::Matched(word.pos, true)\r\n            }else if child_index.is_some(){\r\n                MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_expr_cont()))\r\n            }else{\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Print\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl PrintState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            count: 0\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":58,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":59,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":62,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":63,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":64,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":69,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":70,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":71,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":72,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":73,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":75,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":83,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":86,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":87,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":92,"address":[],"length":0,"stats":{"Line":2377900603251621888}}],"covered":19,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","rect.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct RectState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for RectState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Rect\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Rect {\r\n                locs,\r\n                indexes: [usize::MAX; 4],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Rect { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1..=3 =\u003e CloseType::Able,\r\n            /*\r\n                1-argument: width of square from current position\r\n                2-argument: width and height of rectangle from current position\r\n                3-argument: x and y coordinates then width of square\r\n                4-argument: x and y coordinate then width and height of rectangle\r\n                Draw from the middle\r\n            */\r\n            4 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Rect { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl RectState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":13,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":17,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","replace.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct ReplaceState {\r\n    count: u8,\r\n}\r\nimpl BasicState for ReplaceState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Replace\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Replace {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Replace {indexes, ..} = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count+=1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!()\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Replace {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl ReplaceState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","return_stat.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct ReturnState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for ReturnState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Return\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn can_happen(\u0026self, env: \u0026mut Environment) -\u003e bool {\r\n        env.parents.into_iter().any(|state| {\r\n            matches!(\r\n                env.before.get(state.expr_index),\r\n                Some(Expr::Function { .. })\r\n            )\r\n        })\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Return {\r\n                locs,\r\n                index: None,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, idx: usize) {\r\n        if let Expr::Return { index, .. } = expr {\r\n            *index = Some(idx);\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Able,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Return { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl ReturnState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":13,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":21,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":23,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":21,"coverable":21},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","rotate.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct RotateState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for RotateState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Rotate\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Rotate {\r\n                locs,\r\n                index: usize::MAX,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, idx: usize) {\r\n        if let Expr::Rotate { index, .. } = expr {\r\n            *index = idx;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Rotate { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl RotateState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","string_lit.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug, PartialEq)]\r\npub enum VarOrStr {\r\n    Var(SubStrData),\r\n    Str(Vec\u003cu8\u003e)\r\n}\r\n#[derive(Debug)]\r\npub struct LitStrState {first: bool, current_str_start: usize, current_str_end: usize}\r\n\r\nimpl ParseState for LitStrState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // let g = 0;\r\n        // black_box(\u0026g);\r\n        // println!(\"G{}\", g);\r\n        \r\n        if word.len() == 1 \u0026\u0026 word.str[0] == b'\"'{\r\n            if self.first {\r\n                self.first=false;\r\n                *env.expr = Expr::LitString {\r\n                    str_start: word.pos + env.global_index,\r\n                    str:Vec::new(),\r\n                    str_end: usize::MAX\r\n                };\r\n                self.current_str_start=word.pos + env.global_index + 1;\r\n                MatchResult::Continue(0)\r\n            } else {\r\n                if let Expr::LitString { str, str_end, .. } = env.expr{\r\n                    //Add current str\r\n                    self.current_str_end = word.pos + env.global_index;\r\n                    if self.current_str_end \u003e self.current_str_start {\r\n                        str.push(VarOrStr::Str(env.full_text[self.current_str_start..self.current_str_end].to_vec()));\r\n                    }\r\n                    *str_end = self.current_str_end;\r\n                    MatchResult::Matched(rest.pos, false)\r\n                }else{\r\n                    unreachable!()\r\n                }\r\n            }\r\n        } else {\r\n            if self.first {\r\n                MatchResult::Failed\r\n            } else {\r\n                if let Expr::LitString { str, .. } = env.expr{\r\n                    if let Some(var) = env.symbols.try_get_var(word, env.global_index){\r\n                        self.current_str_end = word.pos + env.global_index;\r\n                        if self.current_str_end \u003e self.current_str_start {\r\n                            str.push(VarOrStr::Str(env.full_text[self.current_str_start..self.current_str_end].to_vec()));\r\n                        }\r\n                        str.push(VarOrStr::Var(var));\r\n                        self.current_str_start = rest.pos;\r\n                    }\r\n                    MatchResult::Continue(0)\r\n                }else{\r\n                    unreachable!()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"StringLit\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl LitStrState {\r\n    pub fn new() -\u003e Self {\r\n        Self {first: true, current_str_start: usize::MAX, current_str_end: usize::MAX}\r\n    }\r\n}\r\n\r\n//pri hi. pri hello world. pri \"hello world\".\r\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":75,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":78,"address":[],"length":0,"stats":{"Line":4539628424389459972}},{"line":79,"address":[],"length":0,"stats":{"Line":4539628424389459972}},{"line":84,"address":[],"length":0,"stats":{"Line":4539628424389459970}}],"covered":5,"coverable":5},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","stroke.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct StrokeState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for StrokeState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Stroke\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Stroke {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Stroke { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Stroke { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl StrokeState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","title.rs"],"content":"use bstr::ByteSlice;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct TitleState {\r\n    parsing_names: bool,\r\n    is_author_closed: bool,\r\n    data: Title,\r\n}\r\nimpl ParseState for TitleState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.parsing_names {\r\n            // names cannot be more than 255\r\n            if word.len() \u003e 255 {\r\n                return MatchResult::Continue(0);\r\n            }\r\n            let separator = Self::is_separator(word.str);\r\n            // is name\r\n            if separator.close_count == 0 {\r\n                if self.is_author_closed {\r\n                    // first author already done\r\n                    if self.data.authors.len() \u003e= 1 {\r\n                        self.add_imports(word.str, word.pos);\r\n                    }\r\n                    self.data\r\n                        .authors\r\n                        .push((word.str.to_vec(), word.pos, word.str.len()));\r\n                } else {\r\n                    // will always exist\r\n                    let author = self.data.authors.last_mut().unwrap();\r\n                    author.0.push(b' ');\r\n                    author.0.extend_from_slice(\u0026word.str);\r\n                    author.2 = word.end() - author.1;\r\n                    // second author started\r\n                    if self.data.authors.len() \u003e= 2 {\r\n                        self.add_imports(word.str, word.pos);\r\n                    }\r\n                }\r\n                self.is_author_closed = false;\r\n                MatchResult::Continue(0)\r\n                // is name close\r\n            } else if separator.only_forced {\r\n                self.is_author_closed = true;\r\n                self.data.delim.push((word.pos, separator.close_length));\r\n\r\n                MatchResult::Continue(0)\r\n                // is total close\r\n            } else {\r\n                self.data.delim.push((word.pos, separator.close_length));\r\n                let title = mem::replace(\u0026mut self.data, Title::new());\r\n                *env.expr = Expr::Title { data: title };\r\n                MatchResult::Matched(word.pos, true)\r\n            }\r\n        } else if word.len() \u003e= 2 \u0026\u0026 word.str.to_ascii_lowercase() == b\"by\" {\r\n            self.data\r\n                .title\r\n                .extend_from_slice(\u0026env.full_text[..word.pos].trim());\r\n            self.data.by_start = word.pos;\r\n            self.parsing_names = true;\r\n\r\n            MatchResult::Continue(0)\r\n        } else {\r\n            let slice = find_newline(\u0026rest, 0);\r\n            if let Some(newline) = slice {\r\n                let offset = newline.pos - rest.pos;\r\n                MatchResult::Continue(offset)\r\n            // did not find another new line -- poem has ended -- will never match\r\n            } else {\r\n                MatchResult::Failed\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Title\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::None\r\n    }\r\n}\r\n\r\nimpl TitleState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            parsing_names: false,\r\n            is_author_closed: true,\r\n            data: Title::new(),\r\n        }\r\n    }\r\n\r\n    ///returns and optinal length of the close\r\n    fn is_separator(str: \u0026[u8]) -\u003e CloseData {\r\n        if str.len() \u003e= 3 \u0026\u0026 str == b\"and\" {\r\n            CloseData {\r\n                close_count: 1,\r\n                close_length: 3,\r\n                only_forced: true,\r\n            }\r\n        } else if str.len() \u003e= 1 \u0026\u0026 str == b\"\u0026\" {\r\n            CloseData {\r\n                close_count: 1,\r\n                close_length: 1,\r\n                only_forced: true,\r\n            }\r\n        } else {\r\n            get_close_data(str)\r\n        }\r\n    }\r\n    fn add_imports(\u0026mut self, name: \u0026[u8], index: usize) {\r\n        let lower_name = name.to_ascii_lowercase();\r\n        let imports = Import::get_all();\r\n        if let Some((offset, _, imp_index)) =\r\n            parser_structs::try_get_best_val(\u0026lower_name, \u0026mut imports.iter().map(|e| e.1), \u0026|_| {\r\n                true\r\n            })\r\n        {\r\n            self.data.imports.push((\r\n                imports[imp_index].0,\r\n                offset as usize + index,\r\n                imports[imp_index].1.len() as u8,\r\n            ))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","var.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct VarState;\r\nimpl ParseState for VarState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // is varible in scope\r\n        if let Some(var) = env.symbols.try_get_var(\u0026word, env.global_index) {\r\n            *env.expr = Expr::Var { var };\r\n            MatchResult::Matched(rest.pos, false)\r\n        } else {\r\n            // future words could be varible names\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Var\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl VarState {\r\n    pub fn new() -\u003e Self {\r\n        Self\r\n    }\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":4251398048237748226}},{"line":8,"address":[],"length":0,"stats":{"Line":5260204364768739330}},{"line":13,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":28,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":29,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":32,"address":[],"length":0,"stats":{"Line":4251398048237748228}},{"line":33,"address":[],"length":0,"stats":{"Line":4251398048237748228}},{"line":37,"address":[],"length":0,"stats":{"Line":4251398048237748226}},{"line":38,"address":[],"length":0,"stats":{"Line":4251398048237748226}}],"covered":9,"coverable":9},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","while_stat.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct WhileState {\r\n    has_condition: bool,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for WhileState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if !self.has_condition {\r\n            *env.expr = Expr::While {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            env.symbols.add_layer();\r\n            // setup child state\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        } else if self.has_stat {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n        } else {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::While { indexes, end, .. } = env.expr {\r\n            if !self.has_condition {\r\n                //add child and find stats\r\n                if let Some(index) = child_index {\r\n                    self.has_condition = true;\r\n                    indexes.push(index);\r\n                    MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n                } else {\r\n                    // if child match fail, I can never succeed\r\n                    MatchResult::Failed\r\n                }\r\n            } else {\r\n                //and stat child\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if self.has_stat \u0026\u0026 is_mandatory_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"While\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl WhileState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            has_condition: false,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":10,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":11,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":12,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":16,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":18,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":70,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":73,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":74,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":13,"coverable":16},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","word_num.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n\r\n/// state for num\r\n#[derive(Debug)]\r\npub struct WordNumState {\r\n    first: bool,\r\n}\r\nimpl ParseState for WordNumState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            *env.expr = Expr::WordNum {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                str_start: usize::MAX,\r\n                str_len: 0,\r\n                end: End::none(),\r\n            };\r\n            self.first = false;\r\n        }\r\n\r\n        // wait for non . word to start\r\n        if is_close(word) {\r\n            MatchResult::Continue(0)\r\n        } else {\r\n            // find close\r\n            let close = find_close_slice(rest, 0);\r\n            //close exists - match\r\n            if let Some(close) = close {\r\n                if let Expr::WordNum {\r\n                    str_start,\r\n                    str_len,\r\n                    end,\r\n                    ..\r\n                } = env.expr\r\n                {\r\n                    *str_start = word.pos + env.global_index;\r\n                    *str_len = word.len();\r\n                    *end = End::from_slice(\u0026close.0, env.global_index);\r\n                }\r\n\r\n                MatchResult::Matched(close.0.pos, true)\r\n            } else {\r\n                // did not find close - fail\r\n                MatchResult::Failed\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"WordNum\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl WordNumState {\r\n    pub fn new() -\u003e Self {\r\n        Self { first: true }\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":12,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":16,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":23,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":62,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":24,"coverable":25},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser.rs"],"content":"#![allow(dead_code)]\r\n#[path = \"parser_source.rs\"]\r\npub(crate) mod parser_source;\r\nuse bstr::ByteSlice;\r\npub(crate) use parser_source::*;\r\n// other stucts\r\n#[path = \"parser_structs.rs\"]\r\npub(crate) mod parser_structs;\r\npub(crate) use parser_structs::*;\r\n\r\nmod alias;\r\npub(crate) mod alias_data;\r\nmod append;\r\nmod assign;\r\nmod basic_func;\r\nmod call_func;\r\nmod color;\r\nmod delete;\r\nmod else_stat;\r\nmod fill;\r\nmod find;\r\nmod foreach;\r\nmod function;\r\nmod if_stat;\r\nmod index;\r\nmod len;\r\nmod list;\r\nmod litcolor;\r\nmod litcolor_data;\r\nmod move_to;\r\nmod not;\r\nmod operator;\r\nmod replace;\r\npub(crate) mod string_lit;\r\nmod stroke;\r\nmod title;\r\nmod var;\r\nmod while_stat;\r\n\r\nmod bezier;\r\nmod circle;\r\nmod line;\r\nmod print;\r\nmod rect;\r\nmod return_stat;\r\nmod rotate;\r\n\r\nmod line_width;\r\npub(crate) mod multi_lit_num;\r\nmod num_literal;\r\nmod word_num;\r\n\r\n#[path = \"testing/mod.rs\"]\r\nmod testing;\r\n\r\nuse crate::commands::*;\r\nuse rangemap::RangeSet;\r\nuse std::{collections::HashMap, fmt::Debug, mem};\r\n\r\nuse alias_data::AliasData;\r\n\r\n#[derive(Debug, PartialEq, Clone, Copy, Hash, Eq)]\r\npub enum Import {\r\n    List,\r\n    Func,\r\n    Graph,\r\n}\r\n\r\nimpl Import {\r\n    pub fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        match self {\r\n            Import::List =\u003e \"List\",\r\n            Import::Func =\u003e \"Func\",\r\n            Import::Graph =\u003e \"Graph\",\r\n        }\r\n    }\r\n    pub fn get_all() -\u003e \u0026'static [(Import, \u0026'static [u8])] {\r\n        \u0026[\r\n            (Import::List, b\"list\"),\r\n            (Import::Func, b\"func\"),\r\n            (Import::Graph, b\"graph\"),\r\n        ]\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Title {\r\n    pub title: Vec\u003cu8\u003e,\r\n    // the imports: (name, position, length)\r\n    pub authors: Vec\u003c(Vec\u003cu8\u003e, usize, usize)\u003e,\r\n    // the imports: (type, position, length)\r\n    pub imports: Vec\u003c(Import, usize, u8)\u003e,\r\n    // the sepatators: (position, length)\r\n    pub delim: Vec\u003c(usize, u8)\u003e,\r\n    // the start of \"by\"\r\n    pub by_start: usize,\r\n}\r\nimpl Title {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            title: Vec::new(),\r\n            authors: Vec::new(),\r\n            imports: Vec::new(),\r\n            delim: Vec::new(),\r\n            by_start: usize::MAX,\r\n        }\r\n    }\r\n}\r\n// impl Title{\r\n//     pub fn empty()-\u003eSelf{\r\n//         Self {\r\n//             title: b\"No Title\".to_vec(),\r\n//             authors: vec![(b\"No Author\".to_vec()],\r\n//             imports: Vec::new(),\r\n//             delim: Vec::new(),\r\n//         }\r\n//     }\r\n// }\r\n///The data that is currently parsed\r\n#[derive(Debug)]\r\npub struct ParsedData\u003c'a\u003e {\r\n    ///the array of parsed exprs\r\n    pub exprs: ExprArena,\r\n    ///the start indexes of statements\r\n    pub stat_starts: Vec\u003cusize\u003e,\r\n    ///the set of current varibles\r\n    pub symbols: SymbolSet,\r\n    /// the ignored values\r\n    pub nots: IgnoreSet,\r\n    ///the parserSource that is used\r\n    pub source: ParserSource\u003c'a\u003e,\r\n    // ///the title and authors\r\n    // pub title: Option\u003cTitle\u003e,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Parser\u003c'a\u003e {\r\n    ///the currently parsed data\r\n    pub data: ParsedData\u003c'a\u003e,\r\n    ///the stack of states\r\n    stack: Vec\u003cState\u003e,\r\n    ///the last state that was dropped (if the last step Matched or Failed)\r\n    last_state: Option\u003cState\u003e,\r\n    ///is the parser currently paring or line or did last step end (see ParserResult::is_end)\r\n    parsing_line: bool,\r\n    ///the global position without respect to ParserSource buffers\r\n    pos: usize,\r\n    ///the last match result\r\n    last_result: LastMatchResult,\r\n    ///the static alias data\r\n    aliases: AliasData,\r\n    ///the number of times the current slice should repeat\r\n    repeat_count: u8,\r\n    /// the index of the last matched state\r\n    stat_indexes: Vec\u003cusize\u003e,\r\n    /// the hash map of ranges of failed exprs\r\n    cached_fails: HashMap\u003c\u0026'static str, RangeSet\u003cusize\u003e\u003e,\r\n    ///does the parser need to parse a title\r\n    parse_title: bool,\r\n}\r\n\r\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\r\n    ///make a new parser with a source and command flags\r\n    pub fn new(source: ParserSource\u003c'a\u003e, flags: ParserFlags) -\u003e Self {\r\n        // let title = (!flags.title).then(|| Title {\r\n        //     title: b\"No Title\".to_vec(),\r\n        //     author: vec![b\"No Author\".to_vec()],\r\n        //     imports:\r\n        // });\r\n        let aliases = if flags.title {\r\n            AliasData::none()\r\n        } else {\r\n            AliasData::all()\r\n        };\r\n\r\n        Parser {\r\n            data: ParsedData {\r\n                exprs: ExprArena { vec: Vec::new() },\r\n                stat_starts: Vec::new(),\r\n                symbols: SymbolSet::new(),\r\n                nots: IgnoreSet::new(),\r\n                source,\r\n                // title,\r\n            },\r\n            parse_title: flags.title,\r\n            stack: Vec::new(),\r\n            last_state: None,\r\n            pos: 0,\r\n            parsing_line: false,\r\n            last_result: LastMatchResult::None,\r\n            aliases,\r\n            repeat_count: 0,\r\n            stat_indexes: Vec::new(),\r\n            cached_fails: HashMap::new(),\r\n        }\r\n    }\r\n    ///get the last state\r\n    pub fn get_last_state\u003c'b\u003e(\u0026'b self) -\u003e Option\u003c\u0026'b State\u003e {\r\n        self.last_state.as_ref().or_else(|| self.stack.last())\r\n    }\r\n\r\n    ///get the name of the last state\r\n    pub fn get_last_state_name(\u0026self) -\u003e \u0026'static str {\r\n        self.get_last_state()\r\n            .map_or(\u0026\"None\", |state| state.state.get_name())\r\n    }\r\n\r\n    ///get the current stack and length\r\n    pub fn get_parser_stack(\u0026self) -\u003e (String, usize) {\r\n        let mut str = self.stack.iter().fold(String::new(), |mut str, state| {\r\n            str += \u0026format!(\"{}:{}, \", state.state.get_name(), state.last_parse);\r\n            str\r\n        });\r\n        str.pop();\r\n        str.pop();\r\n        (str, self.stack.len())\r\n    }\r\n\r\n    ///get the slice that was last used + index\r\n    pub fn get_last_word\u003c'b\u003e(\u0026'b self) -\u003e (\u0026'b [u8], usize) {\r\n        // (if self.last_result == LastMatchResult::Failed {\r\n        //     self.get_last_state()\r\n        // } else {\r\n        //     self.stack.last()\r\n        // })\r\n        self.get_last_state().map_or((b\"\", usize::MAX), |state| {\r\n            (\r\n                Self::get_slice(self.data.source.get_line(), state.last_parse)\r\n                    .0\r\n                    .str,\r\n                state.last_parse,\r\n            )\r\n        })\r\n    }\r\n\r\n    ///convert the parser into its data\r\n    ///also drops the stdin from the ParserSource\r\n    pub fn into_data(mut self) -\u003e ParsedData\u003c'a\u003e {\r\n        self.data.source.drop_input();\r\n        self.data\r\n    }\r\n}\r\n\r\n///the parser - Woah!!\r\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\r\n    ///step the parser\r\n    ///\r\n    pub fn step(\u0026mut self) -\u003e ParserResult {\r\n        let is_first = !self.parsing_line;\r\n        if is_first {\r\n            // push match stat on first step of line\r\n            if !self.setup_first() {\r\n                return ParserResult::NoInput;\r\n            } else {\r\n                return ParserResult::Start;\r\n            }\r\n        }\r\n        //debug time\r\n        // let _debug = only_debug!(Vec::from_iter(\r\n        //     self.stack.iter().map(|x| (x.expr_index, x.last_parse))\r\n        // ));\r\n        // let _debug2 = only_debug!(Vec::from_iter(\r\n        //     self.stack.iter().map(|x| x.state.get_name())\r\n        // ));\r\n        // let _expr = only_debug!(self.data.exprs.vec);\r\n        // let _expr2 = only_debug!(lisp_like_writer::write(\r\n        //     \u0026self.data.exprs,\r\n        //     \u0026self.data.stat_starts\r\n        // ));\r\n        // let _expr_short = only_debug!(Vec::from_iter(self.data.exprs.vec.iter().map(|e| {\r\n        //     let mut str = format!(\"{:?}\", e);\r\n        //     str.truncate(str.find(\" \").unwrap_or(str.len()));\r\n        //     str\r\n        // })));\r\n        // let _last = only_debug!(self.last_result);\r\n\r\n        self.last_state = None;\r\n        // get curr frame\r\n        let stack_index = self.stack.len() - 1;\r\n        let (parents, frame_arr) = self.stack.split_at_mut(stack_index);\r\n        let frame = \u0026mut frame_arr[0];\r\n\r\n        let id = frame.state.get_name();\r\n        // does the failing range of the state include the current parsing location\r\n        let must_fail = self\r\n            .cached_fails\r\n            .get(id)\r\n            .is_some_and(|range| range.contains(\u0026frame.last_parse));\r\n\r\n        if must_fail \u0026\u0026 !cfg!(feature = \"no-cache\") {\r\n            self.failed_func();\r\n            return ParserResult::CachedFail;\r\n        }\r\n        // should always be in bounds\r\n        // spilt at mut for borrow safety\r\n        // get (parents, this[0] and children[1..])\r\n        let parents_this = self.data.exprs.vec.split_at_mut(frame.expr_index);\r\n        //let _splits1 = format!(\"{:?}\", parents_this);\r\n        // get (this, children)\r\n        let this_children = parents_this.1.split_at_mut_checked(1);\r\n        //let _splits = format!(\"{:?} {:?}\", _splits1, this_children);\r\n\r\n        // default_expr is used on failing back to a none state,\r\n        // the corrisponding expr no longer exists\r\n        let mut expr = \u0026mut Expr::NoneExpr;\r\n        let mut after: \u0026mut [Expr] = \u0026mut [];\r\n        let before = parents_this.0;\r\n        if let Some(split) = this_children {\r\n            //should always be safe\r\n            expr = split.0.first_mut().unwrap();\r\n            after = split.1;\r\n        }\r\n\r\n        // let _self_expr = format!(\"{:?}\", expr);\r\n        //black_box(\u0026_debug);\r\n        //let mut last_stat = None;\r\n\r\n        // // // if last expr matched\r\n        // if let Some(index) = self.last_match_index {\r\n        //     // let last_stat_index = self.data.exprs[last_stat];\r\n        //     last_stat = split1.0.get_mut(index);\r\n        // }\r\n\r\n        // setup slice\r\n        let line = self.data.source.get_line();\r\n        let mut start = frame.last_parse;\r\n        let (mut word, mut rest) = Self::get_slice(line, start);\r\n\r\n        //New ignore code location\r\n        while self.data.nots.try_get_val(\u0026word, 0).is_some() {\r\n            start = rest.pos;\r\n            (word, rest) = Self::get_slice(line, start);\r\n        }\r\n\r\n        // setup env\r\n        let mut env = Environment {\r\n            expr,\r\n            parents,\r\n            after,\r\n            before,\r\n            last_stat_index: self.stat_indexes.last().cloned(),\r\n            expr_index: frame.expr_index,\r\n            symbols: \u0026mut self.data.symbols,\r\n            nots: \u0026mut self.data.nots,\r\n            locs: None,\r\n            global_index: self.pos,\r\n            aliases: \u0026self.aliases,\r\n            full_text: line,\r\n        };\r\n\r\n        let last_result = mem::replace(\u0026mut self.last_result, LastMatchResult::None);\r\n\r\n        // run step function\r\n        let mut result = match last_result {\r\n            LastMatchResult::None | LastMatchResult::Continue =\u003e {\r\n                frame.state.step(\u0026mut env, \u0026word, \u0026rest)\r\n            }\r\n            LastMatchResult::New(locs) =\u003e {\r\n                env.locs = locs;\r\n                frame.state.step(\u0026mut env, \u0026word, \u0026rest)\r\n            }\r\n            LastMatchResult::Matched(child_index) =\u003e {\r\n                frame\r\n                    .state\r\n                    .step_match(\u0026mut env, Some(child_index), \u0026word, \u0026rest)\r\n            }\r\n            LastMatchResult::Failed =\u003e frame.state.step_match(\u0026mut env, None, \u0026word, \u0026rest),\r\n        };\r\n\r\n        // run aftermath\r\n        let new_locs = env.locs.take();\r\n\r\n        // reached end of line - upgrade result to failed\r\n        if word.len() == 0 \u0026\u0026 matches!(result, MatchResult::Continue(0)) {\r\n            result = MatchResult::Failed;\r\n        }\r\n\r\n        match result {\r\n            // I matched - return to last expr on stack with success\r\n            MatchResult::Matched(index, bool) =\u003e self.matched_func(index, bool),\r\n            // continue parsing child\r\n            MatchResult::ContinueWith(index, state) =\u003e {\r\n                self.continue_with_func(index, state, new_locs)\r\n            }\r\n            // continue with me\r\n            MatchResult::Continue(index) =\u003e self.continue_func(rest.pos + index),\r\n            // I failed, go back on stack with fail\r\n            MatchResult::Failed =\u003e self.failed_func(),\r\n        }\r\n    }\r\n\r\n    ///this function is called if the step fails\r\n    fn failed_func(\u0026mut self) -\u003e ParserResult {\r\n        let state = self.stack.pop().unwrap();\r\n\r\n        let state_type = state.state.get_type();\r\n        if state_type == StateType::Stat {\r\n            // remove self\r\n            while self\r\n                .stat_indexes\r\n                .last()\r\n                .is_some_and(|index| *index \u003e state.expr_index)\r\n            {\r\n                self.stat_indexes.pop();\r\n            }\r\n        } else {\r\n            //insert the range of parsed words into map\r\n            let id = state.state.get_name();\r\n            self.cached_fails\r\n                .entry(id)\r\n                .or_insert(RangeSet::new())\r\n                .insert(state.first_parse..state.last_parse + 1);\r\n        }\r\n\r\n        let state_pos = state.expr_index;\r\n        self.data.exprs.vec.truncate(state_pos);\r\n        //let _test = format!(\"{:?}\", state);\r\n        self.repeat_count = 0;\r\n\r\n        self.last_state = Some(state);\r\n\r\n        self.last_result = LastMatchResult::Failed;\r\n        // failed final stat - couldn't parse anything on line\r\n        if self.stack.is_empty() {\r\n            self.parsing_line = false;\r\n            self.parse_title = false;\r\n            self.data.stat_starts.pop();\r\n            ParserResult::FailedLine\r\n        } else {\r\n            // setup result for next step\r\n            ParserResult::Failed\r\n        }\r\n    }\r\n\r\n    ///this function is called if the step coninues\r\n    fn continue_func(\u0026mut self, new_index: usize) -\u003e ParserResult {\r\n        let stack_index = self.stack.len() - 1;\r\n        let frame = \u0026mut self.stack[stack_index];\r\n\r\n        self.repeat_count = 0;\r\n        // change match starting location to after word\r\n        frame.last_parse = new_index;\r\n\r\n        self.last_result = LastMatchResult::Continue;\r\n\r\n        ParserResult::Continue\r\n    }\r\n    ///this function is called if the step coninues with\r\n    fn continue_with_func(\r\n        \u0026mut self,\r\n        index: usize,\r\n        state: Box\u003cdyn ParseState\u003e,\r\n        locs: Option\u003cVec\u003cusize\u003e\u003e,\r\n    ) -\u003e ParserResult {\r\n        let mut expr_index = self.data.exprs.vec.len();\r\n        self.repeat_count = 0;\r\n        // replace none exprs\r\n        if self.data.exprs.vec.last().is_some_and(|e| e.is_none()) {\r\n            self.data.exprs.vec.pop();\r\n            expr_index -= 1;\r\n        }\r\n        self.data.exprs.vec.push(Expr::NoneExpr);\r\n        self.stack.push(State {\r\n            expr_index,\r\n            first_parse: index,\r\n            last_parse: index,\r\n            state,\r\n        });\r\n\r\n        self.last_result = LastMatchResult::New(locs);\r\n\r\n        ParserResult::ContinueWith\r\n    }\r\n\r\n    ///this function is called if the step matches\r\n    fn matched_func(\u0026mut self, mut index: usize, closed: bool) -\u003e ParserResult {\r\n        let state = self.stack.pop().unwrap();\r\n        let expr_index = state.expr_index;\r\n        if state.state.get_type() == StateType::Stat {\r\n            // add self\r\n            self.stat_indexes.push(expr_index);\r\n            // stats can change parse ablility -- reset cached fails\r\n            self.cached_fails = HashMap::new();\r\n        }\r\n        self.last_state = Some(state);\r\n\r\n        // matched final stat\r\n        if self.stack.is_empty() {\r\n            if self.parse_title {\r\n                if let Expr::Title { data } = \u0026self.data.exprs[expr_index] {\r\n                    self.aliases = AliasData::new(\u0026mut data.imports.iter().map(|e| \u0026e.0))\r\n                } else {\r\n                    unreachable!()\r\n                };\r\n            }\r\n            self.parse_title = false;\r\n            // setup next\r\n            self.add_new_start_state(index);\r\n            ParserResult::MatchedLine\r\n        } else {\r\n            if closed {\r\n                let line = self.data.source.get_line();\r\n                self.repeat_count += 1;\r\n                // get needed counts\r\n                let cd = get_close_data(\u0026line[index..]);\r\n                if self.repeat_count \u003e= cd.close_count {\r\n                    index += cd.close_length as usize;\r\n                    self.repeat_count = 0;\r\n                }\r\n            }\r\n            // setup result for next step\r\n            self.last_result = LastMatchResult::Matched(expr_index);\r\n            let parent_state = self.stack.last_mut().unwrap();\r\n            parent_state.last_parse = index;\r\n\r\n            // remove parent expr from cachefail map\r\n            self.cached_fails.remove(parent_state.state.get_name());\r\n            ParserResult::Matched\r\n        }\r\n    }\r\n    ///get a (word,rest) that starts at start\r\n    fn get_slice(line: \u0026[u8], mut start: usize) -\u003e (Slice, Slice) {\r\n        //let line = line.as_bytes();\r\n        start = start.min(line.len());\r\n\r\n        let slice = Slice {\r\n            str: \u0026line[start..],\r\n            pos: start,\r\n        };\r\n        get_next_slice(\u0026slice, 0)\r\n    }\r\n    ///setup the a new line for parsing\r\n    fn setup_first(\u0026mut self) -\u003e bool {\r\n        let line = self.data.source.get_line();\r\n        self.pos += line.len();\r\n        let data = self.data.source.new_line();\r\n        if let Some(data) = data {\r\n            let found_data = data.trim().len() \u003e 0;\r\n            if found_data {\r\n                self.add_new_start_state(0);\r\n                self.parsing_line = true;\r\n            }\r\n            found_data\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n    ///setup a noneStat on the stack\r\n    fn add_new_start_state(\u0026mut self, new_index: usize) {\r\n        // if need to parse title -- put it on stack\r\n        let state = if self.parse_title {\r\n            get_state!(title::TitleState::new())\r\n        } else {\r\n            get_state!(alias::NoneState::new_stat_cont())\r\n        };\r\n\r\n        // push match stat on first step of line\r\n        let expr_index = self.data.exprs.vec.len();\r\n\r\n        self.data.exprs.vec.push(Expr::NoneStat);\r\n\r\n        self.stack.push(State {\r\n            expr_index,\r\n            first_parse: new_index,\r\n            last_parse: new_index,\r\n            state,\r\n        });\r\n\r\n        self.data.stat_starts.push(expr_index);\r\n        self.last_result = LastMatchResult::None;\r\n        self.cached_fails = HashMap::new();\r\n    }\r\n}\r\n\r\n// /// https://stackoverflow.com/questions/31101915/how-to-implement-trim-for-vecu8\r\n// pub fn trim_ascii_whitespace(x: \u0026[u8]) -\u003e \u0026[u8] {\r\n//     let from = match x.iter().position(|x| !x.is_ascii_whitespace()) {\r\n//         Some(i) =\u003e i,\r\n//         None =\u003e return \u0026x[0..0],\r\n//     };\r\n//     let to = x.iter().rposition(|x| !x.is_ascii_whitespace()).unwrap();\r\n//     \u0026x[from..=to]\r\n// }\r\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":78,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":79,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":80,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":81,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":170,"address":[],"length":0,"stats":{"Line":13690942867206307840}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":16068843470457929727}},{"line":177,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":185,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":186,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":193,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":194,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":239,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":240,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":248,"address":[],"length":0,"stats":{"Line":11889503016258109441}},{"line":249,"address":[],"length":0,"stats":{"Line":11889503016258109441}},{"line":250,"address":[],"length":0,"stats":{"Line":11889503016258109441}},{"line":252,"address":[],"length":0,"stats":{"Line":13763000461244235824}},{"line":253,"address":[],"length":0,"stats":{"Line":16068843470457929776}},{"line":255,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":277,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":279,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":280,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":281,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":283,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":285,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":286,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":287,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":288,"address":[],"length":0,"stats":{"Line":4683743612465315793}},{"line":290,"address":[],"length":0,"stats":{"Line":936748722493063171}},{"line":291,"address":[],"length":0,"stats":{"Line":936748722493063169}},{"line":292,"address":[],"length":0,"stats":{"Line":936748722493063169}},{"line":297,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":300,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":305,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":306,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":307,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":308,"address":[],"length":0,"stats":{"Line":7421932185906577358}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":15636497906230362088}},{"line":331,"address":[],"length":0,"stats":{"Line":13}},{"line":332,"address":[],"length":0,"stats":{"Line":13}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":13618885273168379829}},{"line":358,"address":[],"length":0,"stats":{"Line":9871890383196127232}},{"line":359,"address":[],"length":0,"stats":{"Line":9871890383196127232}},{"line":360,"address":[],"length":0,"stats":{"Line":9871890383196127232}},{"line":362,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":363,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":364,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":365,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":367,"address":[],"length":0,"stats":{"Line":4323455642275676166}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":5044031582654955543}},{"line":375,"address":[],"length":0,"stats":{"Line":16573246628723425280}},{"line":378,"address":[],"length":0,"stats":{"Line":15636497906230362056}},{"line":380,"address":[],"length":0,"stats":{"Line":5908722711110090771}},{"line":382,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":383,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":386,"address":[],"length":0,"stats":{"Line":16357073846609641487}},{"line":388,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":393,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":394,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":396,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":397,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":399,"address":[],"length":0,"stats":{"Line":1297036692682702863}},{"line":400,"address":[],"length":0,"stats":{"Line":1297036692682702863}},{"line":401,"address":[],"length":0,"stats":{"Line":1297036692682702863}},{"line":402,"address":[],"length":0,"stats":{"Line":2377900603251621906}},{"line":404,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":408,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":409,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":410,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":411,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":412,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":415,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":416,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":418,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":420,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":422,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":424,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":425,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":426,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":427,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":428,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":431,"address":[],"length":0,"stats":{"Line":4395513236313604097}},{"line":436,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":437,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":438,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":440,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":442,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":444,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":446,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":449,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":455,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":456,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":458,"address":[],"length":0,"stats":{"Line":17437937757178560533}},{"line":459,"address":[],"length":0,"stats":{"Line":3098476543630901267}},{"line":460,"address":[],"length":0,"stats":{"Line":3098476543630901267}},{"line":462,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":463,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":464,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":465,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":466,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":467,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":470,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":472,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":522,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":524,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":527,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":530,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":533,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":534,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":535,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":536,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":537,"address":[],"length":0,"stats":{"Line":11457157452030541909}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":540,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":541,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":543,"address":[],"length":0,"stats":{"Line":16140901064495857666}},{"line":545,"address":[],"length":0,"stats":{"Line":16068843470457929731}},{"line":549,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":551,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":552,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":15780613094306217981}},{"line":558,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":560,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":562,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":563,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":564,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":565,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":566,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":569,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":570,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":571,"address":[],"length":0,"stats":{"Line":15780613094306217984}}],"covered":141,"coverable":179},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser_runner.rs"],"content":"// pub enum ParserVisuals{\r\n\r\n// }\r\n\r\nuse std::time::SystemTime;\r\n\r\nuse crate::{\r\n    parser::{ParsedData, Parser, ParserFlags, ParserResult, ParserSource},\r\n    writers::{\r\n        javascript_writer, lisp_like_writer,\r\n        syntax_lint::SyntaxLinter,\r\n        syntax_renderers::{line_renderer::LineRenderer, wind_renderer::WindowsRenderer},\r\n    },\r\n};\r\n\r\n#[derive(Clone, Copy)]\r\npub struct RunnerFlags {\r\n    pub assert_steps: bool,\r\n    #[allow(dead_code)]\r\n    pub input: bool,\r\n    pub whole_program: bool,\r\n    pub linted: bool,\r\n    pub line_rendered: bool,\r\n}\r\n\r\npub fn run_state(state: ParserResult, parser: \u0026Parser, parser_flags: RunnerFlags, step_count: u64) {\r\n    let count = if cfg!(feature = \"speed\") { 1000000 } else { 1 };\r\n\r\n    if parser_flags.assert_steps {\r\n        if step_count % count == 0 {\r\n            let (word, index) = parser.get_last_word();\r\n            let (stack, length) = parser.get_parser_stack();\r\n            println!(\r\n                \"step:{}\\nword:[{}:{}]\\nreturn:[{:?}]\\nstack:{}[{}]\",\r\n                step_count,\r\n                std::str::from_utf8(word).unwrap(),\r\n                index,\r\n                state,\r\n                length,\r\n                stack\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\npub fn run_after(data: ParsedData, parser_flags: RunnerFlags) {\r\n    // if parser_flags.input {\r\n    //     let iter = data.source.get_iter();\r\n    //     println!(\r\n    //         \"    text input:\\n\\\"{}\\\"\",\r\n    //         std::str::from_utf8(iter.cloned().collect::\u003cVec\u003c_\u003e\u003e().as_slice()).unwrap()\r\n    //     );\r\n    // }\r\n    if parser_flags.whole_program {\r\n        println!(\r\n            \"   whole program:\\n{}\",\r\n            lisp_like_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n        );\r\n        println!(\r\n            \"   JavaScript output:\\n{}\",\r\n            javascript_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n        );\r\n    }\r\n    if parser_flags.linted {\r\n        let iter = data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cWindowsRenderer\u003e::new();\r\n        lint.write(\u0026data.exprs, \u0026data.stat_starts, iter);\r\n        println!(\r\n            \"   linted:\\n{}\",\r\n            std::str::from_utf8(\u0026lint.into_data()).unwrap()\r\n        );\r\n    }\r\n    if parser_flags.line_rendered {\r\n        let iter = data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cLineRenderer\u003e::new();\r\n        lint.write(\u0026data.exprs, \u0026data.stat_starts, iter);\r\n        println!(\"   line renderered:\\n{:?}\", lint.into_data());\r\n    }\r\n}\r\n\r\npub fn run_parser(parser_flags: ParserFlags, vis_flags: RunnerFlags, source: ParserSource) {\r\n    // println!(\"Input text to be parsed:\");\r\n    let mut parser = Parser::new(source, parser_flags);\r\n    let mut step_count = 0;\r\n    let start = SystemTime::now();\r\n    loop {\r\n        match parser.step() {\r\n            ParserResult::NoInput =\u003e break,\r\n            state =\u003e run_state(state, \u0026parser, vis_flags, step_count),\r\n        }\r\n        step_count += 1;\r\n    }\r\n    let end = SystemTime::now();\r\n    let duration = end.duration_since(start).unwrap();\r\n    println!(\r\n        \"took {} seconds with {} steps\",\r\n        duration.as_secs(),\r\n        step_count\r\n    );\r\n\r\n    let data = parser.into_data();\r\n\r\n    run_after(data, vis_flags);\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser_source.rs"],"content":"use std::{\r\n    fmt::Debug,\r\n    io::{stdin, BufRead, StdinLock},\r\n    iter::{self, Flatten},\r\n};\r\n\r\nuse bstr::{ByteSlice, ByteVec};\r\n\r\npub type ParserSourceIter\u003c'a\u003e = Flatten\u003cstd::vec::IntoIter\u003cBox\u003cdyn Iterator\u003cItem = \u0026'a u8\u003e + 'a\u003e\u003e\u003e;\r\n\r\nmacro_rules! make_iter {\r\n    ($expr:expr) =\u003e {\r\n        Box::new($expr) as Box\u003cdyn iter::Iterator\u003cItem = \u0026u8\u003e\u003e\r\n    };\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Source\u003c'a\u003e {\r\n    Stdin {\r\n        source: Option\u003cStdinLock\u003c'a\u003e\u003e,\r\n        start: usize,\r\n        buf: Vec\u003cu8\u003e,\r\n    },\r\n    File,\r\n    String {\r\n        str: Vec\u003cu8\u003e,\r\n        first: bool,\r\n    },\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct ParserSource\u003c'a\u003e {\r\n    sources: Vec\u003cSource\u003c'a\u003e\u003e,\r\n    index: usize,\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    pub fn from_stdin() -\u003e Self {\r\n        Self {\r\n            sources: Vec::new(),\r\n            index: 0,\r\n        }\r\n        .add_stdin()\r\n    }\r\n    pub fn from_string(str: Vec\u003cu8\u003e) -\u003e Self {\r\n        Self {\r\n            sources: Vec::new(),\r\n            index: 0,\r\n        }\r\n        .add_string(str)\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    pub fn add_stdin(mut self) -\u003e Self {\r\n        self.sources.push(Source::Stdin {\r\n            source: Some(stdin().lock()),\r\n            start: 0,\r\n            buf: Vec::new(),\r\n        });\r\n        self\r\n    }\r\n\r\n    pub fn add_string(mut self, mut str: Vec\u003cu8\u003e) -\u003e Self {\r\n        // if last is not newline - add it\r\n        if does_str_need_newline(\u0026str) {\r\n            str.push(b'\\n');\r\n        }\r\n\r\n        for slice in str.split_str(\"\\n\\n\") {\r\n            let mut str = slice.to_vec();\r\n            str.push_str(b\"\\n\\n\");\r\n            self.sources.push(Source::String { str, first: true });\r\n        }\r\n\r\n        self\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    pub fn get_line\u003c'b\u003e(\u0026'b self) -\u003e \u0026'b [u8] {\r\n        match \u0026self.sources[self.index] {\r\n            Source::Stdin { start, buf, .. } =\u003e \u0026buf[*start..],\r\n            Source::File =\u003e todo!(),\r\n            Source::String { str, first } =\u003e {\r\n                // if getting before new line is set - return nothing\r\n                if *first {\r\n                    \u0026[]\r\n                } else {\r\n                    \u0026str\r\n                }\r\n            }\r\n        }\r\n    }\r\n    pub fn new_line\u003c'b\u003e(\u0026'b mut self) -\u003e Option\u003c\u0026'b [u8]\u003e {\r\n        loop {\r\n            if self.index \u003e= self.sources.len() {\r\n                return None;\r\n            }\r\n            let has_failed = match \u0026mut self.sources[self.index] {\r\n                Source::Stdin { source, start, buf } =\u003e {\r\n                    if let Some(stdin) = source {\r\n                        Self::get_from_stdin(stdin, start, buf)\r\n                    } else {\r\n                        true\r\n                    }\r\n                }\r\n                Source::File =\u003e todo!(),\r\n                Source::String { first, .. } =\u003e {\r\n                    let ret = *first;\r\n                    *first = false;\r\n                    !ret\r\n                }\r\n            };\r\n            if has_failed {\r\n                self.index += 1;\r\n            } else {\r\n                return Some(self.get_line());\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn drop_input(\u0026mut self) {\r\n        for s in \u0026mut self.sources {\r\n            if let Source::Stdin { source, .. } = s {\r\n                *source = None;\r\n            }\r\n        }\r\n    }\r\n    pub fn get_iter\u003c'b\u003e(\u0026'b self) -\u003e ParserSourceIter {\r\n        let mut ret = Vec::new();\r\n        let mut add_newline = false;\r\n        for s in \u0026self.sources {\r\n            if add_newline {\r\n                ret.push(make_iter!(iter::once(\u0026b'\\n')));\r\n            }\r\n            let iter;\r\n            (iter, add_newline) = match s {\r\n                Source::Stdin { buf, .. } =\u003e (make_iter!(buf.iter()), false),\r\n                Source::File =\u003e todo!(),\r\n                Source::String { str, .. } =\u003e (make_iter!(str.iter()), does_str_need_newline(str)),\r\n            };\r\n            ret.push(iter);\r\n        }\r\n        ret.into_iter().flatten()\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    /// get input from stdin stoping on 0 len input\r\n    /// returns has_failed\r\n    fn get_from_stdin(stdin: \u0026mut StdinLock\u003c'a\u003e, start: \u0026mut usize, buf: \u0026mut Vec\u003cu8\u003e) -\u003e bool {\r\n        println!(\"Input text to be parsed:\");\r\n        let mut has_input = false;\r\n        // let mut has_first_empty = false;\r\n        *start = buf.len();\r\n        loop {\r\n            let mut new_input = Vec::new();\r\n            let has_failed = stdin.read_until(b'\\n', \u0026mut new_input).is_err();\r\n\r\n            // remove newlines if it exists\r\n            while !new_input.is_empty() {\r\n                let last = *new_input.last().unwrap();\r\n                if last == b'\\n' || last == b'\\r' {\r\n                    new_input.pop();\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if has_failed || new_input.len() == 0 {\r\n                // if has_first_empty {\r\n                buf.push(b'\\n');\r\n                return !has_input;\r\n            }\r\n            //     } else {\r\n            //         has_first_empty = true;\r\n            //     }\r\n            // } else {\r\n            //     has_first_empty = false;\r\n            // }\r\n\r\n            has_input = true;\r\n            if buf.len() == 0 {\r\n                *buf = new_input;\r\n            } else {\r\n                buf.append(\u0026mut new_input);\r\n            }\r\n            buf.push(b'\\n');\r\n        }\r\n    }\r\n}\r\n\r\nfn does_str_need_newline(str: \u0026Vec\u003cu8\u003e) -\u003e bool {\r\n    !str.last().is_some_and(|f| *f == b'\\n')\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":47,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":50,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":66,"address":[],"length":0,"stats":{"Line":13690942867206307842}},{"line":67,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":70,"address":[],"length":0,"stats":{"Line":11457157452030541827}},{"line":71,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":72,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":73,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":76,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":81,"address":[],"length":0,"stats":{"Line":11673330234144325633}},{"line":82,"address":[],"length":0,"stats":{"Line":11673330234144325633}},{"line":83,"address":[],"length":0,"stats":{"Line":18446744073709551565}},{"line":85,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":87,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":88,"address":[],"length":0,"stats":{"Line":16068843470457929780}},{"line":90,"address":[],"length":0,"stats":{"Line":14051230837395947521}},{"line":95,"address":[],"length":0,"stats":{"Line":13763000461244235826}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":11457157452030541877}},{"line":98,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":100,"address":[],"length":0,"stats":{"Line":13835058055282163763}},{"line":101,"address":[],"length":0,"stats":{"Line":51}},{"line":102,"address":[],"length":0,"stats":{"Line":48}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":110,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":111,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":112,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":115,"address":[],"length":0,"stats":{"Line":16140901064495857667}},{"line":116,"address":[],"length":0,"stats":{"Line":16140901064495857667}},{"line":118,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":123,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":124,"address":[],"length":0,"stats":{"Line":11457157452030541828}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":195,"address":[],"length":0,"stats":{"Line":11313042263954685954}}],"covered":47,"coverable":81},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser_structs.rs"],"content":"use bstr::ByteSlice;\r\nuse quickscope::ScopeMap;\r\nuse std::{\r\n    collections::HashSet,\r\n    fmt::{self, Debug},\r\n    usize,\r\n};\r\n\r\nuse super::{alias_data::AliasData, Expr};\r\n\r\npub fn try_get_best_val\u003c'a\u003e(\r\n    name: \u0026[u8],\r\n    iter: \u0026mut dyn Iterator\u003cItem = \u0026'a [u8]\u003e,\r\n    pred: \u0026dyn Fn(\u0026[u8]) -\u003e bool,\r\n) -\u003e Option\u003c(u8, \u0026'a [u8], usize)\u003e {\r\n    let mut max_var_length = 0u8;\r\n    let mut var_data: Option\u003c(u8, \u0026[u8], usize)\u003e = None;\r\n    for (index, str) in iter.enumerate() {\r\n        let is_longer = str.len() as u8 \u003e= max_var_length;\r\n        // if var could be in word\r\n        if is_longer \u0026\u0026 name.len() \u003e= str.len() \u0026\u0026 (pred)(str) {\r\n            // if found\r\n            if let Some(str_index) = name.find(str) {\r\n                let is_better = var_data.as_ref().map_or(true, |\u0026(old_index, _, _)| {\r\n                    is_longer || (str_index as u8) \u003c old_index\r\n                });\r\n\r\n                if is_better {\r\n                    max_var_length = str.len() as u8;\r\n                    var_data = Some((str_index as u8, str, index));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var_data\r\n}\r\n/// remove skip indexes outside of var str and fix indexes for ones inside, returns var start in term of word start\r\nfn convert_skip_indexes(skip_indexes: \u0026mut Vec\u003cu8\u003e, var_start: u8, var_len: u8) -\u003e u8 {\r\n    let mut start_index = 0u8;\r\n    while start_index \u003c skip_indexes.len() as u8 {\r\n        if skip_indexes[start_index as usize] \u003c= var_start + start_index {\r\n            start_index += 1;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    let start = var_start + start_index;\r\n    let var_end = start + var_len;\r\n    skip_indexes.drain(..start_index as usize);\r\n\r\n    let end_index = skip_indexes\r\n        .iter()\r\n        .position(|\u0026v| v \u003e var_end)\r\n        .unwrap_or(skip_indexes.len());\r\n    skip_indexes.drain(end_index..);\r\n\r\n    for val in skip_indexes {\r\n        *val -= start;\r\n    }\r\n    start\r\n}\r\n\r\nfn try_get_from_iter\u003c'a\u003e(\r\n    word: \u0026Slice,\r\n    iter: \u0026mut dyn Iterator\u003cItem = \u0026'a [u8]\u003e,\r\n    global_index: usize,\r\n    pred: \u0026dyn Fn(\u0026[u8]) -\u003e bool,\r\n) -\u003e Option\u003cSubStrData\u003e {\r\n    if word.len() \u003e 255 {\r\n        return None;\r\n    }\r\n    // remove ' and make lowercase\r\n    let (name, mut skip_indexes) = get_var_name_and_skips(word.str);\r\n    let var_data = try_get_best_val(\u0026name, iter, pred);\r\n\r\n    if let Some((var_start, name, _)) = var_data {\r\n        let start = convert_skip_indexes(\u0026mut skip_indexes, var_start, name.len() as u8);\r\n\r\n        Some(SubStrData {\r\n            start: global_index + word.pos + start as usize,\r\n            name: name.to_vec(),\r\n            skip_indexes,\r\n        })\r\n    } else {\r\n        None\r\n    }\r\n}\r\nenum Symbol {\r\n    ///symbol is a varible\r\n    Var,\r\n    ///symbol is a function with a number of arguments\r\n    Func(u8),\r\n}\r\n\r\npub struct SymbolSet {\r\n    set: ScopeMap\u003cVec\u003cu8\u003e, Symbol\u003e,\r\n}\r\nimpl SymbolSet {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            set: ScopeMap::new(),\r\n        }\r\n    }\r\n    pub fn insert_var(\u0026mut self, mut name: Vec\u003cu8\u003e) {\r\n        name.make_ascii_lowercase();\r\n        self.set.define(name, Symbol::Var);\r\n    }\r\n    pub fn insert_func(\u0026mut self, mut name: Vec\u003cu8\u003e, args: u8) {\r\n        name.make_ascii_lowercase();\r\n        self.set.define(name, Symbol::Func(args));\r\n    }\r\n    pub fn add_layer(\u0026mut self) {\r\n        self.set.push_layer();\r\n    }\r\n    pub fn remove_layer(\u0026mut self) {\r\n        self.set.pop_layer();\r\n    }\r\n    pub fn contains(\u0026self, name: \u0026[u8]) -\u003e bool {\r\n        let lower = name.to_ascii_lowercase();\r\n        self.set.contains_key(\u0026lower)\r\n    }\r\n    pub fn get_func_arg_count(\u0026self, name: \u0026Vec\u003cu8\u003e) -\u003e Option\u003cu8\u003e {\r\n        let lower = name.to_ascii_lowercase();\r\n        if let Some(Symbol::Func(count)) = self.set.get(\u0026lower) {\r\n            Some(*count)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n    ///returns (index in word, varible name)\r\n    ///\r\n    pub fn try_get_var(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n        try_get_from_iter(\r\n            word,\r\n            \u0026mut self.set.keys().map(|e| e.as_slice()),\r\n            global_index,\r\n            \u0026|name| matches!(self.set.get(name), Some(Symbol::Var)),\r\n        )\r\n    }\r\n\r\n    pub fn try_get_func(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n        try_get_from_iter(\r\n            word,\r\n            \u0026mut self.set.keys().map(|e| e.as_slice()),\r\n            global_index,\r\n            \u0026|name| matches!(self.set.get(name), Some(Symbol::Func(..))),\r\n        )\r\n    }\r\n}\r\nimpl Debug for SymbolSet {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        f.debug_struct(\"SymbolSet\").finish()\r\n    }\r\n}\r\n\r\npub struct IgnoreSet {\r\n    set: HashSet\u003cVec\u003cu8\u003e\u003e,\r\n}\r\n\r\nimpl IgnoreSet {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            set: HashSet::new(),\r\n        }\r\n    }\r\n    pub fn insert(\u0026mut self, name: Vec\u003cu8\u003e) {\r\n        let lower = name.to_ascii_lowercase();\r\n        self.set.insert(lower);\r\n    }\r\n    pub fn contains(\u0026self, name: \u0026Vec\u003cu8\u003e) -\u003e bool {\r\n        let lower = name.to_ascii_lowercase();\r\n        self.set.contains(\u0026lower)\r\n    }\r\n    ///returns (index in word, length)\r\n    pub fn try_get_val(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n        if word.len() \u003e 255 {\r\n            return None;\r\n        }\r\n        // remove ' and make lowercase\r\n        let (name, mut skip_indexes) = get_var_name_and_skips(word.str);\r\n        let var_data =\r\n            try_get_best_val(\u0026name, \u0026mut self.set.iter().map(|e| e.as_slice()), \u0026|_| true);\r\n\r\n        if let Some((var_start, name, _)) = var_data {\r\n            let start = convert_skip_indexes(\u0026mut skip_indexes, var_start, name.len() as u8);\r\n\r\n            Some(SubStrData {\r\n                start: global_index + word.pos + start as usize,\r\n                name: name.to_vec(),\r\n                skip_indexes,\r\n            })\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\nimpl Debug for IgnoreSet {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        f.debug_struct(\"IgnoreSet\").finish()\r\n    }\r\n}\r\n\r\n// pub struct FuncSet {\r\n//     /// set with \u003cname, arg_count\u003e\r\n//     set: ScopeMap\u003cVec\u003cu8\u003e, usize\u003e,\r\n// }\r\n\r\n// impl FuncSet {\r\n//     pub fn new() -\u003e Self {\r\n//         Self {\r\n//             set: ScopeMap::new(),\r\n//         }\r\n//     }\r\n//     pub fn insert(\u0026mut self, name: Vec\u003cu8\u003e, arg_count: usize) {\r\n//         self.set.define(name, arg_count);\r\n//     }\r\n//     pub fn add_layer(\u0026mut self) {\r\n//         self.set.push_layer();\r\n//     }\r\n//     pub fn remove_layer(\u0026mut self) {\r\n//         self.set.pop_layer();\r\n//     }\r\n//     pub fn contains(\u0026self, name: Vec\u003cu8\u003e) -\u003e bool {\r\n//         self.set.contains_key(\u0026name)\r\n//     }\r\n//     pub fn try_get_func(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n//         if word.len() \u003e 255 {\r\n//             return None;\r\n//         }\r\n//         // remove ' and make lowercase\r\n//         let (name, mut skip_indexes) = get_var_name_and_skips(word.str);\r\n//         let var_data = try_get_val(\u0026name, \u0026mut self.set.keys());\r\n\r\n//         if let Some((var_start, name)) = var_data {\r\n//             let start = convert_skip_indexes(\u0026mut skip_indexes, var_start, name.len() as u8);\r\n\r\n//             Some(SubStrData {\r\n//                 start: global_index + word.pos + start as usize,\r\n//                 name: name.to_vec(),\r\n//                 skip_indexes,\r\n//             })\r\n//         } else {\r\n//             None\r\n//         }\r\n//     }\r\n\r\n//     pub fn get_arg_count(\u0026self, name: \u0026[u8]) -\u003e Option\u003c\u0026usize\u003e {\r\n//         self.set.get(name)\r\n//     }\r\n// pub fn inc_arg_count(\u0026mut self, name: \u0026[u8]) {\r\n//     if let Some(val) = self.set.get(name) {\r\n//         //Increment in above scope.\r\n//         self.set.define(name.to_vec(), val + 1);\r\n//     }\r\n// }\r\n// }\r\n\r\n// impl Debug for FuncSet {\r\n//     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n//         f.debug_struct(\"FuncSet\").finish()\r\n//     }\r\n// }\r\n#[derive(PartialEq, Debug)]\r\npub struct SubStrData {\r\n    pub name: Vec\u003cu8\u003e,\r\n    pub start: usize,\r\n    pub skip_indexes: Vec\u003cu8\u003e,\r\n}\r\n\r\nimpl SubStrData {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            start: usize::MAX,\r\n            name: Vec::new(),\r\n            skip_indexes: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\n\r\n/// a state on the stack\r\npub struct State {\r\n    pub expr_index: usize,\r\n    pub first_parse: usize,\r\n    pub last_parse: usize,\r\n    pub state: Box\u003cdyn ParseState\u003e,\r\n}\r\n\r\n/// a macro to change the a ParseState to a generic box\r\nmacro_rules! get_state {\r\n    ($state:expr) =\u003e {\r\n        Box::new($state) as Box\u003cdyn ParseState\u003e\r\n    };\r\n}\r\npub(crate) use get_state;\r\n\r\n// macro_rules! only_debug {\r\n//     ($expr:expr) =\u003e {\r\n//         if cfg!(debug_assertions) {\r\n//             format!(\"{:?}\", $expr)\r\n//         } else {\r\n//             Default::default()\r\n//         }\r\n//     };\r\n// }\r\n// pub(crate) use only_debug;\r\n\r\n/// add or remove commands based on flags\r\n#[derive(Default, Debug)]\r\npub struct ParserFlags {\r\n    pub title: bool,\r\n}\r\n\r\n#[derive(PartialEq, Eq, Debug)]\r\npub enum StateType {\r\n    /// for NoneExpr and NoneStat\r\n    /// is replaceble\r\n    None,\r\n    Expr,\r\n    Stat,\r\n}\r\n\r\n/// A state (which goes onto the parser stack)\r\npub trait ParseState: Debug {\r\n    /// called first time to setup the state and after the state continues\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult;\r\n\r\n    /// called after match or fail\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult;\r\n\r\n    /// gets the name of the state\r\n    fn get_name(\u0026self) -\u003e \u0026'static str;\r\n\r\n    fn get_type(\u0026self) -\u003e StateType;\r\n}\r\n\r\n///a struct for closing character with an index and a length\r\n#[derive(PartialEq, Debug, Clone, Copy)]\r\npub struct End {\r\n    pub index: usize,\r\n    pub count: u8,\r\n}\r\n\r\nimpl End {\r\n    /// make new end from index and close length\r\n    pub fn new(index: usize, count: u8) -\u003e Self {\r\n        Self { index, count }\r\n    }\r\n\r\n    pub fn from_slice(slice: \u0026Slice, global_index: usize) -\u003e Self {\r\n        End::new(slice.pos + global_index, slice.str.len() as u8)\r\n    }\r\n\r\n    pub fn none() -\u003e Self {\r\n        End::new(usize::MAX, 0)\r\n    }\r\n}\r\n\r\n/// the result of a step or stepmatch function\r\n#[derive(Debug)]\r\npub enum MatchResult {\r\n    /// returned to go to the parent state with the index to now parse from and whether the state closed on it\r\n    Matched(usize, bool),\r\n    /// returned to add a child onto the stack with an index and the state to continue with\r\n    ContinueWith(usize, Box\u003cdyn ParseState\u003e),\r\n    /// returned to give the same state with the offset (usually 0)\r\n    Continue(usize),\r\n    /// returned to go to the parent state with a failure\r\n    Failed,\r\n}\r\n\r\n///the result of the last match\r\n///None means that the parser just started\r\n///New means that continuewith was returned with the locs if they exist\r\n///The rest are the same as MatchResult\r\n#[derive(PartialEq, Debug)]\r\npub enum LastMatchResult {\r\n    None,\r\n    New(Option\u003cVec\u003cusize\u003e\u003e),\r\n    Matched(usize),\r\n    Failed,\r\n    Continue,\r\n}\r\n\r\n///The state that is returned each step\r\n///NoInput means that the parser ran out of input text\r\n///Start means that the parser just started (it is never returned)\r\n///MatchedLine means that the parser just matched a statement\r\n///FailedLine means that the parser just reached the end of a buffer without matching\r\n///The rest are the same as MatchResult and returned accordingly   \r\n#[derive(PartialEq, Debug, Clone, Copy)]\r\npub enum ParserResult {\r\n    NoInput,\r\n    Start,\r\n\r\n    MatchedLine,\r\n    FailedLine,\r\n\r\n    Matched,\r\n    ContinueWith,\r\n    Continue,\r\n    Failed,\r\n    /// this fail was cached earlier\r\n    CachedFail,\r\n}\r\n\r\n///is the state able to be closed\r\n///either it can't, it can, or it must.\r\n#[derive(Debug)]\r\npub enum CloseType {\r\n    Unable,\r\n    Able,\r\n    Force,\r\n}\r\n\r\nimpl ParserResult {\r\n    /// is the parser result an end (is it MatchedLine, FailedLine, or NoInput)\r\n    pub fn is_end(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            ParserResult::MatchedLine | ParserResult::FailedLine | ParserResult::NoInput\r\n        )\r\n    }\r\n}\r\n\r\n///the parser enviorment\r\npub struct Environment\u003c'a\u003e {\r\n    ///The set of current varibles\r\n    pub symbols: \u0026'a mut SymbolSet,\r\n    ///The set of current ignored values\r\n    pub nots: \u0026'a mut IgnoreSet,\r\n    ///The list of expressions\r\n    pub expr: \u0026'a mut Expr,\r\n    ///the index of this expr\r\n    pub expr_index: usize,\r\n    ///the exprs before this\r\n    pub parents: \u0026'a [State],\r\n    ///the exprs before this\r\n    pub before: \u0026'a mut [Expr],\r\n    ///the exprs after this\r\n    pub after: \u0026'a mut [Expr],\r\n    ///The last matched expr if exists\r\n    pub last_stat_index: Option\u003cusize\u003e,\r\n    ///The current locs (locations of the alias characters)\r\n    pub locs: Option\u003cVec\u003cusize\u003e\u003e,\r\n    /// the global index (with multiple input buffers)\r\n    pub global_index: usize,\r\n    /// reference to static AliasData\r\n    pub aliases: \u0026'a AliasData,\r\n    pub full_text: \u0026'a [u8],\r\n}\r\n\r\n///a slice of the input text\r\n#[derive(PartialEq)]\r\npub struct Slice\u003c'a\u003e {\r\n    ///the string itself\r\n    pub str: \u0026'a [u8],\r\n    ///the position relative to the buffer\r\n    pub pos: usize,\r\n}\r\n\r\n///Slice Debug impl\r\nimpl\u003c'a\u003e fmt::Debug for Slice\u003c'a\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        f.debug_struct(\"Slice\")\r\n            .field(\"str\", \u0026String::from_utf8_lossy(\u0026self.str))\r\n            .field(\"pos\", \u0026self.pos)\r\n            .finish()\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e Slice\u003c'a\u003e {\r\n    ///the length of the slice\r\n    ///the same as .str.len()\r\n    pub fn len(\u0026self) -\u003e usize {\r\n        self.str.len()\r\n    }\r\n    ///the end of the slice relative to the buffer\r\n    pub fn end(\u0026self) -\u003e usize {\r\n        self.pos + self.str.len()\r\n    }\r\n    ///returns a new slice that is shortened by offset\r\n    pub fn offset(\u0026self, offset: usize) -\u003e Slice {\r\n        Slice {\r\n            str: \u0026self.str[offset..],\r\n            pos: self.pos + offset,\r\n        }\r\n    }\r\n}\r\n\r\n///the chars that are counted as being part of words\r\nconst OTHER_CHARS: \u0026[u8] = b\"-+^/'\";\r\n///can the char be part of a word\r\nfn is_valid_word_char(char: u8) -\u003e bool {\r\n    char.is_ascii_alphanumeric() || OTHER_CHARS.contains(\u0026char)\r\n}\r\n\r\n///chars that close functions\r\nconst END_CHARS: \u0026[u8] = b\".?!,:\";\r\n///can the char close a command\r\nfn is_valid_close_char(char: u8) -\u003e bool {\r\n    END_CHARS.contains(\u0026char)\r\n}\r\n\r\n///the chars that are returned single but are not closes\r\nconst NON_CLOSE_CHARS: \u0026[u8] = b\"\\\"\u0026\";\r\n///shoudl the char be made into a 1 len slice\r\npub fn is_non_close_but_still_single(char: u8) -\u003e bool {\r\n    NON_CLOSE_CHARS.contains(\u0026char)\r\n}\r\n\r\n/// does slice consist of a closing character\r\npub fn is_close(slice: \u0026Slice) -\u003e bool {\r\n    // does str close something\r\n    get_close_data(slice.str).close_length != 0\r\n}\r\n\r\n/// For when a close is forced rather than able.\r\npub fn is_mandatory_close(slice: \u0026Slice) -\u003e bool {\r\n    let cd = get_close_data(slice.str);\r\n    cd.close_length != 0 \u0026\u0026 !cd.only_forced\r\n}\r\n\r\n///get the next valid word and the rest of the string as decided by is_valid_word_char()\r\n///returns (word,rest)\r\npub fn get_next_word\u003c'a\u003e(slice: \u0026Slice\u003c'a\u003e, mut start: usize) -\u003e (Slice\u003c'a\u003e, Slice\u003c'a\u003e) {\r\n    // find start of word\r\n    start = start.min(slice.len());\r\n    while start \u003c slice.len() \u0026\u0026 !is_valid_word_char(slice.str[start]) {\r\n        start += 1;\r\n    }\r\n\r\n    // find end of word\r\n    let mut end = start;\r\n    while end \u003c slice.len() \u0026\u0026 is_valid_word_char(slice.str[end]) {\r\n        end += 1;\r\n    }\r\n\r\n    (\r\n        Slice {\r\n            str: \u0026slice.str[start..end],\r\n            pos: slice.pos + start,\r\n        },\r\n        Slice {\r\n            str: \u0026slice.str[end..],\r\n            pos: slice.pos + end,\r\n        },\r\n    )\r\n}\r\npub struct CloseData {\r\n    pub close_count: u8,\r\n    pub close_length: u8,\r\n    pub only_forced: bool,\r\n}\r\n/// gets the number of times the characters at line[index] should be repeated and the offset after\r\n/// returns (repeat_count,offset)\r\npub fn get_close_data(line: \u0026[u8]) -\u003e CloseData {\r\n    if line.len() \u003e= 3 \u0026\u0026 line[..3] == b\"...\"[..] {\r\n        CloseData {\r\n            close_count: 10,\r\n            close_length: 3,\r\n            only_forced: false,\r\n        }\r\n    } else if line.len() \u003e= 3 \u0026\u0026 line[..3] == b\"---\"[..] {\r\n        CloseData {\r\n            close_count: 3,\r\n            close_length: 3,\r\n            only_forced: false,\r\n        }\r\n    } else if line.len() \u003e= 2 \u0026\u0026 line[..2] == b\"--\"[..] {\r\n        CloseData {\r\n            close_count: 2,\r\n            close_length: 2,\r\n            only_forced: false,\r\n        }\r\n    } else if line.len() \u003e= 1 {\r\n        match line[0] {\r\n            b'.' | b':' =\u003e CloseData {\r\n                close_count: 1,\r\n                close_length: 1,\r\n                only_forced: false,\r\n            },\r\n            b',' | b';' =\u003e CloseData {\r\n                close_count: 1,\r\n                close_length: 1,\r\n                only_forced: true,\r\n            },\r\n            b'?' | b'!' =\u003e CloseData {\r\n                close_count: 2,\r\n                close_length: 1,\r\n                only_forced: false,\r\n            },\r\n            _ =\u003e CloseData {\r\n                close_count: 0,\r\n                close_length: 0,\r\n                only_forced: false,\r\n            },\r\n        }\r\n    } else {\r\n        CloseData {\r\n            close_count: 0,\r\n            close_length: 0,\r\n            only_forced: false,\r\n        }\r\n    }\r\n}\r\n\r\n///gets the next slice. a slice consists of either a word or a closing character\r\npub fn get_next_slice\u003c'a\u003e(slice: \u0026Slice\u003c'a\u003e, mut start: usize) -\u003e (Slice\u003c'a\u003e, Slice\u003c'a\u003e) {\r\n    // find start of word\r\n    start = start.min(slice.len());\r\n    while start \u003c slice.len()\r\n        \u0026\u0026 !is_valid_word_char(slice.str[start])\r\n        \u0026\u0026 !is_valid_close_char(slice.str[start])\r\n        \u0026\u0026 !is_non_close_but_still_single(slice.str[start])\r\n    {\r\n        start += 1;\r\n    }\r\n\r\n    // find end of word\r\n    let mut end = start;\r\n\r\n    let close_data = get_close_data(\u0026slice.str[start..]);\r\n    if close_data.close_length != 0 {\r\n        end += close_data.close_length as usize;\r\n    } else if end \u003c slice.len() \u0026\u0026 is_non_close_but_still_single(slice.str[start]) {\r\n        end += 1;\r\n    } else {\r\n        while end \u003c slice.len() \u0026\u0026 is_valid_word_char(slice.str[end]) {\r\n            end += 1;\r\n        }\r\n    }\r\n\r\n    (\r\n        Slice {\r\n            str: \u0026slice.str[start..end],\r\n            pos: slice.pos + start,\r\n        },\r\n        Slice {\r\n            str: \u0026slice.str[end..],\r\n            pos: slice.pos + end,\r\n        },\r\n    )\r\n}\r\n\r\n/// returns the rest after the end of the word\r\npub fn find_word_end\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, start: usize) -\u003e Slice\u003c'a\u003e {\r\n    // find end of word\r\n\r\n    let mut end = start.min(slice.len());\r\n    while end \u003c slice.len() \u0026\u0026 is_valid_word_char(slice.str[end]) {\r\n        end += 1;\r\n    }\r\n    //let test = end \u003c slice.len();\r\n    //end = end.min(slice.len());\r\n    Slice {\r\n        str: \u0026slice.str[end..],\r\n        pos: slice.pos + end,\r\n    }\r\n}\r\n\r\n/// returns (close, rest) after finding close\r\npub fn find_close_slice\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, mut start: usize) -\u003e Option\u003c(Slice, Slice)\u003e {\r\n    // find end char\r\n    let mut close_len = 0;\r\n    while start \u003c slice.len() {\r\n        close_len = get_close_data(\u0026slice.str[start..]).close_length;\r\n        if close_len == 0 {\r\n            start += 1;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if start \u003c slice.len() {\r\n        // find end of period\r\n        let end = start + close_len as usize;\r\n        Some((\r\n            Slice {\r\n                str: \u0026slice.str[start..end],\r\n                pos: slice.pos + start,\r\n            },\r\n            Slice {\r\n                str: \u0026slice.str[end..],\r\n                pos: slice.pos + end,\r\n            },\r\n        ))\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n/// returns the rest after finding the next closing character\r\npub fn find_close\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, start: usize) -\u003e Option\u003cSlice\u003c'_\u003e\u003e {\r\n    find_close_slice(slice, start).map(|s| s.1)\r\n}\r\n\r\npub fn get_var_name_and_skips(word: \u0026[u8]) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n    let mut name = Vec::new();\r\n    let mut skips = Vec::new();\r\n    for j in 0..word.len() {\r\n        if word[j] == b'\\'' {\r\n            skips.push(j as u8);\r\n        } else {\r\n            name.push(word[j].to_ascii_lowercase());\r\n        }\r\n    }\r\n    (name, skips)\r\n}\r\n\r\npub fn try_get_symbol_word(word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n    if word.len() \u003e= 3\r\n        \u0026\u0026 word.len() \u003c= 255\r\n        \u0026\u0026 !is_close(word)\r\n        \u0026\u0026 !is_non_close_but_still_single(word.str[0])\r\n    {\r\n        let (name, skip_indexes) = get_var_name_and_skips(word.str);\r\n\r\n        // vars cant be empty\r\n        if name.is_empty() {\r\n            None\r\n        } else {\r\n            Some(SubStrData {\r\n                start: global_index + word.pos,\r\n                name,\r\n                skip_indexes,\r\n            })\r\n        }\r\n    } else {\r\n        None\r\n    }\r\n}\r\n///get a slice that starts at the next \\n\r\npub fn find_newline\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, mut start: usize) -\u003e Option\u003cSlice\u003c'_\u003e\u003e {\r\n    while start \u003c slice.len() {\r\n        let char = slice.str[start];\r\n        if char == b'\\n' {\r\n            break;\r\n        } else {\r\n            start += 1;\r\n        }\r\n    }\r\n\r\n    if start \u003c slice.len() {\r\n        let end = start;\r\n        Some(Slice {\r\n            str: \u0026slice.str[start..end],\r\n            pos: slice.pos + start,\r\n        })\r\n    } else {\r\n        None\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":12177733392409821184}},{"line":16,"address":[],"length":0,"stats":{"Line":12177733392409821184}},{"line":17,"address":[],"length":0,"stats":{"Line":12177733392409821184}},{"line":18,"address":[],"length":0,"stats":{"Line":1441151880758558773}},{"line":19,"address":[],"length":0,"stats":{"Line":7710162562058289205}},{"line":21,"address":[],"length":0,"stats":{"Line":1224979098644774969}},{"line":23,"address":[],"length":0,"stats":{"Line":4107282860161892350}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":28,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":29,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":30,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":35,"address":[],"length":0,"stats":{"Line":12177733392409821237}},{"line":38,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":39,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":40,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":41,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":44,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":48,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":49,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":50,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":52,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":54,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":58,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":59,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":64,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":70,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":14987979559889010680}},{"line":75,"address":[],"length":0,"stats":{"Line":14987979559889010680}},{"line":77,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":78,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":80,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":81,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":82,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":83,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":86,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":100,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":102,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":105,"address":[],"length":0,"stats":{"Line":15492382718154506241}},{"line":106,"address":[],"length":0,"stats":{"Line":15492382718154506241}},{"line":107,"address":[],"length":0,"stats":{"Line":15492382718154506241}},{"line":109,"address":[],"length":0,"stats":{"Line":1224979098644774913}},{"line":110,"address":[],"length":0,"stats":{"Line":1224979098644774913}},{"line":111,"address":[],"length":0,"stats":{"Line":1224979098644774913}},{"line":113,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":114,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":116,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":117,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":119,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":120,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":121,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":123,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":124,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":125,"address":[],"length":0,"stats":{"Line":2017612633061982209}},{"line":126,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":135,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":136,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":137,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":138,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":142,"address":[],"length":0,"stats":{"Line":7421932185906577410}},{"line":144,"address":[],"length":0,"stats":{"Line":7421932185906577410}},{"line":145,"address":[],"length":0,"stats":{"Line":144115188075855876}},{"line":146,"address":[],"length":0,"stats":{"Line":7421932185906577410}},{"line":147,"address":[],"length":0,"stats":{"Line":1008806316530991110}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":16068843470457929734}},{"line":164,"address":[],"length":0,"stats":{"Line":16068843470457929734}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":177,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":178,"address":[],"length":0,"stats":{"Line":44}},{"line":181,"address":[],"length":0,"stats":{"Line":15636497906230362068}},{"line":182,"address":[],"length":0,"stats":{"Line":15636497906230362068}},{"line":183,"address":[],"length":0,"stats":{"Line":15636497906230362068}},{"line":185,"address":[],"length":0,"stats":{"Line":44}},{"line":186,"address":[],"length":0,"stats":{"Line":44}},{"line":188,"address":[],"length":0,"stats":{"Line":44}},{"line":189,"address":[],"length":0,"stats":{"Line":44}},{"line":190,"address":[],"length":0,"stats":{"Line":44}},{"line":191,"address":[],"length":0,"stats":{"Line":44}},{"line":194,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":276,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":277,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":355,"address":[],"length":0,"stats":{"Line":6413125869375586305}},{"line":359,"address":[],"length":0,"stats":{"Line":3026418949592973316}},{"line":360,"address":[],"length":0,"stats":{"Line":3026418949592973316}},{"line":363,"address":[],"length":0,"stats":{"Line":3386706919782612994}},{"line":364,"address":[],"length":0,"stats":{"Line":3386706919782612994}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":2}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":485,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":488,"address":[],"length":0,"stats":{"Line":474}},{"line":489,"address":[],"length":0,"stats":{"Line":474}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":15924728282382073856}},{"line":504,"address":[],"length":0,"stats":{"Line":16140901064495857406}},{"line":510,"address":[],"length":0,"stats":{"Line":17077649786988921032}},{"line":511,"address":[],"length":0,"stats":{"Line":17077649786988921032}},{"line":517,"address":[],"length":0,"stats":{"Line":2089670227099910168}},{"line":518,"address":[],"length":0,"stats":{"Line":2089670227099910168}},{"line":522,"address":[],"length":0,"stats":{"Line":16573246628723425334}},{"line":524,"address":[],"length":0,"stats":{"Line":16573246628723425334}},{"line":528,"address":[],"length":0,"stats":{"Line":13402712491054596097}},{"line":529,"address":[],"length":0,"stats":{"Line":13402712491054596097}},{"line":530,"address":[],"length":0,"stats":{"Line":936748722493063169}},{"line":535,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":537,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":538,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":539,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":543,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":544,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":545,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":549,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":550,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":551,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":553,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":554,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":555,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":566,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":567,"address":[],"length":0,"stats":{"Line":2522015791327477812}},{"line":573,"address":[],"length":0,"stats":{"Line":11313042263954685917}},{"line":579,"address":[],"length":0,"stats":{"Line":13690942867206307839}},{"line":585,"address":[],"length":0,"stats":{"Line":3674937295934324694}},{"line":586,"address":[],"length":0,"stats":{"Line":9799832789158199246}},{"line":618,"address":[],"length":0,"stats":{"Line":17582052945254416425}},{"line":620,"address":[],"length":0,"stats":{"Line":17582052945254416425}},{"line":621,"address":[],"length":0,"stats":{"Line":15564440312192434261}},{"line":622,"address":[],"length":0,"stats":{"Line":3386706919782613058}},{"line":623,"address":[],"length":0,"stats":{"Line":17077649786988920891}},{"line":624,"address":[],"length":0,"stats":{"Line":17654110539292344347}},{"line":626,"address":[],"length":0,"stats":{"Line":16429131440647569452}},{"line":630,"address":[],"length":0,"stats":{"Line":17582052945254416446}},{"line":632,"address":[],"length":0,"stats":{"Line":17582052945254416446}},{"line":633,"address":[],"length":0,"stats":{"Line":17942340915444056126}},{"line":634,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":635,"address":[],"length":0,"stats":{"Line":5404319552844595274}},{"line":636,"address":[],"length":0,"stats":{"Line":1224979098644774917}},{"line":638,"address":[],"length":0,"stats":{"Line":16861477004875137202}},{"line":639,"address":[],"length":0,"stats":{"Line":5260204364768739360}},{"line":644,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":645,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":646,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":648,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":649,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":650,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":656,"address":[],"length":0,"stats":{"Line":864691128455135401}},{"line":659,"address":[],"length":0,"stats":{"Line":864691128455135401}},{"line":660,"address":[],"length":0,"stats":{"Line":2233785415175766354}},{"line":661,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":666,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":667,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":672,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":674,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":675,"address":[],"length":0,"stats":{"Line":6269010681299730433}},{"line":676,"address":[],"length":0,"stats":{"Line":5260204364768739329}},{"line":677,"address":[],"length":0,"stats":{"Line":11673330234144325634}},{"line":678,"address":[],"length":0,"stats":{"Line":6413125869375586305}},{"line":680,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":683,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":685,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":686,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":687,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":688,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":689,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":691,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":692,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":693,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":697,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":10016005571271983105}},{"line":707,"address":[],"length":0,"stats":{"Line":10016005571271983105}},{"line":708,"address":[],"length":0,"stats":{"Line":10016005571271983105}},{"line":709,"address":[],"length":0,"stats":{"Line":3746994889972252728}},{"line":710,"address":[],"length":0,"stats":{"Line":17726168133330272529}},{"line":711,"address":[],"length":0,"stats":{"Line":5548434740920451290}},{"line":713,"address":[],"length":0,"stats":{"Line":6629298651489369949}},{"line":716,"address":[],"length":0,"stats":{"Line":10016005571271983159}},{"line":719,"address":[],"length":0,"stats":{"Line":16501189034685497344}},{"line":720,"address":[],"length":0,"stats":{"Line":16501189034685497344}},{"line":721,"address":[],"length":0,"stats":{"Line":16285016252571713537}},{"line":722,"address":[],"length":0,"stats":{"Line":16285016252571713537}},{"line":723,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":725,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":728,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":732,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":733,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":734,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":738,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":742,"address":[],"length":0,"stats":{"Line":1}},{"line":743,"address":[],"length":0,"stats":{"Line":1}},{"line":744,"address":[],"length":0,"stats":{"Line":1}},{"line":745,"address":[],"length":0,"stats":{"Line":1}},{"line":746,"address":[],"length":0,"stats":{"Line":1}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":1}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":1}}],"covered":202,"coverable":224},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","playground.rs"],"content":"use crate::{\r\n    commands::{Expr, ExprArena},\r\n    parser::{Parser, ParserSource},\r\n    writers::{syntax_lint::SyntaxLinter, syntax_renderers::wind_renderer::WindowsRenderer},\r\n};\r\n\r\n// pub fn print_test() {\r\n//     let source = ParserSource::from_string(\"was test num . seven ..\".into());\r\n//     let exp1 = ExprArena {\r\n//         vec: vec![\r\n//             Expr::Assign {\r\n//                 locs: vec![0, 1, 2],\r\n//                 name_start: 4,\r\n//                 name: \"test\".into(),\r\n//                 value_index: 1,\r\n//                 end: 22,\r\n//             },\r\n//             Expr::WordNum {\r\n//                 locs: vec![9, 10, 11],\r\n//                 str_start: 13,\r\n//                 str: \".\".into(),\r\n//                 end: 21,\r\n//             },\r\n//         ],\r\n//     };\r\n//     let exp2 = ExprArena {\r\n//         vec: vec![\r\n//             Expr::Assign {\r\n//                 locs: vec![0, 1, 2],\r\n//                 name_start: 4,\r\n//                 name: \"test\".into(),\r\n//                 value_index: 1,\r\n//                 end: 22,\r\n//             },\r\n//             Expr::WordNum {\r\n//                 locs: vec![9, 10, 11],\r\n//                 str_start: 15,\r\n//                 str: \"seven\".into(),\r\n//                 end: 21,\r\n//             },\r\n//         ],\r\n//     };\r\n//     let exp3 = ExprArena {\r\n//         vec: vec![\r\n//             Expr::Assign {\r\n//                 locs: vec![0, 1, 2],\r\n//                 name_start: 4,\r\n//                 name: \"test\".into(),\r\n//                 value_index: 1,\r\n//                 end: 21,\r\n//             },\r\n//             Expr::MultiLitNum {\r\n//                 locs: vec![],\r\n//                 str_start: 15,\r\n//                 str_length: 5,\r\n//                 value: 7,\r\n//                 end: usize::MAX,\r\n//             },\r\n//         ],\r\n//     };\r\n//     let exps = vec![exp1, exp2, exp3];\r\n//     for exp in exps {\r\n//         let mut lint = SyntaxLinter::\u003cWindowsRenderer\u003e::new();\r\n//         lint.write(\u0026exp, \u0026[0], source.get_iter());\r\n//         println!(\"{}\", std::str::from_utf8(\u0026lint.into_string()).unwrap());\r\n//     }\r\n// }\r\n\r\npub fn size_test() {}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","mod.rs"],"content":"mod test_word_funcs;\r\n\r\nmod parsing_tests_simple;\r\nmod test_assign_vars;\r\nmod test_closing;\r\nmod test_if_while;\r\nmod test_lit_int;\r\nmod test_numbers;\r\nmod test_operators;\r\nmod test_print;\r\nmod test_colors;\r\n\r\nmod testing;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","parsing_tests_simple.rs"],"content":"#[cfg(test)]\r\nmod tests_simple {\r\n    use ntest::timeout;\r\n\r\n    // use crate::parser::*;\r\n    use crate::testing::*;\r\n\r\n\r\n   \r\n\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_for_each() {\r\n        let data = run_parser!(b\"fre value lis 1 2 3. pri value..\");\r\n         check_lisp!(data,\r\n            \"(foreach@0,1,2$31 value (list@10,11,12$19 (litnum 1@14$$1) (litnum 2@16$$1) (litnum 3@18$$1)) then:\\\r\n            \\n  (print@21,22,23$30 (var \\\"value\\\"@25))\\n)\"\r\n        );\r\n    }\r\n\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_ret_out_of_function() {\r\n        let data = run_parser!(b\"fun func. ret one! ret. pri hello. ret. func.\");\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$17 \\\"func\\\"@4 (args) (return@10,11,12$17 (litnum 1@14$$3)))\\n(print@24,25,26$33 \\\"hello\\\"@28)\\n(\\\"func\\\"@40 )\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_0_arg_function() {\r\n        let data = run_parser!(b\"fun F'unc'. pri hi... fun'c.\");\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$18$$3 \\\"func\\\"@4|1,5 (args) (print@12,13,14$18$$3 \\\"hi\\\"@16))\\n(\\\"func\\\"@22|3 )\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_multi_arg_function() {\r\n        let data = run_parser!(b\"fun 'cause can't 'cause 'w'ow. p'ri hi! 'cause one two three. \\\r\n        c'a'us'e one two. cause one. cause.\"\r\n            );\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$38 \\\"cause\\\"@4|0 (args \\\"cant\\\"@11|3 \\\"wow\\\"@24|0,2) \\\r\n            (print@31,33,34$38 \\\"hi\\\"@36))\\n(\\\"cause\\\"@41 (litnum 1@47$$3) (litnum 2@51$$3))\\n\\\r\n            (\\\"cause\\\"@62|1,3 (litnum 1@71$$3) (litnum 2@75$$3))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_infinite_loop_function() {\r\n        let data = run_parser!(\r\n            b\"fun in'finite. infi'n'ite... 'infinite'? pri \\\"this will never print\\\".\");\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$25$$3 \\\"infinite\\\"@4|2 (args) (\\\"infinite\\\"@15|4,6 ))\\n\\\r\n            (\\\"infinite\\\"@30|8 )\\n(print@41,42,43$68 \\\"this will never print\\\"@45)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_function_fail() {\r\n        let data = run_parser!(b\"fun func. pri hi.\");\r\n         check_lisp!(data,\r\n            \"(function@4,5,6$16 \\\"pri\\\"@10 (args) )\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_line_4() {\r\n        let data = run_parser!( b\"lin one two three four!\");\r\n         check_lisp!(data,\r\n            \"(line@0,1,2$22 (litnum 1@4$$3) (litnum 2@8$$3) (litnum 3@12$$5) (litnum 4@18$$4))\"\r\n        );\r\n    }\r\n    \r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_double_newline() {\r\n        let data = run_parser!( b\"was twelve\\ntwo.\\nwas twelve\\n\\ntwo.\");\r\n         check_lisp!(data,\r\n            \"(assign@0,1,2$14 \\\"twelve\\\"@4 (litnum 2@11$$3))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_assign_vars.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_was_one_letter_var() {\r\n        let data = run_parser!(b\"was a mario two.\");\r\n        check_lisp!(data, \"(assign@0,1,2$15 \\\"mario\\\"@6 (litnum 2@12$$3))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_var_apostrophes() {\r\n        let data = run_parser!(b\"wasn't 'cause one. was only b'e'ca'use'.\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@0,1,2$17 \\\"cause\\\"@7|0 (litnum 1@14$$3))\\n\\\r\n            (assign@19,20,21$39 \\\"only\\\"@23 (var \\\"cause\\\"@32|2))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_varible_substrings() {\r\n        let data = run_parser!(\r\n            b\"was cat one. was car cat. was car car. was cart cater. was cater handcarts.\"\r\n        );\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@0,1,2$11 \\\"cat\\\"@4 (litnum 1@8$$3))\\n\\\r\n            (assign@13,14,15$24 \\\"car\\\"@17 (var \\\"cat\\\"@21))\\n\\\r\n            (assign@26,27,28$37 mut \\\"car\\\"@30 (var \\\"car\\\"@34))\\n\\\r\n            (assign@39,40,41$53 \\\"cart\\\"@43 (var \\\"cat\\\"@48))\\n\\\r\n            (assign@55,56,57$74 \\\"cater\\\"@59 (var \\\"cart\\\"@69))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    // #[timeout(1000)]\r\n    fn test_assign_no_end() {\r\n        let data = run_parser!(b\"was cat one. was car two\");\r\n        check_lisp!(data, \"(assign@0,1,2$11 \\\"cat\\\"@4 (litnum 1@8$$3))\");\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_closing.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_ellipsis_6_close() {\r\n        let data = run_parser!(b\"It was sub sub sub sub sub sub one...\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@3,4,5$34$$3 \\\"sub\\\"@7 (-@11,12,13$34$$3 (-@15,16,17$34$$3 \\\r\n            (-@19,20,21$34$$3 (-@23,24,25$34$$3 (-@27,28,29$34$$3 (litnum 1@31$$3)))))))\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_2_peirod() {\r\n        let data = run_parser!(b\"It was sub sub one..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@3,4,5$19 \\\"sub\\\"@7 (-@11,12,13$18 (litnum 1@15$$3)))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_ellipsis_overload_12() {\r\n        let data = run_parser!(b\"It was sub sub sub sub sub sub sub sub sub sub sub sub one......\");\r\n        check_lisp!(data,\r\n            \"(assign@3,4,5$61$$3 \\\"sub\\\"@7 (-@11,12,13$61$$3 (-@15,16,17$58$$3 (-@19,20,21$58$$3 (-@23,24,25$58$$3 \\\r\n            (-@27,28,29$58$$3 (-@31,32,33$58$$3 (-@35,36,37$58$$3 (-@39,40,41$58$$3 (-@43,44,45$58$$3 \\\r\n            (-@47,48,49$58$$3 (-@51,52,53$58$$3 (litnum 1@55$$3)))))))))))))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_colors.rs"],"content":"#[cfg(test)]\r\nmod test_colors {\r\n    use std::collections::HashSet;\r\n\r\n    use crate::{parser::foreach, testing::*};\r\n    use bstr::ByteSlice;\r\n    use itertools::Itertools;\r\n    use ntest::timeout;\r\n\r\n    const COLOR_STR: \u0026[u8] = include_bytes!(\"colors.txt\");\r\n\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_correct_colors_separate() {\r\n        for line in COLOR_STR.lines() {\r\n            let mut str = b\"was mario \".to_vec();\r\n            str.extend_from_slice(line);\r\n            str.push(b'.');\r\n            let no_spaces = line.replace(b\" \", b\"\");\r\n\r\n            let length = line.len();\r\n            let data = run_parser!(\u0026str);\r\n            check_lisp!(\r\n                data,\r\n                format!(\r\n                    \"(assign@0,1,2${} \\\"mario\\\"@4 (litcol {}@10$${}))\",\r\n                    length + 10,\r\n                    std::str::from_utf8(\u0026no_spaces).unwrap(),\r\n                    length\r\n                ),\r\n                format!(\"testing: {}\", std::str::from_utf8(line).unwrap())\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_correct_colors_together() {\r\n        for line in COLOR_STR.lines() {\r\n            let spaces = line.find_iter(b\" \").powerset();\r\n            for curr_spaces in spaces {\r\n                let mut str = b\"was mario \".to_vec();\r\n                let mut curr_color = line.to_vec();\r\n                for space in curr_spaces.into_iter().rev() {\r\n                    curr_color.remove(space);\r\n                }\r\n                str.extend_from_slice(\u0026curr_color);\r\n                str.push(b'.');\r\n                let no_spaces = line.replace(b\" \", b\"\");\r\n\r\n                let length = curr_color.len();\r\n                let data = run_parser!(\u0026str);\r\n                check_lisp!(\r\n                    data,\r\n                    format!(\r\n                        \"(assign@0,1,2${} \\\"mario\\\"@4 (litcol {}@10$${}))\",\r\n                        length + 10,\r\n                        std::str::from_utf8(\u0026no_spaces).unwrap(),\r\n                        length\r\n                    ),\r\n                    format!(\"testing: {}\", std::str::from_utf8(\u0026curr_color).unwrap())\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//     fn test_incorrect_colors(num: u8) {\r\n//         let mut correct = HashSet::new();\r\n//         let mut words = HashSet::new();\r\n//         for line in COLOR_STR.lines() {\r\n//             correct.insert(line.replace(b\" \", b\"\"));\r\n//             for word in line.split_str(b\" \") {\r\n//                 words.insert(word);\r\n//             }\r\n//         }\r\n//         println!(\r\n//             \"words: {:?}\",\r\n//             correct\r\n//                 .iter()\r\n//                 .map(|str| std::str::from_utf8(str).unwrap())\r\n//                 .collect::\u003cVec\u003c_\u003e\u003e()\r\n//         );\r\n//         let perms = words.iter().permutations(num.into());\r\n//         let perms_vec = perms.clone().count();\r\n//         println!(\"length: {}\", perms_vec);\r\n//         for (index, color) in perms.enumerate() {\r\n//             let no_spaces = color\r\n//                 .iter()\r\n//                 .flat_map(|str| str.into_iter().cloned())\r\n//                 .collect::\u003cVec\u003c_\u003e\u003e();\r\n//             if !correct.contains(\u0026no_spaces) {\r\n//                 println!(\"{}:{}\", index, std::str::from_utf8(\u0026no_spaces).unwrap())\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     #[test]\r\n//     #[timeout(1000)]\r\n//     fn test_incorrect_colors_1() {\r\n//         test_incorrect_colors(1);\r\n//     }\r\n// }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_if_while.rs"],"content":"#[cfg(test)]\r\nmod tests_lit_int {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_else_pri() {\r\n        let data = run_parser!(b\"whe one pri yes! else pri no:(:(\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$15 (litnum 1@4$$3) then:\\n  (print@8,9,10$15 \\\"yes\\\"@12)\\n)\\n(else@17,18,19$30\\\r\n            \\n  (print@22,23,24$28 \\\"no\\\"@26)\\n)\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_space_else_pri() {\r\n        let data = run_parser!(b\"whe one pri yes. Or. pri maybe. Else pri no:( sadge :(\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$19 (litnum 1@4$$3) then:\\n  (print@8,9,10$15 \\\"yes\\\"@12)\\n)\\n(print@21,22,23$30 \\\"maybe\\\"@25)\\n(print@37,38,39$43 \\\"no\\\"@41)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_space_else_rect() {\r\n        let data =\r\n            run_parser!(b\"whe one pri yes! Recording one two. Else pri no:( double sadge :(\");\r\n        check_lisp!(\r\n            data,\r\n            \"(if@0,1,2$15 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$15 \\\"yes\\\"@12)\\n)\\n\\\r\n            (rect@17,18,19$34 (litnum 1@27$$3) (litnum 2@31$$3))\\n\\\r\n            (print@41,42,43$47 \\\"no\\\"@45)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_else_past() {\r\n        let data = run_parser!(b\"whels one whi one pri hi..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(while@10,11,12$25 (litnum 1@14$$3) then:\\n  (print@18,19,20$24 \\\"hi\\\"@22)\\n)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_double_else() {\r\n        let data = run_parser!(b\"whe one pri good.. els els pri bad...\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$17 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$16 \\\"good\\\"@12)\\n)\\n\\\r\n            (else@19,20,21$34$$3\\n  (print@27,28,29$34$$3 \\\"bad\\\"@31)\\n)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_double_else_last() {\r\n        let data = run_parser!(b\"whe one pri good.. els pri bad. els...\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$17 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$16 \\\"good\\\"@12)\\n)\\n\\\r\n            (else@19,20,21$35$$3\\n  (print@23,24,25$30 \\\"bad\\\"@27)\\n)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_else_simple() {\r\n        let data = run_parser!(b\"whe one pri one. pri two.. els pri three. pri four..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(if@0,1,2$25 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$15 (litnum 1@12$$3))\\n  \\\r\n            (print@17,18,19$24 (litnum 2@21$$3))\\n)\\n\\\r\n            (else@27,28,29$51\\n  \\\r\n            (print@31,32,33$40 (litnum 3@35$$5))\\n  \\\r\n            (print@42,43,44$50 (litnum 4@46$$4))\\n)\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_inside_fail() {\r\n        let data = run_parser!(b\"whe one pri one. els. whe one els. pri two..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(if@0,1,2$20 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$15 (litnum 1@12$$3))\\n)\\n\\\r\n            (if@22,23,24$43 (litnum 1@26$$3) then:\\n  \\\r\n            (print@35,36,37$42 (litnum 2@39$$3))\\n)\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_lit_int.rs"],"content":"#[cfg(test)]\r\nmod tests_lit_int {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_wizards_with_double_close() {\r\n        let data = run_parser!(b\"The wizards were literally nine at most!\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@4,7,10$39 \\\"were\\\"@12 (litnum@17,18,19$39 924))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_wizards_with_double_close_ellipsis() {\r\n        let data = run_parser!(b\"The wizards were literally nine at most...\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@4,7,10$39$$3 \\\"were\\\"@12 (litnum@17,18,19$39$$3 924))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_lit_zero() {\r\n        let data = run_parser!(b\"The wizards were literally...\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@4,7,10$26$$3 \\\"were\\\"@12 (litnum@17,18,19$26$$3 0))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_lit_close_early() {\r\n        let data = run_parser!(b\"It was nice int. nice two..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@3,4,5$26 \\\"nice\\\"@7 (wordnum@12,13,14$25 4@17))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_multilitnum_overflow_fail() {\r\n        let data = run_parser!(\r\n            b\"was having little or no money in my purse, and nothing particular to interest me on shore, \\\r\n            I thought I would sail about a little and see the watery part of the world!\");\r\n        check_lisp!(data,\r\n            \"(assign@0,1,2$165 \\\"having\\\"@4 \\\r\n            (multilitnum@11,12,13$165 2 2 5 2 2 5 1 3 7 0 2 8 2 2 5 1 1 7 1 5 4 5 1 6 3 3 3 6 4 2 3 5))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_in_word_hyphen() {\r\n        let data = run_parser!(b\"I was about to learn in-depth mathematics -- It was crazy!\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@2,3,4$42$$2 \\\"about\\\"@6 (wordnum@21,22,27$42$$2 11@30))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_word_no_close() {\r\n        let data = run_parser!(b\"I was two two. was into a two\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@2,3,4$13 \\\"two\\\"@6 (litnum 2@10$$3))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_numbers.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n    \r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn set_var_to_seven() {\r\n        let data = run_parser!(b\"I was going to be seventy.\");\r\n        check_lisp!(data, \"(assign@2,3,4$25 \\\"going\\\"@6 (litnum 70@18$$7))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn set_var_to_seven_with_ellipsis() {\r\n        let data = run_parser!(b\"I was always seventy-seven....\");\r\n        check_lisp!(data, \"(assign@2,3,4$26$$3 \\\"always\\\"@6 (litnum 77@13$$13))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_complicated_litnum() {\r\n        let data = run_parser!(\r\n            b\"I was always one-hundred-and-twenty-three-thousand-three-hundred-and-two....\"\r\n        );\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@2,3,4$72$$3 \\\"always\\\"@6 (litnum 123302@13$$59))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_twenty_one_litnum() {\r\n        let data = run_parser!(b\"I was always twenty-one....\");\r\n        check_lisp!(data, \"(assign@2,3,4$23$$3 \\\"always\\\"@6 (litnum 21@13$$10))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_zero() {\r\n        let data = run_parser!(b\"I was always zero....\");\r\n        check_lisp!(data, \"(assign@2,3,4$17$$3 \\\"always\\\"@6 (litnum 0@13$$4))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_gettysburg() {\r\n        let data = run_parser!(b\"I was always four-score-and-seven....\");\r\n        check_lisp!(data, \"(assign@2,3,4$33$$3 \\\"always\\\"@6 (litnum 87@13$$20))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn do_not_make_gas_station() {\r\n        let data = run_parser!(b\"I was always seven-eleven two.\");\r\n        check_lisp!(data, \"(assign@2,3,4$29 \\\"always\\\"@6 (litnum 2@26$$3))\");\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_operators.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    // use crate::parser::*;\r\n    // use crate::testing::*;\r\n    // use ntest::timeout;\r\n\r\n    }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_print.rs"],"content":"#[cfg(test)]\r\nmod tests_lit_int {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_print_no_vars() {\r\n        let data = run_parser!( b\"pri hi. pri hello world. pri \\\"hello world\\\".\");\r\n         check_lisp!(data,\r\n            \"(print@0,1,2$6 \\\"hi\\\"@4)\\n(print@8,9,10$23 )\\n(print@25,26,27$42 \\\"hello world\\\"@29)\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_print_vars() {\r\n        let data = run_parser!( b\"was test 4. pri one test two test. pri test. pri four.\");\r\n         check_lisp!(data,\r\n            \"(assign@0,1,2$10 \\\"test\\\"@4 (litnum 4@9$$1))\\n(print@12,13,14$33 (litnum 1@16$$3) (var \\\"test\\\"@20) (litnum 2@25$$3) (var \\\"test\\\"@29))\\n(print@35,36,37$43 (var \\\"test\\\"@39))\\n(print@45,46,47$53 (litnum 4@49$$4))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_pri_mult_str() {\r\n        let data = run_parser!( b\"pri \\\"mario\\\" \\\"luigi\\\"!\");\r\n         check_lisp!(data,\r\n            \"(print@0,1,2$19 \\\"mario\\\"@4 \\\"luigi\\\"@12)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_pri_varible_casing() {\r\n        let data = run_parser!(b\"was hi1 one. was HI2 two. pri hi1 Hi1 hi2 Hi2.\");\r\n         check_lisp!(data,\r\n            \"(assign@0,1,2$11 \\\"hi1\\\"@4 (litnum 1@8$$3))\\n(assign@13,14,15$24 \\\"hi2\\\"@17 (litnum 2@21$$3))\\n\\\r\n            (print@26,27,28$45 (var \\\"hi1\\\"@30) (var \\\"hi1\\\"@34) (var \\\"hi2\\\"@38) (var \\\"hi2\\\"@42))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_word_funcs.rs"],"content":"#[cfg(test)]\r\nmod tests {\r\n    use crate::parser::*;\r\n    use crate::testing::test_lib::*;\r\n\r\n    // get_next_word\r\n\r\n    #[test]\r\n    fn test_get_next_word_simple() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"asdf   \", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"   \", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" asdf  \", 1), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"  \", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"  asdf \", 0), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\" \", 6))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_word_no_space_end() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"\", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 3), new_slice(\"\", 7))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"  asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 4), new_slice(\"\", 8))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_word_fails() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"\", 2), 0),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" \", 4), 0),\r\n            (new_slice(\"\", 5), new_slice(\"\", 5))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" \", 8), 0),\r\n            (new_slice(\"\", 9), new_slice(\"\", 9))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_word_out() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"a \", 0), 2),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"a \", 0), 3),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"a \", 0), 4),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n    }\r\n\r\n    // find_word_end\r\n    #[test]\r\n    fn test_find_word_end_after() {\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 0),\r\n            new_slice(\" a b c\", 0)\r\n        );\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 1),\r\n            new_slice(\" b c\", 2)\r\n        );\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 2),\r\n            new_slice(\" b c\", 2)\r\n        );\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 3),\r\n            new_slice(\" c\", 4)\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_word_end_fails() {\r\n        assert_eq!(find_word_end(\u0026new_slice(\"\", 0), 0), new_slice(\"\", 0));\r\n        assert_eq!(find_word_end(\u0026new_slice(\" \", 0), 0), new_slice(\" \", 0));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a\", 0), 0), new_slice(\"\", 1));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a \", 0), 0), new_slice(\" \", 1));\r\n        assert_eq!(find_word_end(\u0026new_slice(\" a\", 0), 0), new_slice(\" a\", 0));\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_word_end_out() {\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a \", 0), 2), new_slice(\"\", 2));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a  \", 0), 3), new_slice(\"\", 3));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a  \", 0), 4), new_slice(\"\", 3));\r\n    }\r\n\r\n    // find_end_close\r\n    #[test]\r\n    fn test_find_close_slice_only() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\".\", 0), 0),\r\n            Some((new_slice(\".\", 0), new_slice(\"\", 1)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"!\", 0), 0),\r\n            Some((new_slice(\"!\", 0), new_slice(\"\", 1)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"...\", 0), 0),\r\n            Some((new_slice(\"...\", 0), new_slice(\"\", 3)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_after() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a . b \", 0), 1),\r\n            Some((new_slice(\".\", 2), new_slice(\" b \", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a ! b \", 0), 0),\r\n            Some((new_slice(\"!\", 2), new_slice(\" b \", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a ... b \", 0), 0),\r\n            Some((new_slice(\"...\", 2), new_slice(\" b \", 5)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_touching_after() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a .b c\", 0), 0),\r\n            Some((new_slice(\".\", 3), new_slice(\"b c\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a !b c\", 0), 0),\r\n            Some((new_slice(\"!\", 3), new_slice(\"b c\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a ...b c\", 0), 0),\r\n            Some((new_slice(\"...\", 3), new_slice(\"b c\", 6)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_touching_before() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a. b c\", 0), 0),\r\n            Some((new_slice(\".\", 2), new_slice(\" b c\", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a! b c\", 0), 0),\r\n            Some((new_slice(\"!\", 2), new_slice(\" b c\", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a... b c\", 0), 0),\r\n            Some((new_slice(\"...\", 2), new_slice(\" b c\", 5)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_touching_both() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b.c d\", 0), 0),\r\n            Some((new_slice(\".\", 3), new_slice(\"c d\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b!c d\", 0), 0),\r\n            Some((new_slice(\"!\", 3), new_slice(\"c d\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b...c d\", 0), 0),\r\n            Some((new_slice(\"...\", 3), new_slice(\"c d\", 6)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_newline() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"\\n . a\", 0), 0),\r\n            Some((new_slice(\".\", 2), new_slice(\" a\", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"\\n a .\", 0), 0),\r\n            Some((new_slice(\".\", 4), new_slice(\"\", 5)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b \\n c . d\", 0), 0),\r\n            Some((new_slice(\".\", 8), new_slice(\" d\", 9)))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_end_close_fails() {\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"\", 0), 0), None);\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a b c d\", 0), 0), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_end_close_out() {\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a \", 0), 2), None);\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a \", 0), 3), None);\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a \", 0), 4), None);\r\n    }\r\n\r\n    // get_next_slice\r\n    #[test]\r\n    fn test_get_next_slice_space_end() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"asdf   \", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"   \", 6))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" asdf  \", 1), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"  \", 6))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  asdf \", 0), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\" \", 6))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_no_space_end() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"\", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 3), new_slice(\"\", 7))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 4), new_slice(\"\", 8))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_fails() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"\", 2), 0),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" \", 4), 0),\r\n            (new_slice(\"\", 5), new_slice(\"\", 5))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" \", 8), 0),\r\n            (new_slice(\"\", 9), new_slice(\"\", 9))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_out() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a \", 0), 2),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a \", 0), 3),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a \", 0), 4),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_close() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\".a\", 2), 0),\r\n            (new_slice(\".\", 2), new_slice(\"a\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" .a \", 1), 0),\r\n            (new_slice(\".\", 2), new_slice(\"a \", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  .a  \", 0), 0),\r\n            (new_slice(\".\", 2), new_slice(\"a  \", 3))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_double_close() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"..a\", 2), 0),\r\n            (new_slice(\".\", 2), new_slice(\".a\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" ..a \", 1), 0),\r\n            (new_slice(\".\", 2), new_slice(\".a \", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  ..a  \", 0), 0),\r\n            (new_slice(\".\", 2), new_slice(\".a  \", 3))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_triple_close() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"...a\", 0), 0),\r\n            (new_slice(\"...\", 0), new_slice(\"a\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" ...a \", 0), 0),\r\n            (new_slice(\"...\", 1), new_slice(\"a \", 4))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  ...a  \", 0), 0),\r\n            (new_slice(\"...\", 2), new_slice(\"a  \", 5))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_close_only() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\".\", 0), 0),\r\n            (new_slice(\".\", 0), new_slice(\"\", 1))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"!\", 0), 0),\r\n            (new_slice(\"!\", 0), new_slice(\"\", 1))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"...\", 0), 0),\r\n            (new_slice(\"...\", 0), new_slice(\"\", 3))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_newline() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a\\na\", 0), 0),\r\n            (new_slice(\"a\", 0), new_slice(\"\\na\", 1))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"\\naa\", 0), 0),\r\n            (new_slice(\"aa\", 1), new_slice(\"\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"\\n a a\", 0), 0),\r\n            (new_slice(\"a\", 2), new_slice(\" a\", 3))\r\n        );\r\n    }\r\n    // #[test]\r\n    // fn test_get_next_slice_quotes() {\r\n    //     assert_eq!(\r\n    //         get_next_slice(\u0026new_slice(\"\\\" b\", 0), 0),\r\n    //         (new_slice(\"\\\"\", 0), new_slice(\" b\", 1))\r\n    //     );\r\n    //     assert_eq!(\r\n    //         get_next_slice(\u0026new_slice(\"\\n \\\"\\' a\", 0), 0),\r\n    //         (new_slice(\"\\\"\", 2), new_slice(\"\\' a\", 3))\r\n    //     );\r\n    //     assert_eq!(\r\n    //         get_next_slice(\u0026new_slice(\"a'b\", 0), 0),\r\n    //         (new_slice(\"a\", 0), new_slice(\"'b\", 1))\r\n    //     );\r\n    // }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","testing.rs"],"content":"#![allow(dead_code)]\r\n#![allow(unused_macros)]\r\n#![allow(unused_imports)]\r\n\r\n#[cfg(test)]\r\npub mod test_lib {\r\n\r\n    use crate::commands::{Expr, ExprArena};\r\n\r\n    use crate::parser::{Parser, *};\r\n    use crate::writers::lisp_like_writer;\r\n    use alias_data::AliasData;\r\n    use std::collections::HashSet;\r\n    use std::hint;\r\n\r\n    pub fn assert_step_inner(\r\n        parser: \u0026mut Parser,\r\n        exp_result: ParserResult,\r\n        exp_state: \u0026str,\r\n        exp_word: \u0026str,\r\n        file: \u0026str,\r\n        line: u32,\r\n    ) {\r\n        let result = parser.step();\r\n        let state = parser.get_last_state_name();\r\n        let word = std::str::from_utf8(parser.get_last_word().0).unwrap();\r\n        let message = \u0026format!(\r\n            \"result was {:?}(\\\"{}\\\",\\\"{}\\\"). expected {:?}(\\\"{}\\\",\\\"{}\\\") at {}:{}\",\r\n            result, state, word, exp_result, exp_state, exp_word, file, line\r\n        );\r\n\r\n        assert_eq!(result, exp_result, \"{}\", message);\r\n        assert_eq!(state, exp_state, \"{}\", message);\r\n        assert_eq!(word, exp_word, \"{}\", message);\r\n    }\r\n\r\n    pub fn new_slice(str: \u0026str, start: usize) -\u003e Slice {\r\n        Slice {\r\n            str: str.as_ref(),\r\n            pos: start,\r\n        }\r\n    }\r\n\r\n    pub fn new_sub_slice(str: \u0026str, start: usize) -\u003e Slice {\r\n        let bytes: \u0026[u8] = str.as_ref();\r\n        Slice {\r\n            str: \u0026bytes[start..],\r\n            pos: start,\r\n        }\r\n    }\r\n\r\n    // pub fn new_env\u003c'a\u003e(\r\n    //     vars: \u0026'a mut VarSet,\r\n    //     expr: \u0026'a mut Expr,\r\n    //     locs: Option\u003cVec\u003cusize\u003e\u003e,\r\n    //     aliases: \u0026'a AliasData,\r\n    //     last_stat:Option\u003c\u0026'a mut Expr\u003e\r\n    // ) -\u003e Environment\u003c'a\u003e {\r\n    //     Environment {\r\n    //         vars,\r\n    //         expr,\r\n    //         last_stat,\r\n    //         locs,\r\n    //         global_index: 0,\r\n    //         aliases,\r\n    //     }\r\n    // }\r\n\r\n    pub fn assert_result(parser: \u0026mut Parser) -\u003e ParserResult {\r\n        loop {\r\n            let result = parser.step();\r\n            if result.is_end() {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    pub fn run_to_completion(parser: \u0026mut Parser) -\u003e ParserResult {\r\n        loop {\r\n            let result = parser.step();\r\n            if matches!(result, ParserResult::NoInput) {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn run_parser(input: Vec\u003cu8\u003e, title: bool) -\u003e ParsedData\u003c'static\u003e {\r\n        let text = hint::black_box(input).to_vec();\r\n        let mut parser = Parser::new(ParserSource::from_string(text), ParserFlags { title });\r\n        run_to_completion(\u0026mut parser);\r\n        parser.into_data()\r\n    }\r\n\r\n    pub fn get_lisp(data: \u0026ParsedData) -\u003e String {\r\n        lisp_like_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n    }\r\n}\r\n\r\n// use crate::testing::test_lib::*;\r\n\r\nmacro_rules! add_vars {\r\n    ($parser:ident, $var:expr) =\u003e {\r\n        $parser.vars.insert($var.as_bytes().to_vec());\r\n    };\r\n    ($parser:ident, $var:expr, $($vars:expr),+) =\u003e {\r\n        $crate::testing::add_vars! ($parser, $var );\r\n        $crate::testing::add_vars! ($parser, $($vars), + );\r\n    };\r\n}\r\npub(crate) use add_vars;\r\n\r\nmacro_rules! assert_step {\r\n    ($parser:ident,$step_result:ident,$state:expr,$word:expr) =\u003e {\r\n        $crate::testing::test_lib::assert_step_inner(\r\n            \u0026mut $parser,\r\n            ParserResult::$step_result,\r\n            $state,\r\n            $word,\r\n            file!(),\r\n            line!(),\r\n        );\r\n    };\r\n}\r\n\r\npub(crate) use assert_step;\r\n\r\nmacro_rules! run_parser {\r\n    ($input:expr) =\u003e {{\r\n        $crate::testing::test_lib::run_parser($input.to_vec(), false)\r\n    }};\r\n    ($input:expr, $title:expr) =\u003e {{\r\n        $crate::testing::test_lib::run_parser($input.to_vec(), $title)\r\n    }};\r\n}\r\n\r\npub(crate) use run_parser;\r\n\r\nmacro_rules! check_lisp {\r\n    ($data:expr,$result:expr) =\u003e {{\r\n        assert_eq!($crate::testing::test_lib::get_lisp(\u0026$data), $result);\r\n    }};\r\n    ($data:expr,$result:expr,$error:expr) =\u003e {{\r\n        assert_eq!(\r\n            $crate::testing::test_lib::get_lisp(\u0026$data),\r\n            $result,\r\n            \"{}\",\r\n            $error\r\n        );\r\n    }};\r\n}\r\n\r\npub(crate) use check_lisp;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","error_messages.rs"],"content":"//#[allow(dead_code)]\r\n\r\n// const MSG_ZERO_TO_TWELVE:[\u0026str;13]=[];\r\n\r\n// const MSG_TEEN :\u0026str = \"\";\r\n\r\n// const TWENTY_TO_NINETY :\u0026str = [8]=[];\r\n\r\n// pub fn get_error_str(number:usize){\r\n\r\n// }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","javascript_writer.rs"],"content":"use crate::{\r\n    commands::*,\r\n    parser::{multi_lit_num::VarOrInt, string_lit::VarOrStr},\r\n};\r\n\r\n#[allow(dead_code)]\r\npub fn write(exprs: \u0026ExprArena, line_starts: \u0026Vec\u003cusize\u003e) -\u003e String {\r\n    let mut str = \"\".to_string();\r\n    let mut indent: usize = 0;\r\n    for statement in line_starts {\r\n        str += \u0026write_expr(exprs, *statement, \u0026mut indent);\r\n        str += \"\\n\";\r\n    }\r\n    str\r\n}\r\n\r\nfn get_indent(indent: \u0026usize) -\u003e String {\r\n    let mut str = \"\".to_string();\r\n    for _ in 0..*indent {\r\n        str += \"\\t\"\r\n    }\r\n    str\r\n}\r\n\r\nfn write_expr(exprs: \u0026ExprArena, index: usize, indent: \u0026mut usize) -\u003e String {\r\n    match \u0026exprs[index] {\r\n        Expr::NoneStat =\u003e \"(todo stat)\".to_string(),\r\n        Expr::NoneExpr =\u003e \"(todo expr)\".to_string(),\r\n        Expr::Title { data } =\u003e {\r\n            let author_str = data\r\n                .authors\r\n                .iter()\r\n                .map(|name| String::from_utf8_lossy(\u0026name.0))\r\n                .collect::\u003cVec\u003c_\u003e\u003e()\r\n                .join(\", \");\r\n            format!(\r\n                \"`{}`;\\n\\\"By {}\\\";\\n\",\r\n                String::from_utf8_lossy(\u0026data.title),\r\n                author_str\r\n            )\r\n        }\r\n        Expr::Assign {\r\n            var,\r\n            value_index,\r\n            first,\r\n            ..\r\n        } =\u003e format!(\r\n            \"{}{}{}_var = {};\",\r\n            get_indent(indent),\r\n            if *first { \"let \" } else { \"\" },\r\n            String::from_utf8_lossy(\u0026var.name),\r\n            write_expr(exprs, *value_index, indent)\r\n        ),\r\n        Expr::Line {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_line({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Bezier {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_bezier({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Arc {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_ellipse({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Rect {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_rect({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Var { var } =\u003e format!(\"{}_var\", String::from_utf8_lossy(\u0026var.name).to_string()),\r\n        Expr::WordNum {\r\n            locs: _,\r\n            str_start: _,\r\n            str_len,\r\n            end: _,\r\n        } =\u003e str_len.to_string(),\r\n        Expr::Operator {\r\n            locs: _,\r\n            func_type,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            let ret = match func_type {\r\n                OperatorType::Log =\u003e {\r\n                    format!(\"log_base({})\", write_exprs(exprs, indexes, \", \", indent))\r\n                }\r\n                OperatorType::Exp =\u003e {\r\n                    if indexes.len() == 1 {\r\n                        format!(\"(Math.E ** {})\", write_expr(exprs, indexes[0], indent))\r\n                    } else {\r\n                        format!(\"({})\", write_exprs(exprs, indexes, \" ** \", indent))\r\n                    }\r\n                }\r\n                OperatorType::Equals =\u003e {\r\n                    let first_exp = write_expr(exprs, indexes[0], indent);\r\n                    let mut r;\r\n                    if indexes.len() \u003e 2 {\r\n                        r = format!(\r\n                            \"({} == {}\",\r\n                            first_exp,\r\n                            write_expr(exprs, indexes[1], indent)\r\n                        );\r\n                        for index in \u0026indexes[2..] {\r\n                            if *index != usize::MAX {\r\n                                r += \" \u0026\u0026 \";\r\n                                r += format!(\r\n                                    \"{} == {}\",\r\n                                    first_exp,\r\n                                    write_expr(exprs, *index, indent)\r\n                                )\r\n                                .as_str();\r\n                            }\r\n                        }\r\n                        r += \")\";\r\n                    } else {\r\n                        r = format!(\"{} == {}\", first_exp, write_expr(exprs, indexes[1], indent));\r\n                    }\r\n                    r\r\n                }\r\n                _ =\u003e \"\".to_string(),\r\n            };\r\n            if ret != \"\" {\r\n                return ret;\r\n            }\r\n            let name = match func_type {\r\n                OperatorType::Add =\u003e \"+\",\r\n                OperatorType::Sub =\u003e \"-\",\r\n                OperatorType::Mult =\u003e \"*\",\r\n                OperatorType::Div =\u003e \"/\",\r\n                OperatorType::Mod =\u003e \"%\",\r\n                OperatorType::Exp =\u003e \"**\",\r\n                OperatorType::Log =\u003e \"log\",\r\n                OperatorType::LessThan =\u003e \"\u003c\",\r\n                OperatorType::GreaterThan =\u003e \"\u003e\",\r\n                OperatorType::And =\u003e \"\u0026\u0026\",\r\n                OperatorType::Or =\u003e \"||\",\r\n                OperatorType::Equals =\u003e \"==\",\r\n                OperatorType::Not =\u003e \"!\",\r\n            };\r\n            match indexes.len() {\r\n                1 =\u003e format!(\"{}{}\", name, write_expr(exprs, indexes[0], indent)),\r\n                2 =\u003e format!(\r\n                    \"({} {} {})\",\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    name,\r\n                    write_expr(exprs, indexes[1], indent)\r\n                ),\r\n                _ =\u003e {\r\n                    let mut ret = String::new();\r\n                    ret += \"(\";\r\n                    ret += write_expr(exprs, indexes[0], indent).as_str();\r\n                    for i in \u0026indexes[1..] {\r\n                        ret += \" \";\r\n                        ret += name;\r\n                        ret += \" \";\r\n                        ret += write_expr(exprs, *i, indent).as_str();\r\n                    }\r\n                    ret += \")\";\r\n                    ret\r\n                }\r\n            }\r\n            // format!(\"{} {}\", name, write_exprs(exprs, indexes))\r\n        }\r\n        Expr::LitNum {\r\n            str_start: _,\r\n            str_length: _,\r\n            value,\r\n        } =\u003e value.to_string(),\r\n        Expr::MultiLitNum {\r\n            values,\r\n            single_value,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(intval) = single_value {\r\n                format!(\"{}\", intval)\r\n            } else {\r\n                let mut output_vals = \"\".to_string();\r\n                let mut is_first = true;\r\n                for val in values {\r\n                    if !is_first {\r\n                        output_vals += \", \";\r\n                    } else {\r\n                        is_first = false;\r\n                    }\r\n                    if let VarOrInt::Var(var) = val {\r\n                        output_vals += \u0026format!(\"{}_var\", String::from_utf8_lossy(\u0026var.name));\r\n                    } else if let VarOrInt::Int(intval) = val {\r\n                        output_vals += \u0026format!(\"{}\", intval);\r\n                    }\r\n                }\r\n                format!(\"get_concat_value({})\", output_vals)\r\n            }\r\n        }\r\n        Expr::Print {\r\n            indexes,\r\n            single_word,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(word) = single_word {\r\n                format!(\r\n                    \"{}print_console(\\\"{}\\\");\",\r\n                    get_indent(indent),\r\n                    String::from_utf8_lossy(word)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}print_console({});\",\r\n                    get_indent(indent),\r\n                    write_exprs(exprs, indexes, \", \", indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::If { indexes, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}if ({}) {{\\n{}\\n{}}}\",\r\n                ind,\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_exprs(exprs, \u0026indexes[1..], \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::While { indexes, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}while ({}) {{\\n{}\\n{}}}\",\r\n                ind,\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_exprs(exprs, \u0026indexes[1..], \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::Else { indexes, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}else {{\\n{}\\n{}}}\",\r\n                ind,\r\n                write_exprs(exprs, indexes, \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::LitCol { value, .. } =\u003e {\r\n            format!(\"\\\"{}\\\"\", String::from_utf8_lossy(\u0026value))\r\n        }\r\n        Expr::Stroke { indexes, .. } =\u003e {\r\n            if indexes[1] == usize::MAX {\r\n                format!(\r\n                    \"{}set_stroke({});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}set_stroke({});\",\r\n                    get_indent(indent),\r\n                    write_exprs(exprs, indexes, \", \", indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Fill { indexes, .. } =\u003e {\r\n            if indexes[1] == usize::MAX {\r\n                format!(\r\n                    \"{}set_fill({});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}set_fill({});\",\r\n                    get_indent(indent),\r\n                    write_exprs(exprs, indexes, \", \", indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Color { indexes, .. } =\u003e {\r\n            format!(\"get_color({})\", write_exprs(exprs, indexes, \", \", indent))\r\n        }\r\n        Expr::LitString { str, .. } =\u003e {\r\n            let mut output: String = String::new();\r\n            for val in str.iter() {\r\n                if let VarOrStr::Var(var) = val {\r\n                    let new_val = format!(\"${{{}_var}}\", String::from_utf8_lossy(\u0026var.name));\r\n                    output += \u0026new_val[..];\r\n                } else if let VarOrStr::Str(str) = val {\r\n                    let new_val = String::from_utf8_lossy(str);\r\n                    output += \u0026new_val[..];\r\n                }\r\n            }\r\n            format!(\"`{}`\", output)\r\n        }\r\n        Expr::MoveTo { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}move_to({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::LineWidth { child_index, .. } =\u003e {\r\n            format!(\r\n                \"{}set_line_width({});\",\r\n                get_indent(indent),\r\n                write_expr(exprs, *child_index, indent)\r\n            )\r\n        }\r\n        Expr::Rotate { index, .. } =\u003e {\r\n            format!(\r\n                \"{}rotate_delta({});\",\r\n                get_indent(indent),\r\n                write_expr(exprs, *index, indent)\r\n            )\r\n        }\r\n        Expr::Append { indexes, .. } =\u003e {\r\n            if indexes[2] == usize::MAX {\r\n                format!(\r\n                    \"{}{}.push({});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    write_expr(exprs, indexes[1], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}{}.splice({}, 0, {});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    write_expr(exprs, indexes[2], indent),\r\n                    write_expr(exprs, indexes[1], indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Delete { indexes, .. } =\u003e {\r\n            if indexes[1] == usize::MAX {\r\n                format!(\r\n                    \"{}{}.splice(0,1);\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}{}.splice({},1);\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    write_expr(exprs, indexes[1], indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Replace { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}{}[{}]={};\",\r\n                get_indent(indent),\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_expr(exprs, indexes[1], indent),\r\n                write_expr(exprs, indexes[2], indent)\r\n            )\r\n        }\r\n        Expr::Find { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}{}.indexOf({})\",\r\n                get_indent(indent),\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_expr(exprs, indexes[1], indent)\r\n            )\r\n        }\r\n        Expr::Index { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}[{}]\",\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_expr(exprs, indexes[1], indent)\r\n            )\r\n        }\r\n        Expr::List { indexes, .. } =\u003e {\r\n            format!(\"[{}]\", write_exprs(exprs, indexes, \", \", indent))\r\n        }\r\n        Expr::ForEach { indexes, var, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}for(let {}_var of {}) {{\\n{}\\n{}}}\",\r\n                ind,\r\n                String::from_utf8_lossy(\u0026var.name),\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_exprs(exprs, \u0026indexes[1..], \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::Function {\r\n            func,\r\n            args,\r\n            indexes,\r\n            ..\r\n        } =\u003e {\r\n            let args_str = args\r\n                .into_iter()\r\n                .map(|data| String::from_utf8_lossy(\u0026data.name) + \"_var\")\r\n                .collect::\u003cVec\u003c_\u003e\u003e()\r\n                .join(\", \");\r\n\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"function {}_var({}) {{\\n{}\\n}}\",\r\n                String::from_utf8_lossy(\u0026func.name),\r\n                args_str,\r\n                write_exprs(exprs, indexes, \"\\n\", indent)\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::FunctionCall { func, indexes, .. } =\u003e {\r\n            //Trying without a semicolon since JS lets you forget them sometimes and function calls can be either expressions or statements\r\n            format!(\r\n                \"{}_var({})\",\r\n                String::from_utf8_lossy(\u0026func.name),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Return { index, .. } =\u003e {\r\n            if let Some(ind) = index {\r\n                format!(\r\n                    \"{}return {};\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, *ind, indent)\r\n                )\r\n            } else {\r\n                format!(\"{}return;\", get_indent(indent))\r\n            }\r\n        }\r\n        Expr::Length { index, .. } =\u003e {\r\n            format!(\"{}.length\", write_expr(exprs, *index, indent))\r\n        }\r\n        Expr::Not { .. } =\u003e {\r\n            format!(\"\")\r\n        }\r\n    }\r\n}\r\n\r\nfn write_exprs(\r\n    exprs: \u0026ExprArena,\r\n    indexes: \u0026[usize],\r\n    delimeter: \u0026str,\r\n    indent: \u0026mut usize,\r\n) -\u003e String {\r\n    if indexes.len() == 0 {\r\n        return \"\".to_string();\r\n    }\r\n    let mut ret = String::new();\r\n    ret += write_expr(exprs, indexes[0], indent).as_str();\r\n    for index in \u0026indexes[1..] {\r\n        if *index != usize::MAX {\r\n            ret += delimeter;\r\n            ret += write_expr(exprs, *index, indent).as_str();\r\n        }\r\n    }\r\n    ret\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":300},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","lisp_like_writer.rs"],"content":"use std::usize;\r\n\r\nuse crate::{\r\n    commands::*,\r\n    parser::{multi_lit_num::VarOrInt, string_lit::VarOrStr, End, SubStrData},\r\n};\r\n\r\nfn write_end(end: End) -\u003e String {\r\n    let mut ret = String::new();\r\n    if end.index != usize::MAX {\r\n        ret += \"$\";\r\n        ret += \u0026end.index.to_string();\r\n        if end.count != 1 {\r\n            ret += \"$$\";\r\n            ret += \u0026end.count.to_string();\r\n        }\r\n    }\r\n    ret\r\n}\r\n\r\nfn join_locs(locs: \u0026Vec\u003cusize\u003e, end: Option\u003cEnd\u003e) -\u003e String {\r\n    if locs.is_empty() {\r\n        \"\".to_string()\r\n    } else {\r\n        let mut iter = locs.into_iter();\r\n        let first = iter.next().unwrap();\r\n        let mut ret = iter.fold(\"@\".to_string() + \u0026first.to_string(), |a, b| {\r\n            a + \u0026\",\" + \u0026b.to_string()\r\n        });\r\n        if let Some(end) = end {\r\n            ret += \u0026write_end(end);\r\n        }\r\n        ret\r\n    }\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn write(exprs: \u0026ExprArena, line_starts: \u0026Vec\u003cusize\u003e) -\u003e String {\r\n    let mut str = \"\".to_string();\r\n    for statement in line_starts {\r\n        str += \u0026write_expr(exprs, *statement, 0);\r\n        str += \"\\n\";\r\n    }\r\n    str.pop();\r\n    str\r\n}\r\n#[allow(dead_code)]\r\npub fn write_first(exprs: \u0026ExprArena) -\u003e String {\r\n    write_expr(exprs, 0, 0)\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn write_one(exprs: \u0026ExprArena, index: usize) -\u003e String {\r\n    write_expr(exprs, index, 0)\r\n}\r\n\r\nfn write_expr(exprs: \u0026ExprArena, index: usize, indent: usize) -\u003e String {\r\n    match \u0026exprs[index] {\r\n        Expr::NoneStat =\u003e \"(todo stat)\".to_string(),\r\n        Expr::NoneExpr =\u003e \"(todo expr)\".to_string(),\r\n        Expr::Title { data } =\u003e {\r\n            let author_str = data.authors.iter().fold(String::new(), |str, author| {\r\n                format!(\r\n                    \"{str} \\\"{}\\\"@{}$${}\",\r\n                    String::from_utf8_lossy(\u0026author.0),\r\n                    author.1,\r\n                    author.2\r\n                )\r\n            });\r\n\r\n            let imports_str = data.imports.iter().fold(String::new(), |str, import| {\r\n                format!(\"{str} {}@{}$${}\", import.0.get_name(), import.1, import.2)\r\n            });\r\n\r\n            format!(\r\n                \"(title \\\"{}\\\" (authors{author_str})@{} (imports{imports_str}))\",\r\n                String::from_utf8_lossy(\u0026data.title),\r\n                data.by_start\r\n            )\r\n        }\r\n        Expr::Assign {\r\n            locs,\r\n            var,\r\n            value_index,\r\n            end,\r\n            first,\r\n        } =\u003e format!(\r\n            \"(assign{} {}{} {})\",\r\n            join_locs(locs, Some(*end)),\r\n            if *first { \"\" } else { \"mut \" },\r\n            write_var(var),\r\n            write_expr(exprs, *value_index, 0)\r\n        ),\r\n        Expr::Bezier { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(bezier{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Line { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(line{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Arc { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(arc{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Rect { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(rect{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Var { var } =\u003e format!(\"(var {})\", write_var(var)),\r\n        Expr::WordNum {\r\n            locs,\r\n            str_start,\r\n            str_len,\r\n            end,\r\n        } =\u003e format!(\r\n            \"(wordnum{} {}@{})\",\r\n            join_locs(locs, Some(*end)),\r\n            *str_len,\r\n            *str_start,\r\n        ),\r\n        Expr::Operator {\r\n            locs,\r\n            func_type,\r\n            indexes,\r\n            end,\r\n        } =\u003e {\r\n            let name = match func_type {\r\n                OperatorType::Add =\u003e \"+\",\r\n                OperatorType::Sub =\u003e \"-\",\r\n                OperatorType::Mult =\u003e \"*\",\r\n                OperatorType::Div =\u003e \"/\",\r\n                OperatorType::Mod =\u003e \"%\",\r\n                OperatorType::Exp =\u003e \"exp\",\r\n                OperatorType::Log =\u003e \"log\",\r\n                OperatorType::LessThan =\u003e \"\u003c\",\r\n                OperatorType::GreaterThan =\u003e \"\u003e\",\r\n                OperatorType::And =\u003e \"\u0026\",\r\n                OperatorType::Or =\u003e \"||\",\r\n                OperatorType::Equals =\u003e \"==\",\r\n                OperatorType::Not =\u003e \"!\",\r\n            };\r\n            format!(\r\n                \"({}{} {})\",\r\n                name,\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::LitNum {\r\n            str_start,\r\n            str_length,\r\n            value,\r\n        } =\u003e format!(\"(litnum {}@{}$${})\", value, str_start, str_length),\r\n        Expr::MultiLitNum {\r\n            locs,\r\n            single_value,\r\n            values,\r\n            end,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(intval) = single_value {\r\n                format!(\"(litnum{} {})\", join_locs(locs, Some(*end)), intval)\r\n            } else {\r\n                let mut output_vals = \"\".to_string();\r\n                let mut is_first = true;\r\n                for val in values {\r\n                    if !is_first {\r\n                        output_vals += \" \";\r\n                    } else {\r\n                        is_first = false;\r\n                    }\r\n                    if let VarOrInt::Var(var) = val {\r\n                        output_vals += \u0026format!(\"{}\", String::from_utf8_lossy(\u0026var.name));\r\n                    } else if let VarOrInt::Int(intval) = val {\r\n                        output_vals += \u0026format!(\"{}\", intval);\r\n                    }\r\n                }\r\n                format!(\r\n                    \"(multilitnum{} {})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    output_vals\r\n                )\r\n            }\r\n        }\r\n        Expr::Print {\r\n            locs,\r\n            indexes,\r\n            end,\r\n            single_word,\r\n            single_word_start,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(word) = single_word {\r\n                format!(\r\n                    \"(print{} \\\"{}\\\"@{})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    String::from_utf8_lossy(word),\r\n                    single_word_start\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"(print{} {})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    write_exprs(exprs, indexes)\r\n                )\r\n            }\r\n        }\r\n        Expr::If {\r\n            locs, indexes, end, ..\r\n        } =\u003e {\r\n            let split = indexes.split_at_checked(1).unwrap_or_default();\r\n            format!(\r\n                \"(if{} {} then:\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *split.0.first().unwrap_or(\u0026usize::MAX), 0),\r\n                write_stats(exprs, split.1, indent + 1)\r\n            )\r\n        }\r\n        Expr::While {\r\n            locs, indexes, end, ..\r\n        } =\u003e {\r\n            let split = indexes.split_at_checked(1).unwrap_or_default();\r\n            format!(\r\n                \"(while{} {} then:\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *split.0.first().unwrap_or(\u0026usize::MAX), 0),\r\n                write_stats(exprs, split.1, indent + 1),\r\n            )\r\n        }\r\n        Expr::Else { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(else{}\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                write_stats(exprs, indexes, indent + 1)\r\n            )\r\n        }\r\n        Expr::LitCol {\r\n            str_start,\r\n            str_length,\r\n            value,\r\n        } =\u003e {\r\n            format!(\r\n                \"(litcol {}@{}$${})\",\r\n                String::from_utf8_lossy(value),\r\n                str_start,\r\n                str_length\r\n            )\r\n        }\r\n        Expr::Color { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(color{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Stroke { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(stroke{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Fill { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(fill{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::LitString { str, str_start, .. } =\u003e {\r\n            let mut output: String = String::new();\r\n            for val in str.iter() {\r\n                if let VarOrStr::Var(var) = val {\r\n                    let new_val = format!(\"{}\", String::from_utf8_lossy(\u0026var.name));\r\n                    output += \u0026new_val[..];\r\n                } else if let VarOrStr::Str(str) = val {\r\n                    let new_val = String::from_utf8_lossy(str);\r\n                    output += \u0026new_val[..];\r\n                }\r\n            }\r\n            format!(\"\\\"{}\\\"@{}\", output, str_start)\r\n        }\r\n        Expr::MoveTo { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(moveto{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::LineWidth {\r\n            locs,\r\n            child_index,\r\n            end,\r\n        } =\u003e {\r\n            format!(\r\n                \"(linewidth{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *child_index, 0)\r\n            )\r\n        }\r\n        Expr::Rotate { locs, index, end } =\u003e {\r\n            format!(\r\n                \"(rotate{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *index, 0)\r\n            )\r\n        }\r\n        Expr::Append { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(append{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Delete { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(delete{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Replace { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(replace{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Find { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(find{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Index { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(index{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::List { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(list{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::ForEach {\r\n            locs,\r\n            indexes,\r\n            end,\r\n            var,\r\n            ..\r\n        } =\u003e {\r\n            let split = indexes.split_at_checked(1).unwrap_or_default();\r\n            format!(\r\n                \"(foreach{} {} {} then:\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                String::from_utf8_lossy(\u0026var.name),\r\n                write_expr(exprs, *split.0.first().unwrap_or(\u0026usize::MAX), 0),\r\n                write_stats(exprs, split.1, indent + 1),\r\n            )\r\n        }\r\n        Expr::Function {\r\n            locs,\r\n            func,\r\n            args,\r\n            indexes,\r\n            end,\r\n            ..\r\n        } =\u003e {\r\n            let args_str = args\r\n                .into_iter()\r\n                .fold(String::new(), |str, arg| str + \u0026\" \" + \u0026write_var(arg));\r\n            format!(\r\n                \"(function{} {} (args{}) {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_var(func),\r\n                args_str,\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::FunctionCall {\r\n            locs,\r\n            func,\r\n            indexes,\r\n            end,\r\n            ..\r\n        } =\u003e {\r\n            format!(\r\n                \"({}{} {})\",\r\n                write_var(func),\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Return { locs, index, end } =\u003e {\r\n            if let Some(ind) = index {\r\n                format!(\r\n                    \"(return{} {})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    write_expr(exprs, *ind, 0)\r\n                )\r\n            } else {\r\n                format!(\"(return{})\", join_locs(locs, Some(*end)))\r\n            }\r\n        }\r\n        Expr::Length { locs, index, end } =\u003e {\r\n            format!(\r\n                \"(length{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *index, 0)\r\n            )\r\n        }\r\n        Expr::Not {\r\n            locs,\r\n            word,\r\n            str_start,\r\n            str_len,\r\n            end,\r\n        } =\u003e {\r\n            format!(\r\n                \"(not{} @{}$${} \\\"{}\\\")\",\r\n                join_locs(locs, Some(*end)),\r\n                *str_start,\r\n                *str_len,\r\n                String::from_utf8_lossy(word)\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\nfn write_exprs(exprs: \u0026ExprArena, indexes: \u0026[usize]) -\u003e String {\r\n    write_mult_exprs(exprs, indexes, b' ', 0)\r\n}\r\nfn write_stats(exprs: \u0026ExprArena, indexes: \u0026[usize], indent: usize) -\u003e String {\r\n    write_mult_exprs(exprs, indexes, b'\\n', indent)\r\n}\r\nfn write_mult_exprs(exprs: \u0026ExprArena, indexes: \u0026[usize], char: u8, indent: usize) -\u003e String {\r\n    let mut ret = String::new();\r\n    for index in indexes {\r\n        if *index != usize::MAX {\r\n            for _ in 0..indent {\r\n                ret += \"  \";\r\n            }\r\n            ret += \u0026write_expr(exprs, *index, indent);\r\n            ret.push(char as char);\r\n        }\r\n    }\r\n    ret.pop();\r\n    ret\r\n}\r\n\r\nfn write_var(var: \u0026SubStrData) -\u003e String {\r\n    let mut skips_str = String::new();\r\n    if !var.skip_indexes.is_empty() {\r\n        skips_str += \"|\";\r\n        skips_str += \u0026var\r\n            .skip_indexes\r\n            .iter()\r\n            .map(|f| f.to_string())\r\n            .collect::\u003cVec\u003cString\u003e\u003e()\r\n            .join(\",\");\r\n    }\r\n\r\n    format!(\r\n        \"\\\"{}\\\"@{}{}\",\r\n        String::from_utf8_lossy(\u0026var.name),\r\n        var.start,\r\n        skips_str\r\n    )\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":9,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":10,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":11,"address":[],"length":0,"stats":{"Line":2377900603251621890}},{"line":12,"address":[],"length":0,"stats":{"Line":2377900603251621890}},{"line":13,"address":[],"length":0,"stats":{"Line":4899916394579099652}},{"line":14,"address":[],"length":0,"stats":{"Line":2522015791327477762}},{"line":15,"address":[],"length":0,"stats":{"Line":2522015791327477762}},{"line":18,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":21,"address":[],"length":0,"stats":{"Line":2810246167479189505}},{"line":22,"address":[],"length":0,"stats":{"Line":2810246167479189505}},{"line":23,"address":[],"length":0,"stats":{"Line":432345564227567618}},{"line":25,"address":[],"length":0,"stats":{"Line":2377900603251621887}},{"line":26,"address":[],"length":0,"stats":{"Line":2377900603251621887}},{"line":27,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":28,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":30,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":31,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":33,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":38,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":39,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":40,"address":[],"length":0,"stats":{"Line":14987979559889010693}},{"line":41,"address":[],"length":0,"stats":{"Line":18086456103519911937}},{"line":42,"address":[],"length":0,"stats":{"Line":18086456103519911937}},{"line":44,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":45,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":2377900603251621889}},{"line":58,"address":[],"length":0,"stats":{"Line":2377900603251621889}},{"line":59,"address":[],"length":0,"stats":{"Line":18446744073709551611}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":83,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":84,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":85,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":86,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":87,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":89,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":90,"address":[],"length":0,"stats":{"Line":12105675798371893249}},{"line":91,"address":[],"length":0,"stats":{"Line":15276209936040722433}},{"line":92,"address":[],"length":0,"stats":{"Line":15276209936040722433}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":118,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":119,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":122,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":130,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":135,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":136,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":137,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":138,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":140,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":164,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":165,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":166,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":168,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":169,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":170,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":171,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":174,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":177,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":178,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":179,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":180,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":181,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":183,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":188,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":191,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":193,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":194,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":199,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":200,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":201,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":202,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":203,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":206,"address":[],"length":0,"stats":{"Line":3386706919782612993}},{"line":207,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":209,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":210,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":211,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":214,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":216,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":217,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":222,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":223,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":224,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":225,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":227,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":228,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":229,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":233,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":234,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":235,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":236,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":238,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":239,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":240,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":243,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":244,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":246,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":247,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":251,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":252,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":253,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":254,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":255,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":257,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":258,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":259,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":284,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":285,"address":[],"length":0,"stats":{"Line":576460752303423489}},{"line":286,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":289,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":294,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":357,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":359,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":360,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":364,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":365,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":366,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":367,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":368,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":369,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":370,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":371,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":373,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":374,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":375,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":376,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":380,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":381,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":382,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":383,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":384,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":385,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":386,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":387,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":389,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":390,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":392,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":393,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":394,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":395,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":399,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":400,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":401,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":402,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":403,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":404,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":405,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":407,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":408,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":409,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":412,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":413,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":414,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":416,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":417,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":449,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":451,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":452,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":454,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":455,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":456,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":458,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":459,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":461,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":462,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":465,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":466,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":469,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":470,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":471,"address":[],"length":0,"stats":{"Line":17942340915444056063}},{"line":472,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":473,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":474,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":475,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":476,"address":[],"length":0,"stats":{"Line":1873497444986126335}},{"line":481,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":483,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":484,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":485,"address":[],"length":0,"stats":{"Line":17149707381026848768}}],"covered":205,"coverable":300},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","processing_writer.rs"],"content":"use crate::commands::*;\r\nuse bitflags::bitflags;\r\n#[allow(dead_code)]\r\n\r\n//from\r\n//https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html\r\n// Operator Precedence\r\n// additive -\u003e 10 * 2\r\n// multiplicative -\u003e 11*2\r\n\r\nconst TODO_FUNC: \u0026str = r#\"\r\n\u003cT\u003e T todo(){\r\n    throw new java.lang.UnsupportedOperationException(\"Not parsed yet\");\r\n}\"#;\r\n\r\nconst CIRCLE_FUNC: \u0026str = r#\"\r\nvoid pcircle(int x,int y,int r){\r\n    circle(x,y,r*2);\r\n}\"#;\r\n\r\nconst FUNCS: [\u0026str; 2] = [TODO_FUNC, CIRCLE_FUNC];\r\n\r\nbitflags! {\r\n    /// Represents a set of flags.\r\n    #[derive(Debug, Default)]\r\n    struct FuncFlags: u32 {\r\n        const uses_todo = 1;\r\n        const uses_circle = 2;\r\n    }\r\n}\r\n\r\nfn write_functions(flags: FuncFlags, str: \u0026mut String) {\r\n    for flag in flags {\r\n        *str += FUNCS[flag.bits() as usize];\r\n    }\r\n}\r\n\r\npub fn write(exprs: \u0026ExprArena, line_starts: \u0026Vec\u003cusize\u003e) -\u003e String {\r\n    let mut flags = Default::default();\r\n    let mut str = \"void setup(){\r\n        size(400, 400);\r\n    }\"\r\n    .to_string();\r\n\r\n    let mut code = \"\r\nvoid draw(){ \r\n    background(255);\r\n\"\r\n    .to_string();\r\n    for statement in line_starts {\r\n        code += \"    \";\r\n        code += \u0026write_stat(exprs, *statement, \u0026mut flags);\r\n    }\r\n\r\n    write_functions(flags, \u0026mut str);\r\n\r\n    str + \u0026code + \"}\"\r\n}\r\n\r\nfn write_stat(exprs: \u0026ExprArena, start: usize, flags: \u0026mut FuncFlags) -\u003e String {\r\n    match \u0026exprs[start] {\r\n        Expr::NoneStat =\u003e \";\\n\".to_string(),\r\n        Expr::Set {\r\n            name, value_index, ..\r\n        } =\u003e format!(\r\n            \"var {}={};\\n\",\r\n            String::from_utf8_lossy(\u0026name),\r\n            write_expr(exprs, *value_index, 0, flags)\r\n        ),\r\n        Expr::Line { indexes, .. } =\u003e format!(\r\n            \"line({},{},{},{});\\n\",\r\n            write_expr(exprs, indexes[0], 0, flags),\r\n            write_expr(exprs, indexes[1], 0, flags),\r\n            write_expr(exprs, indexes[2], 0, flags),\r\n            write_expr(exprs, indexes[3], 0, flags)\r\n        ),\r\n        Expr::Arc { indexes, .. } =\u003e {\r\n            *flags |= FuncFlags::uses_circle;\r\n            format!(\r\n                \"pcircle({},{},{});\\n\",\r\n                write_expr(exprs, indexes[0], 0, flags),\r\n                write_expr(exprs, indexes[1], 0, flags),\r\n                write_expr(exprs, indexes[2], 0, flags)\r\n            )\r\n        }\r\n        expr =\u003e panic!(\"found non starting expresion {expr:?} in starting position\"),\r\n    }\r\n}\r\n\r\nfn write_expr(\r\n    exprs: \u0026ExprArena,\r\n    index: usize,\r\n    last_precedence: u8,\r\n    flags: \u0026mut FuncFlags,\r\n) -\u003e String {\r\n    match \u0026exprs[index] {\r\n        Expr::NoneExpr =\u003e {\r\n            *flags |= FuncFlags::uses_todo;\r\n            \"todo()\".to_string()\r\n        }\r\n        Expr::Var { name, .. } =\u003e String::from_utf8_lossy(\u0026name).to_string(),\r\n        Expr::WordNum { str, .. } =\u003e format!(\"\\\"{}\\\".length()\", String::from_utf8_lossy(\u0026str)),\r\n        Expr::Operator {\r\n            func_type, indexes, ..\r\n        } =\u003e {\r\n            let func_data = match func_type {\r\n                OperatorType::Add =\u003e (\"+\", 10 * 2),\r\n                OperatorType::Sub =\u003e (\"-\", 10 * 2),\r\n                OperatorType::Mult =\u003e (\"*\", 11 * 2),\r\n                OperatorType::Div =\u003e (\"/\", 11 * 2),\r\n                OperatorType::Mod =\u003e (\"%\", 11 * 2),\r\n            };\r\n            write_var_len_operator(\r\n                exprs,\r\n                indexes,\r\n                func_data.0,\r\n                last_precedence,\r\n                func_data.1,\r\n                flags,\r\n            )\r\n        }\r\n\r\n        Expr::LitNum { value, .. } =\u003e format!(\"{}\", value),\r\n        expr =\u003e panic!(\"found starting expresion {expr:?} in non starting position\"),\r\n    }\r\n}\r\n\r\nfn write_var_len_operator(\r\n    exprs: \u0026ExprArena,\r\n    indexes: \u0026Vec\u003cusize\u003e,\r\n    operator: \u0026str,\r\n    last_precedence: u8,\r\n    current_precedence: u8,\r\n    flags: \u0026mut FuncFlags,\r\n) -\u003e String {\r\n    if indexes.len() \u003c 2 {\r\n        panic!(\"operator {operator} had less than two arguments\");\r\n    }\r\n    let add_paren = last_precedence \u003e current_precedence;\r\n    let mut ret = String::new();\r\n    if add_paren {\r\n        ret += \"(\";\r\n    }\r\n\r\n    ret += \u0026write_expr(exprs, indexes[0], current_precedence, flags);\r\n\r\n    for index in indexes.iter().skip(1) {\r\n        ret += operator;\r\n        ret += \u0026write_expr(exprs, *index, current_precedence + 1, flags);\r\n    }\r\n\r\n    if add_paren {\r\n        ret += \")\";\r\n    }\r\n    ret\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","runner.rs"],"content":"// use std::{collections::HashMap, default};\r\n\r\n// use crate::{commands::*, parser::State};\r\n\r\n// pub enum ValueType {\r\n//     // type , index\r\n//     Error(ErrorData),\r\n//     Number(i64),\r\n//     Float(f64),\r\n// }\r\n\r\n// impl ValueType {\r\n//     pub fn get_i64(\u0026self) -\u003e Option\u003ci64\u003e {\r\n//         match \u0026self {\r\n//             ValueType::Error(_) =\u003e None,\r\n//             ValueType::Number(i) =\u003e Some(*i),\r\n//             ValueType::Float(_) =\u003e None,\r\n//         }\r\n//     }\r\n\r\n//     pub fn get_f64(\u0026self) -\u003e Option\u003cf64\u003e {\r\n//         match \u0026self {\r\n//             ValueType::Error(_) =\u003e None,\r\n//             ValueType::Number(i) =\u003e Some(*i as f64),\r\n//             ValueType::Float(i) =\u003e Some(*i),\r\n//         }\r\n//     }\r\n\r\n//     // pub fn get_i64_cast(\u0026self) -\u003e Option\u003ci64\u003e {\r\n//     //     match \u0026self {\r\n//     //         ValueType::Error(_) =\u003e None,\r\n//     //         ValueType::Number(i) =\u003e Some(*i),\r\n//     //         ValueType::Float(i) =\u003e f64_to_i64(*i),\r\n//     //     }\r\n//     // }\r\n// }\r\n\r\n// // fn f64_to_i64(val:f64)-\u003eOption\u003ci64\u003e{\r\n// //     if val.is_nan() || val\u003ei64::MAX as f64||val\u003ci64::MIN  as f64{\r\n// //         None\r\n// //     }else {\r\n// //         val.round().\r\n// //     }\r\n// // }\r\n// #[derive(Debug)]\r\n\r\n// pub enum Error {\r\n//     Malformed,\r\n//     NotParsed,\r\n//     Div0,\r\n//     Log,\r\n//     TypeError,\r\n//     NoVarible,\r\n// }\r\n\r\n// pub struct ErrorData {\r\n//     error: Error,\r\n// }\r\n\r\n// pub struct Bounds {\r\n//     x1: f64,\r\n//     y1: f64,\r\n//     x2: f64,\r\n//     y2: f64,\r\n// }\r\n\r\n// pub enum Statement {\r\n//     Error(ErrorData, usize),\r\n//     Circle([f64; 3]),\r\n//     Ellipse([f64; 4]),\r\n//     Line([f64; 4]),\r\n//     Assign(Vec\u003cu8\u003e, ValueType),\r\n//     Square([f64; 3]),\r\n//     Rect([f64; 4]),\r\n//     Print(Vec\u003cPrints\u003e),\r\n// }\r\n// // name, index\r\n// type Vars = HashMap\u003cVec\u003cu8\u003e, ValueType\u003e;\r\n// pub struct ProgramRunner {\r\n//     pub bounds: Option\u003cBounds\u003e,\r\n//     pub vars: Vars,\r\n//     pub statements: Vec\u003cStatement\u003e,\r\n// }\r\n\r\n// #[allow(dead_code)]\r\n// impl ProgramRunner {\r\n//     pub fn new() -\u003e Self {\r\n//         Self {\r\n//             bounds: None,\r\n//             vars: Vars::new(),\r\n//             statements: Vec::new(),\r\n//         }\r\n//     }\r\n\r\n//     pub fn run(\u0026mut self, exprs: \u0026ExprArena, line_starts: \u0026[usize]) {\r\n//         let mut vars = Vars::new();\r\n//         let mut global_index = 0;\r\n//         for statement in line_starts {\r\n//             let stat;\r\n//             (stat, global_index) = run_statement(exprs, \u0026vars, *statement, global_index);\r\n//             self.run_statement_bounds(stat);\r\n//         }\r\n//     }\r\n// }\r\n\r\n// impl ProgramRunner {\r\n//     fn run_statement_bounds(\u0026mut self, stat: Statement) {\r\n//         match stat {\r\n//             Statement::Error(error, index) =\u003e {\r\n//                 println!(\"{:?} Error occured at {}\", error.error, index);\r\n//             }\r\n//             Statement::Assign(name, data) =\u003e {\r\n//                 self.vars.insert(name, data);\r\n//             }\r\n//             s @ Statement::Circle([x, y, r]) =\u003e {\r\n//                 self.add_to_bounds((x - r, y));\r\n//                 self.add_to_bounds((x + r, y));\r\n//                 self.add_to_bounds((x, y - r));\r\n//                 self.add_to_bounds((x, y + r));\r\n//                 self.statements.push(s);\r\n//             }\r\n//             s @ Statement::Ellipse([x, y, w, h]) =\u003e {\r\n//                 self.add_to_bounds((x - w, y));\r\n//                 self.add_to_bounds((x + w, y));\r\n//                 self.add_to_bounds((x, y - h));\r\n//                 self.add_to_bounds((x, y + h));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Line([x, y, x2, y2]) =\u003e {\r\n//                 self.add_to_bounds((x, y));\r\n//                 self.add_to_bounds((x2, y2));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Square([x, y, w]) =\u003e {\r\n//                 self.add_to_bounds((x, y));\r\n//                 self.add_to_bounds((x + w, y));\r\n//                 self.add_to_bounds((x, y + w));\r\n//                 self.add_to_bounds((x + w, y + w));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Rect([x, y, w, h]) =\u003e {\r\n//                 self.add_to_bounds((x, y));\r\n//                 self.add_to_bounds((x + w, y));\r\n//                 self.add_to_bounds((x, y + h));\r\n//                 self.add_to_bounds((x + w, y + h));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Print(_) =\u003e self.statements.push(s),\r\n//         };\r\n//     }\r\n\r\n//     fn add_to_bounds(\u0026mut self, point: (f64, f64)) {\r\n//         if let Some(bounds) = \u0026mut self.bounds {\r\n//             *bounds = Bounds {\r\n//                 x1: bounds.x1.min(point.0),\r\n//                 y1: bounds.y1.min(point.1),\r\n//                 x2: bounds.x2.max(point.0),\r\n//                 y2: bounds.y2.max(point.1),\r\n//             };\r\n//         } else {\r\n//             self.bounds = Some(Bounds {\r\n//                 x1: point.0,\r\n//                 y1: point.1,\r\n//                 x2: point.0,\r\n//                 y2: point.1,\r\n//             });\r\n//         }\r\n//     }\r\n// }\r\n// fn run_statement(\r\n//     exprs: \u0026ExprArena,\r\n//     vars: \u0026Vars,\r\n//     index: usize,\r\n//     mut global_index: usize,\r\n// ) -\u003e (Statement, usize) {\r\n//     match \u0026exprs[index] {\r\n//         Expr::NoneStat | Expr::NoneExpr =\u003e (\r\n//             Statement::Error(\r\n//                 ErrorData {\r\n//                     error: Error::NotParsed,\r\n//                 },\r\n//                 global_index,\r\n//             ),\r\n//             global_index,\r\n//         ),\r\n//         Expr::Arc { locs, indexes, end } =\u003e {\r\n//             let data;\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             (data, _) = run_varible_length_args(exprs, vars, indexes, global_index, |vec| {\r\n//                 match (vec.len(), vec) {\r\n//                     (0..=2, ..) =\u003e None,\r\n//                     (3, [a, b, c]) =\u003e Some((Statement::Circle([*a, *b, *c]), false)),\r\n//                     (4, [a, b, c, d]) =\u003e Some((Statement::Ellipse([*a, *b, *c, *d]), true)),\r\n//                     _ =\u003e unreachable!(),\r\n//                 }\r\n//             });\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         Expr::Line { locs, indexes, end } =\u003e {\r\n//             let data;\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             (data, _) = run_varible_length_args(exprs, vars, indexes, global_index, |vec| {\r\n//                 match (vec.len(), vec) {\r\n//                     (0..=3, ..) =\u003e None,\r\n//                     (4, [a, b, c, d]) =\u003e Some((Statement::Line([*a, *b, *c, *d]), true)),\r\n//                     _ =\u003e unreachable!(),\r\n//                 }\r\n//             });\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         Expr::Assign {\r\n//             locs,\r\n//             name_start,\r\n//             name,\r\n//             value_index,\r\n//             end,\r\n//         } =\u003e todo!(),\r\n//         Expr::Rect { locs, indexes, end } =\u003e {\r\n//             let data;\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             (data, _) = run_varible_length_args(exprs, vars, indexes, global_index, |vec| {\r\n//                 match (vec.len(), vec) {\r\n//                     (0..=2, ..) =\u003e None,\r\n//                     (3, [a, b, c]) =\u003e Some((Statement::Square([*a, *b, *c]), false)),\r\n//                     (4, [a, b, c, d]) =\u003e Some((Statement::Rect([*a, *b, *c, *d]), true)),\r\n//                     _ =\u003e unreachable!(),\r\n//                 }\r\n//             });\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         Expr::Print { locs, data, end } =\u003e {\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         // this should never run - but if it does than error\r\n//         _ =\u003e (\r\n//             Statement::Error(\r\n//                 ErrorData {\r\n//                     error: Error::Malformed,\r\n//                 },\r\n//                 global_index,\r\n//             ),\r\n//             global_index,\r\n//         ),\r\n//     }\r\n// }\r\n\r\n// fn run_expr(\r\n//     exprs: \u0026ExprArena,\r\n//     vars: \u0026Vars,\r\n//     index: usize,\r\n//     mut global_index: usize,\r\n// ) -\u003e (ValueType, usize) {\r\n//     match \u0026exprs[index] {\r\n//         Expr::NoneStat | Expr::NoneExpr =\u003e (\r\n//             ValueType::Error(ErrorData {\r\n//                 error: Error::NotParsed,\r\n//             }),\r\n//             global_index,\r\n//         ),\r\n//         Expr::Var { name_start, name } =\u003e todo!(),\r\n//         Expr::WordNum { str_len, end, .. } =\u003e (ValueType::Number(*str_len as i64), *end + 1),\r\n//         Expr::Operator {\r\n//             locs,\r\n//             func_type,\r\n//             indexes,\r\n//             end,\r\n//         } =\u003e match func_type {\r\n//             OperatorType::Add =\u003e todo!(),\r\n//             OperatorType::Sub =\u003e todo!(),\r\n//             OperatorType::Mult =\u003e todo!(),\r\n//             OperatorType::Div =\u003e todo!(),\r\n//             OperatorType::Mod =\u003e todo!(),\r\n//             OperatorType::Exp =\u003e todo!(),\r\n//             OperatorType::Log =\u003e todo!(),\r\n//         },\r\n//         Expr::LitNum {\r\n//             str_start,\r\n//             str_length,\r\n//             value,\r\n//         } =\u003e (ValueType::Number(*value), *str_start + *str_length),\r\n//         Expr::MultiLitNum {\r\n//             locs,\r\n//             num_indexes,\r\n//             end,\r\n//         } =\u003e todo!(),\r\n//         Expr::Skip {\r\n//             locs,\r\n//             index,\r\n//             start,\r\n//             end,\r\n//         } =\u003e {\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             run_expr(exprs, vars, *index, global_index)\r\n//         }\r\n\r\n//         // this should never run - but if it does than error\r\n//         _ =\u003e (\r\n//             ValueType::Error(ErrorData {\r\n//                 error: Error::Malformed,\r\n//             }),\r\n//             global_index,\r\n//         ),\r\n//     }\r\n// }\r\n\r\n// // None = cant closes\r\n// // Some(..,0) = can close\r\n// // Some(..,1) = must close\r\n// type VaribleLengthFn = fn(\u0026[f64]) -\u003e Option\u003c(Statement, bool)\u003e;\r\n// fn run_varible_length_args(\r\n//     exprs: \u0026ExprArena,\r\n//     vars: \u0026Vars,\r\n//     indexes: \u0026[usize],\r\n//     mut global_index: usize,\r\n//     close_fn: VaribleLengthFn,\r\n// ) -\u003e (Statement, usize) {\r\n//     let mut last_statement = None;\r\n//     let mut vec = Vec::with_capacity(indexes.len());\r\n//     for j in indexes {\r\n//         // end of arguments\r\n//         if *j == usize::MAX {\r\n//             break;\r\n//         }\r\n//         let data;\r\n//         (data, global_index) = run_expr(exprs, vars, *j, global_index);\r\n//         // get the value inside\r\n//         if let Some(val) = data.get_f64() {\r\n//             vec.push(val);\r\n//             // if error than return\r\n//         } else if let ValueType::Error(data) = data {\r\n//             return (Statement::Error(data, global_index), global_index);\r\n//             // else make error - type couldn't convert\r\n//         } else {\r\n//             return (\r\n//                 Statement::Error(\r\n//                     ErrorData {\r\n//                         error: Error::TypeError,\r\n//                     },\r\n//                     global_index,\r\n//                 ),\r\n//                 global_index,\r\n//             );\r\n//         }\r\n//         let close = (close_fn)(\u0026vec);\r\n//         if let Some((stat, must_close)) = close {\r\n//             if must_close {\r\n//                 return (stat, global_index);\r\n//             } else {\r\n//                 last_statement = Some(stat);\r\n//             }\r\n//         } else {\r\n//             last_statement = None;\r\n//         }\r\n//     }\r\n//     (\r\n//         last_statement.unwrap_or(Statement::Error(\r\n//             ErrorData {\r\n//                 error: Error::Malformed,\r\n//             },\r\n//             global_index,\r\n//         )),\r\n//         global_index,\r\n//     )\r\n// }\r\n\r\n// fn set_global_to_loc(global_index: \u0026mut usize, locs: \u0026[usize]) {\r\n//     if let Some(last) = locs.last() {\r\n//         *global_index = last + 1;\r\n//     }\r\n// }\r\n\r\n// fn set_global_to_end(global_index: \u0026mut usize, end: usize) {\r\n//     if end != usize::MAX {\r\n//         *global_index = end + 1;\r\n//     }\r\n// }\r\n// // fn run_3_or_4_args(exprs: \u0026ExprArena, indexes: [usize; 4], mut global_index: usize,checker:fn()-\u003eOptional\u003c(Statement,bool)\u003e)-\u003e (Result\u003cStatement,ErrorData\u003e, usize) {\r\n// //     let data = [0i64; 4];\r\n// //     let has_last = false;\r\n\r\n// // first 3\r\n// // for j in 0..3 {\r\n// //     if indexes[j] == usize::MAX {\r\n// //         return (Err(ErrorData {\r\n// //             error: Error::NotParsed,\r\n// //             index: global_index,\r\n// //         }),global_index);\r\n// //     }\r\n// //     if self.write_expr(exprs) {\r\n\r\n// //     }\r\n// // }\r\n// //     match (j==3,indexes[j] == usize::MAX){\r\n// //         (true, true) =\u003e {},\r\n// //         (true, false) =\u003e {has_last = false;},\r\n// //         (false, true) =\u003e { return (Statement::Error(ErrorData {\r\n// //             error: Error::NotParsed,\r\n// //             index: global_index,\r\n// //         }),global_index);\r\n// //     },\r\n// //         (false, false) =\u003e todo!(),\r\n// //     }\r\n// //     // if indexes[j] == usize::MAX {\r\n// //     //     if j!=3{\r\n// //     //         return Statement::Error(ErrorData {\r\n// //     //             error: Error::NotParsed,\r\n// //     //             index: global_index,\r\n// //     //         }),\r\n// //     //     }\r\n// //     // }\r\n\r\n// // (Ok((data,has_last)),global_index)\r\n// // todo!()\r\n// // }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_lint.rs"],"content":"use std::usize;\r\n\r\nuse crate::{\r\n    commands::*,\r\n    parser::{End, ParserSourceIter, SubStrData},\r\n};\r\n\r\nuse super::syntax_renderers::{Renderer, TermColor};\r\n\r\n//colors\r\nconst BASE_COLOR: (TermColor, bool) = (TermColor::White, true);\r\n// const IGNORE_COLOR: (TermColor, bool) = (TermColor::White, false);\r\n\r\nconst LOC_COLOR: [(TermColor, bool); 3] = [\r\n    (TermColor::Yellow, true),\r\n    (TermColor::Purple, true),\r\n    (TermColor::Blue, true),\r\n];\r\n\r\nconst STRING_COLOR: (TermColor, bool) = (TermColor::Black, true);\r\n\r\nconst VAR_COLOR: (TermColor, bool) = (TermColor::Cyan, true);\r\nconst NUM_COLOR: (TermColor, bool) = (TermColor::Green, true);\r\n\r\npub struct SyntaxLinter\u003cT: Renderer\u003e {\r\n    /// the renderer\r\n    renderer: T,\r\n    /// the current writing index\r\n    index: usize,\r\n    /// the length of ending characters and vec of ending colors if they exist\r\n    ends: Option\u003c(u8, Vec\u003c(TermColor, bool)\u003e)\u003e,\r\n}\r\n\r\n#[allow(dead_code)]\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            renderer: Default::default(),\r\n            index: 0,\r\n            ends: None,\r\n        }\r\n    }\r\n    pub fn into_data(self) -\u003e \u003cT as Renderer\u003e::Output {\r\n        self.renderer.into_data()\r\n    }\r\n}\r\n\r\n#[allow(dead_code)]\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    pub fn write(\r\n        \u0026mut self,\r\n        exprs: \u0026ExprArena,\r\n        line_starts: \u0026[usize],\r\n        mut source: ParserSourceIter,\r\n    ) {\r\n        for statement in line_starts {\r\n            self.write_expr(\u0026mut source, exprs, *statement, 0);\r\n            self.write_end(\u0026mut source);\r\n        }\r\n        self.write_rest(\u0026mut source);\r\n    }\r\n}\r\n\r\nfn get_n(source: \u0026mut ParserSourceIter, num: usize) -\u003e Result\u003cVec\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\r\n    let ret: Vec\u003cu8\u003e = source.take(num).cloned().collect();\r\n    if ret.len() == num {\r\n        Ok(ret)\r\n    } else {\r\n        Err(ret)\r\n    }\r\n}\r\n\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    fn write_rest(\u0026mut self, source: \u0026mut ParserSourceIter) {\r\n        let buf = get_n(source, usize::MAX).map_or_else(|e| e, |o| o);\r\n        self.index += buf.len();\r\n        self.renderer.add_with(\u0026buf, BASE_COLOR);\r\n    }\r\n    fn write_up_to(\u0026mut self, source: \u0026mut ParserSourceIter, index: usize) {\r\n        self.write_up_to_as(source, index, BASE_COLOR);\r\n    }\r\n    fn get_n_or_error(source: \u0026mut ParserSourceIter, num: usize) -\u003e Vec\u003cu8\u003e {\r\n        get_n(source, num).expect(\"writing should not find end of buffer\")\r\n    }\r\n    fn write_up_to_as(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        index: usize,\r\n        color: (TermColor, bool),\r\n    ) {\r\n        let num = index.checked_sub(self.index).expect(\u0026format!(\r\n            \"index {} should be after the writing index {}\",\r\n            index, self.index\r\n        ));\r\n        let buf = Self::get_n_or_error(source, num);\r\n        self.renderer.add_with(\u0026buf, color);\r\n        self.index = index;\r\n    }\r\n    // fn write_num(\u0026mut self, source: \u0026mut ParserSourceIter, index: usize) {\r\n    //     self.write_as(source, index, BASE_COLOR);\r\n    // }\r\n    fn write_as(\u0026mut self, source: \u0026mut ParserSourceIter, num: usize, color: (TermColor, bool)) {\r\n        let buf: Vec\u003cu8\u003e = Self::get_n_or_error(source, num);\r\n        self.renderer.add_with(\u0026buf, color);\r\n        self.index += num;\r\n    }\r\n\r\n    fn write_end(\u0026mut self, source: \u0026mut ParserSourceIter) {\r\n        if let Some(end) = self.ends.take() {\r\n            // let num = index\r\n            //     .checked_sub(self.index)\r\n            //     .expect(\"index is before the end index\");\r\n            let buf = Self::get_n_or_error(source, end.0 as usize);\r\n            self.renderer.add_with_mult(\u0026buf, end.1);\r\n            self.index += end.0 as usize;\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    fn write_var(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        var: \u0026SubStrData,\r\n        color: (TermColor, bool),\r\n    ) {\r\n        self.write_up_to(source, var.start);\r\n        for \u0026index in \u0026var.skip_indexes {\r\n            self.write_up_to_as(source, var.start + index as usize, color);\r\n            self.write_as(source, 1, BASE_COLOR);\r\n        }\r\n        let len = var.name.len() + var.skip_indexes.len();\r\n        self.write_up_to_as(source, var.start + len, color);\r\n    }\r\n\r\n    fn write_locs(\u0026mut self, source: \u0026mut ParserSourceIter, locs: \u0026Vec\u003cusize\u003e, stack_index: usize) {\r\n        let color = LOC_COLOR[stack_index % 3];\r\n        for loc in locs {\r\n            self.write_up_to(source, *loc);\r\n            self.write_as(source, 1, color);\r\n        }\r\n    }\r\n\r\n    fn add_end(\u0026mut self, source: \u0026mut ParserSourceIter, end: End, stack_index: usize) {\r\n        let color = LOC_COLOR[stack_index % 3];\r\n        if end.index != usize::MAX {\r\n            //let close_index = self.index - end.count as usize;\r\n\r\n            // if close_index == self.index {\r\n\r\n            // } else {\r\n            //     //different close character\r\n            // }\r\n\r\n            // if passed close\r\n            if self.ends.is_some() \u0026\u0026 end.index \u003e self.index {\r\n                self.write_end(source);\r\n                self.write_up_to(source, end.index);\r\n            //close is before index\r\n            } else if end.index \u003c self.index {\r\n                unreachable!(\r\n                    \"close index {} should be after writing index {}\",\r\n                    end.index, self.index\r\n                );\r\n            }\r\n            // setup close\r\n            if let Some((_, vec)) = \u0026mut self.ends {\r\n                vec.push(color);\r\n            } else {\r\n                self.write_up_to(source, end.index);\r\n                self.ends = Some((end.count, vec![color]));\r\n            }\r\n        }\r\n    }\r\n\r\n    fn write_exprs(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        exprs: \u0026ExprArena,\r\n        indexes: \u0026[usize],\r\n        stack_index: usize,\r\n    ) {\r\n        for index in indexes {\r\n            self.write_expr(source, exprs, *index, stack_index);\r\n        }\r\n    }\r\n\r\n    fn write_expr(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        exprs: \u0026ExprArena,\r\n        index: usize,\r\n        stack_index: usize,\r\n    ) {\r\n        if index == usize::MAX {\r\n            return;\r\n        }\r\n        self.write_end(source);\r\n        match \u0026exprs[index] {\r\n            Expr::Title { data } =\u003e {\r\n                self.write_up_to_as(source, data.by_start, STRING_COLOR);\r\n                // color by\r\n                self.write_as(source, 2, LOC_COLOR[0]);\r\n                //write authors\r\n                let mut authors = data.authors.iter().peekable();\r\n                let mut imports = data.imports.iter().peekable();\r\n                let mut delims = data.delim.iter().peekable();\r\n                loop {\r\n                    // get lowest indexed thing or break -- this is atrocious\r\n                    let Some((write_delim, index, length)) = (match (delims.peek(), authors.peek())\r\n                    {\r\n                        (None, None) =\u003e None,\r\n                        (Some(delim), None) =\u003e Some((true, delim.0, delim.1.into())),\r\n                        (None, Some(author)) =\u003e Some((false, author.1, author.2)),\r\n                        (Some(delim), Some(author)) =\u003e Some(if delim.0 \u003c author.1 {\r\n                            (true, delim.0, delim.1.into())\r\n                        } else {\r\n                            (false, author.1, author.2)\r\n                        }),\r\n                    }) else {\r\n                        break;\r\n                    };\r\n\r\n                    // write delim\r\n                    if write_delim {\r\n                        self.write_up_to(source, index);\r\n                        self.write_as(source, length, LOC_COLOR[1]);\r\n                        delims.next();\r\n                    //write name\r\n                    } else {\r\n                        self.write_up_to(source, index);\r\n                        while let Some(\u0026\u0026(_, imp_index, imp_length)) = imports.peek() {\r\n                            // if import before end -- write that\r\n                            if imp_index \u003c index + length {\r\n                                self.write_up_to_as(source, imp_index, VAR_COLOR);\r\n                                self.write_as(source, imp_length.into(), LOC_COLOR[2]);\r\n                                imports.next();\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        self.write_up_to_as(source, index + length, VAR_COLOR);\r\n                        authors.next();\r\n                    }\r\n                }\r\n            }\r\n\r\n            Expr::Assign {\r\n                locs,\r\n                var,\r\n                value_index,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, var, VAR_COLOR);\r\n                self.write_expr(source, exprs, *value_index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Bezier { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Line { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Arc { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Rect { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Var { var } =\u003e self.write_var(source, var, VAR_COLOR),\r\n            Expr::WordNum {\r\n                locs,\r\n                str_start,\r\n                str_len,\r\n                end,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_len, STRING_COLOR);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Operator {\r\n                locs, indexes, end, ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LitNum {\r\n                str_start,\r\n                str_length,\r\n                ..\r\n            } =\u003e {\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_length, NUM_COLOR);\r\n            }\r\n            Expr::MultiLitNum {\r\n                locs,\r\n                end,\r\n                str_start,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, end.index - str_start, NUM_COLOR);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Print {\r\n                locs, indexes, end, ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::If {\r\n                locs,\r\n                // body_end ,\r\n                indexes,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::While {\r\n                locs,\r\n                // body_end ,\r\n                indexes,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LitCol {\r\n                str_start,\r\n                str_length,\r\n                ..\r\n            } =\u003e {\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_length, STRING_COLOR);\r\n            }\r\n            Expr::Stroke { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Fill { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Color { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n\r\n            Expr::Else {\r\n                locs, indexes, end, ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LitString {\r\n                str_start, str_end, ..\r\n            } =\u003e {\r\n                self.write_up_to(source, *str_start);\r\n                //one for each quote\r\n                //TODO: different color for variables\r\n                self.write_as(source, str_end - str_start + 1, STRING_COLOR);\r\n            }\r\n            Expr::MoveTo { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LineWidth {\r\n                locs,\r\n                child_index,\r\n                end,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_expr(source, exprs, *child_index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Rotate { locs, index, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_expr(source, exprs, *index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Function {\r\n                locs,\r\n                indexes,\r\n                end,\r\n                func,\r\n                args,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, func, VAR_COLOR);\r\n                for arg in args {\r\n                    self.write_var(source, arg, VAR_COLOR);\r\n                }\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Append { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::FunctionCall {\r\n                locs,\r\n                indexes,\r\n                end,\r\n                func,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, func, VAR_COLOR);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Delete { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Return { locs, index, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                if let Some(ind) = index {\r\n                    self.write_expr(source, exprs, *ind, stack_index + 1);\r\n                }\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Replace { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Find { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Index { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::List { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::ForEach {\r\n                locs,\r\n                indexes,\r\n                var,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, var, VAR_COLOR);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Length { locs, index, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_expr(source, exprs, *index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Not {\r\n                locs,\r\n                str_start,\r\n                str_len,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_len, STRING_COLOR);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::NoneExpr | Expr::NoneStat =\u003e {}\r\n        };\r\n    }\r\n}\r\n\r\n//The wizards were literally nine at most!\r\n\r\n//list[line_num, index, color,length]\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":297},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers","html_renderer.rs"],"content":"use super::{Renderer, TermColor};\r\nuse bstr::ByteSlice;\r\n\r\npub struct HTMLRenderer {\r\n    str: Vec\u003cu8\u003e,\r\n    old_color: (TermColor, bool),\r\n    new_color: (TermColor, bool),\r\n}\r\n\r\nimpl Default for HTMLRenderer {\r\n    fn default() -\u003e Self {\r\n        let color = (TermColor::White, true);\r\n        Self {\r\n            str: Vec::new(),\r\n            old_color: color,\r\n            new_color: color,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Renderer for HTMLRenderer {\r\n    type Output = Vec\u003cu8\u003e;\r\n\r\n    fn add(\u0026mut self, text: \u0026[u8]) {\r\n        let vec = text.replace(b\"\\n\", b\"\u003cbr\u003e\");\r\n        self.check_color();\r\n        self.str.extend_from_slice(\u0026vec);\r\n    }\r\n\r\n    fn push(\u0026mut self, char: u8) {\r\n        self.check_color();\r\n        self.str.push(char);\r\n    }\r\n\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.add(text);\r\n    }\r\n\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], colors: Vec\u003c(TermColor, bool)\u003e) {\r\n        for color in \u0026colors[..colors.len() - 1] {\r\n            self.set_color(*color);\r\n            self.push(b'_');\r\n        }\r\n        self.set_color(*colors.last().unwrap());\r\n        self.add(text);\r\n    }\r\n\r\n    fn push_with(\u0026mut self, char: u8, color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.push(char);\r\n    }\r\n\r\n    fn into_data(self) -\u003e Vec\u003cu8\u003e {\r\n        self.str\r\n    }\r\n}\r\n\r\nconst BASE_COLOR: (TermColor, bool) = (TermColor::White, true);\r\n\r\nimpl HTMLRenderer {\r\n    fn set_color(\u0026mut self, color: (TermColor, bool)) {\r\n        self.new_color = color;\r\n    }\r\n    fn check_color(\u0026mut self) {\r\n        if self.old_color != self.new_color {\r\n            Self::change_color(\u0026mut self.str, self.new_color, self.old_color);\r\n            self.old_color = self.new_color;\r\n        }\r\n    }\r\n\r\n    fn change_color(str: \u0026mut Vec\u003cu8\u003e, new_color: (TermColor, bool), old_color: (TermColor, bool)) {\r\n        if old_color != BASE_COLOR {\r\n            str.extend_from_slice(b\"\u003c/span\u003e\");\r\n        }\r\n        if new_color != BASE_COLOR {\r\n            str.extend_from_slice(b\"\u003cspan class=\\\"term_\");\r\n            if new_color.1 {\r\n                str.extend_from_slice(b\"b_\");\r\n            }\r\n            str.extend_from_slice(match new_color.0 {\r\n                TermColor::Black =\u003e b\"black\",\r\n                TermColor::Red =\u003e b\"red\",\r\n                TermColor::Green =\u003e b\"green\",\r\n                TermColor::Yellow =\u003e b\"yellow\",\r\n                TermColor::Blue =\u003e b\"blue\",\r\n                TermColor::Purple =\u003e b\"purple\",\r\n                TermColor::Cyan =\u003e b\"cyan\",\r\n                TermColor::White =\u003e b\"white\",\r\n            });\r\n            str.extend_from_slice(b\"\\\"\u003e\")\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers","line_renderer.rs"],"content":"use super::{Renderer, TermColor};\r\nuse bstr::ByteSlice;\r\n\r\npub struct LineRenderer {\r\n    vec: Vec\u003cHighlight\u003e,\r\n    curr_line: usize,\r\n    curr_index: usize,\r\n    old_color: Vec\u003c(TermColor, bool)\u003e,\r\n    new_color: Vec\u003c(TermColor, bool)\u003e,\r\n    force: bool,\r\n}\r\n\r\nimpl Default for LineRenderer {\r\n    fn default() -\u003e Self {\r\n        let color = vec![(TermColor::White, true)];\r\n        Self {\r\n            vec: Vec::new(),\r\n            old_color: color.clone(),\r\n            new_color: color,\r\n            curr_line: 0,\r\n            curr_index: 0,\r\n            force: false,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(feature = \"wasm\")]\r\nuse wasm_bindgen::prelude::*;\r\n#[allow(dead_code)]\r\n#[cfg_attr(feature = \"wasm\", wasm_bindgen(getter_with_clone))]\r\n#[derive(PartialEq, Eq, Clone, Debug)]\r\npub struct Highlight {\r\n    pub line: usize,\r\n    pub index: usize,\r\n    pub length: usize,\r\n    pub color: Vec\u003cString\u003e,\r\n}\r\n\r\n// #[cfg(feature = \"wasm\")]\r\n// use serde_wasm_bindgen::to_value;\r\n// #[cfg(feature = \"wasm\")]\r\n// use wasm_bindgen::JsValue;\r\n// #[cfg(feature = \"wasm\")]\r\n// #[allow(dead_code)]\r\n// #[wasm_bindgen]\r\n// impl Highlight {\r\n//     pub fn get_colors(\u0026self) -\u003e JsValue {\r\n//         serde_wasm_bindgen::to_value(\u0026self.color).unwrap()\r\n//     }\r\n// }\r\n\r\nimpl Renderer for LineRenderer {\r\n    type Output = Vec\u003cHighlight\u003e;\r\n\r\n    fn add(\u0026mut self, text: \u0026[u8]) {\r\n        let splited = text.split_str(b\"\\n\");\r\n        let mut first = true;\r\n        for line in splited {\r\n            if !first {\r\n                self.curr_line += 1;\r\n                self.curr_index = 0;\r\n                self.force = true;\r\n            }\r\n            self.change_or_add(line);\r\n            first = false;\r\n        }\r\n    }\r\n\r\n    fn push(\u0026mut self, char: u8) {\r\n        if char == b'\\n' {\r\n            self.curr_line += 1;\r\n            self.curr_index = 0;\r\n        } else {\r\n            self.change_or_add(\u0026[char]);\r\n        }\r\n    }\r\n\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool)) {\r\n        self.new_color = vec![color];\r\n        self.add(text);\r\n    }\r\n\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], colors: Vec\u003c(TermColor, bool)\u003e) {\r\n        self.new_color = colors;\r\n        self.add(text);\r\n    }\r\n\r\n    fn push_with(\u0026mut self, char: u8, color: (TermColor, bool)) {\r\n        self.new_color = vec![color];\r\n        self.push(char);\r\n    }\r\n\r\n    fn into_data(self) -\u003e Vec\u003cHighlight\u003e {\r\n        self.vec\r\n    }\r\n}\r\n\r\nconst BASE_COLOR: (TermColor, bool) = (TermColor::White, true);\r\n\r\nimpl LineRenderer {\r\n    fn change_or_add(\u0026mut self, str: \u0026[u8]) {\r\n        //if length 0, color shouldn't change either\r\n        if str.len() == 0 {\r\n            return;\r\n        }\r\n        // if color changed to base, nothing is needed\r\n        if self.new_color != vec![BASE_COLOR] {\r\n            // colors are same -- add to last\r\n            if self.old_color == self.new_color \u0026\u0026 !self.force {\r\n                // should always be safe due to the not BASE_COLOR check\r\n                let highlight = self.vec.last_mut().unwrap();\r\n                highlight.length += str.len();\r\n            // colors have changed\r\n            } else {\r\n                self.force = false;\r\n                self.vec.push(Highlight {\r\n                    line: self.curr_line,\r\n                    index: self.curr_index,\r\n                    length: str.len(),\r\n                    color: self.new_color.iter().map(Self::get_color_str).collect(),\r\n                });\r\n            }\r\n        }\r\n        self.curr_index += str.len();\r\n        self.old_color = self.new_color.clone();\r\n    }\r\n    fn get_color_str(color: \u0026(TermColor, bool)) -\u003e String {\r\n        match color {\r\n            (TermColor::Black, false) =\u003e \"term_black\",\r\n            (TermColor::Black, true) =\u003e \"term_b_black\",\r\n            (TermColor::Red, false) =\u003e \"term_red\",\r\n            (TermColor::Red, true) =\u003e \"term_b_red\",\r\n            (TermColor::Green, false) =\u003e \"term_green\",\r\n            (TermColor::Green, true) =\u003e \"term_b_green\",\r\n            (TermColor::Yellow, false) =\u003e \"term_yellow\",\r\n            (TermColor::Yellow, true) =\u003e \"term_b_yellow\",\r\n            (TermColor::Blue, false) =\u003e \"term_blue\",\r\n            (TermColor::Blue, true) =\u003e \"term_b_blue\",\r\n            (TermColor::Purple, false) =\u003e \"term_purple\",\r\n            (TermColor::Purple, true) =\u003e \"term_b_purple\",\r\n            (TermColor::Cyan, false) =\u003e \"term_cyan\",\r\n            (TermColor::Cyan, true) =\u003e \"term_b_cyan\",\r\n            (TermColor::White, false) =\u003e \"term_white\",\r\n            (TermColor::White, true) =\u003e \"term_b_white\",\r\n        }\r\n        .to_string()\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":63},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers","wind_renderer.rs"],"content":"use super::{Renderer, TermColor};\r\n\r\npub struct WindowsRenderer {\r\n    str: Vec\u003cu8\u003e,\r\n    old_color: (TermColor, bool),\r\n    new_color: (TermColor, bool),\r\n}\r\n\r\nimpl Default for WindowsRenderer {\r\n    fn default() -\u003e Self {\r\n        let color = (TermColor::White, true);\r\n        Self {\r\n            str: Vec::new(),\r\n            old_color: color,\r\n            new_color: color,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Renderer for WindowsRenderer {\r\n    type Output = Vec\u003cu8\u003e;\r\n\r\n    fn add(\u0026mut self, text: \u0026[u8]) {\r\n        self.check_color();\r\n        self.str.extend_from_slice(text);\r\n    }\r\n\r\n    fn push(\u0026mut self, char: u8) {\r\n        self.check_color();\r\n        self.str.push(char);\r\n    }\r\n\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.add(text);\r\n    }\r\n\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], colors: Vec\u003c(TermColor, bool)\u003e) {\r\n        for color in \u0026colors[..colors.len() - 1] {\r\n            self.set_color(*color);\r\n            self.push(b'_');\r\n        }\r\n        self.set_color(*colors.last().unwrap());\r\n        self.add(text);\r\n    }\r\n\r\n    fn push_with(\u0026mut self, char: u8, color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.push(char);\r\n    }\r\n\r\n    fn into_data(self) -\u003e Vec\u003cu8\u003e {\r\n        self.str\r\n    }\r\n}\r\nimpl WindowsRenderer {\r\n    fn set_color(\u0026mut self, color: (TermColor, bool)) {\r\n        self.new_color = color;\r\n    }\r\n    \r\n    fn check_color(\u0026mut self) {\r\n        if self.old_color != self.new_color {\r\n            Self::change_color(\u0026mut self.str, self.new_color);\r\n            self.old_color = self.new_color;\r\n        }\r\n    }\r\n\r\n    fn change_color(str: \u0026mut Vec\u003cu8\u003e, color: (TermColor, bool)) {\r\n        str.extend_from_slice(b\"\\x1b[\");\r\n        str.extend_from_slice(match color {\r\n            (TermColor::Black, false) =\u003e b\"30\",\r\n            (TermColor::Red, false) =\u003e b\"31\",\r\n            (TermColor::Green, false) =\u003e b\"32\",\r\n            (TermColor::Yellow, false) =\u003e b\"33\",\r\n            (TermColor::Blue, false) =\u003e b\"34\",\r\n            (TermColor::Purple, false) =\u003e b\"35\",\r\n            (TermColor::Cyan, false) =\u003e b\"36\",\r\n            (TermColor::White, false) =\u003e b\"37\",\r\n            (TermColor::Black, true) =\u003e b\"90\",\r\n            (TermColor::Red, true) =\u003e b\"91\",\r\n            (TermColor::Green, true) =\u003e b\"92\",\r\n            (TermColor::Yellow, true) =\u003e b\"93\",\r\n            (TermColor::Blue, true) =\u003e b\"94\",\r\n            (TermColor::Purple, true) =\u003e b\"95\",\r\n            (TermColor::Cyan, true) =\u003e b\"96\",\r\n            (TermColor::White, true) =\u003e b\"97\",\r\n        });\r\n        str.push(b'm');\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers.rs"],"content":"pub(crate) mod html_renderer;\r\npub(crate) mod wind_renderer;\r\npub(crate) mod line_renderer;\r\n\r\n#[allow(dead_code)]\r\n#[derive(PartialEq, Clone, Copy)]\r\npub enum TermColor {\r\n    Black,\r\n    Blue,\r\n    Cyan,\r\n    Green,\r\n    Purple,\r\n    Red,\r\n    White,\r\n    Yellow,\r\n}\r\n\r\n#[allow(dead_code)]\r\npub trait Renderer: Default {\r\n    type Output;\r\n    // fn set_color(\u0026mut self, color: (TermColor, bool));\r\n    fn add(\u0026mut self, text: \u0026[u8]);\r\n    fn push(\u0026mut self, text: u8);\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool));\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], color: Vec\u003c(TermColor, bool)\u003e);\r\n    fn push_with(\u0026mut self, text: u8, color: (TermColor, bool));\r\n    fn into_data(self) -\u003e Self::Output;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers.rs"],"content":"pub(crate) mod javascript_writer;\r\npub(crate) mod lisp_like_writer;\r\n\r\npub(crate) mod syntax_lint;\r\npub(crate) mod syntax_renderers;\r\n\r\npub(crate) mod error_messages;\r\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","commands.rs"],"content":"use std::ops::Index;\r\n\r\nuse crate::parser::multi_lit_num::VarOrInt;\r\nuse crate::parser::string_lit::VarOrStr;\r\nuse crate::parser::{End, SubStrData, Title};\r\n\r\n#[derive(PartialEq, Debug, Clone, Copy)]\r\npub enum OperatorType {\r\n    Add,\r\n    Sub,\r\n    Mult,\r\n    Div,\r\n    Mod,\r\n    Exp,\r\n    Log,\r\n    LessThan,\r\n    GreaterThan,\r\n    And,\r\n    Or,\r\n    Equals,\r\n    Not,\r\n}\r\n\r\n#[derive(PartialEq, Debug)]\r\npub enum Expr {\r\n    NoneStat,\r\n    NoneExpr,\r\n    //stats\r\n    Title {\r\n        data: Title,\r\n    },\r\n    Arc {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 4],\r\n        end: End,\r\n    },\r\n    Bezier {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Line {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 4],\r\n        end: End,\r\n    },\r\n    Rect {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 4],\r\n        end: End,\r\n    },\r\n    Assign {\r\n        locs: Vec\u003cusize\u003e,\r\n        var: SubStrData,\r\n        first: bool,\r\n        value_index: usize,\r\n        end: End,\r\n    },\r\n    Print {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        single_word: Option\u003cVec\u003cu8\u003e\u003e,\r\n        single_word_start: usize,\r\n        end: End,\r\n    },\r\n    If {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        else_index: usize,\r\n        end: End,\r\n    },\r\n    While {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Else {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    //expr\r\n    Var {\r\n        var: SubStrData,\r\n    },\r\n    WordNum {\r\n        locs: Vec\u003cusize\u003e,\r\n        str_start: usize,\r\n        str_len: usize,\r\n        end: End,\r\n    },\r\n    Operator {\r\n        locs: Vec\u003cusize\u003e,\r\n        func_type: OperatorType,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    LitNum {\r\n        str_start: usize,\r\n        str_length: usize,\r\n        value: i64,\r\n    },\r\n    //TODO: Could make a compiler optimization to pre-evaluate this if there are no variables\r\n    MultiLitNum {\r\n        str_start: usize,\r\n        locs: Vec\u003cusize\u003e,\r\n        values: Vec\u003cVarOrInt\u003e,\r\n        single_value: Option\u003ci64\u003e,\r\n        end: End,\r\n    },\r\n    Color {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Fill {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Stroke {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    LitCol {\r\n        str_start: usize,\r\n        str_length: usize,\r\n        value: Vec\u003cu8\u003e,\r\n    },\r\n    LitString {\r\n        str_start: usize,\r\n        str_end: usize,\r\n        str: Vec\u003cVarOrStr\u003e,\r\n    },\r\n    MoveTo {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    LineWidth {\r\n        locs: Vec\u003cusize\u003e,\r\n        child_index: usize,\r\n        end: End,\r\n    },\r\n    Rotate {\r\n        locs: Vec\u003cusize\u003e,\r\n        index: usize,\r\n        end: End,\r\n    },\r\n    Function {\r\n        locs: Vec\u003cusize\u003e,\r\n        func: SubStrData,\r\n        args: Vec\u003cSubStrData\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    FunctionCall {\r\n        locs: Vec\u003cusize\u003e,\r\n        func: SubStrData,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Return {\r\n        locs: Vec\u003cusize\u003e,\r\n        index: Option\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Append {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Delete {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    Replace {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 3],\r\n        end: End,\r\n    },\r\n    Find {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    Index {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: [usize; 2],\r\n        end: End,\r\n    },\r\n    List {\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    ForEach {\r\n        var: SubStrData,\r\n        locs: Vec\u003cusize\u003e,\r\n        indexes: Vec\u003cusize\u003e,\r\n        end: End,\r\n    },\r\n    Length {\r\n        locs: Vec\u003cusize\u003e,\r\n        index: usize,\r\n        end: End,\r\n    },\r\n    Not {\r\n        locs: Vec\u003cusize\u003e,\r\n        word: Vec\u003cu8\u003e,\r\n        str_start: usize,\r\n        str_len: usize,\r\n        end: End,\r\n    },\r\n}\r\n\r\nimpl Expr {\r\n    pub fn is_none(\u0026self) -\u003e bool {\r\n        match self {\r\n            Expr::NoneStat =\u003e true,\r\n            Expr::NoneExpr =\u003e true,\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n    // pub fn is_stat(\u0026self) -\u003e bool {\r\n    //     match self {\r\n    //         Expr::Arc { .. } | Expr::Line { .. } | Expr::Rect { .. } =\u003e true,\r\n    //         Expr::Assign { .. } | Expr::Print { .. } =\u003e true,\r\n    //         Expr::If { .. } | Expr::Else { .. } | Expr::While { .. } =\u003e true,\r\n    //         _ =\u003e false,\r\n    //     }\r\n    // }\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct ExprArena {\r\n    pub vec: Vec\u003cExpr\u003e,\r\n}\r\nimpl Index\u003cusize\u003e for ExprArena {\r\n    type Output = Expr;\r\n\r\n    fn index(\u0026self, index: usize) -\u003e \u0026Self::Output {\r\n        if index \u003c self.vec.len() {\r\n            \u0026self.vec[index]\r\n        } else {\r\n            \u0026Expr::NoneExpr\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":220,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":221,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":222,"address":[],"length":0,"stats":{"Line":15780613094306217965}},{"line":223,"address":[],"length":0,"stats":{"Line":5764607523034234897}},{"line":224,"address":[],"length":0,"stats":{"Line":8358680908399640578}},{"line":244,"address":[],"length":0,"stats":{"Line":2377900603251621899}},{"line":245,"address":[],"length":0,"stats":{"Line":2377900603251621899}},{"line":246,"address":[],"length":0,"stats":{"Line":2377900603251621892}},{"line":248,"address":[],"length":0,"stats":{"Line":7}}],"covered":9,"coverable":9},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","lib.rs"],"content":"#![cfg(feature = \"wasm\")]\r\n\r\nuse crate::parser::{Parser, ParserFlags};\r\n\r\n// #[path = \"testing/testing.rs\"]\r\n// mod testing;\r\n\r\nmod parser_runner;\r\n\r\nmod commands;\r\nmod parser;\r\nmod writers;\r\n\r\nuse crate::parser::{ParsedData, ParserResult};\r\nuse parser::ParserSource;\r\n\r\nuse crate::writers::javascript_writer;\r\nuse crate::writers::syntax_lint::SyntaxLinter;\r\nuse crate::writers::syntax_renderers::{\r\n    html_renderer::HTMLRenderer,\r\n    line_renderer::{Highlight, LineRenderer},\r\n};\r\nuse cap::Cap;\r\nuse std::alloc;\r\n\r\n// // When the `wee_alloc` feature is enabled, use `wee_alloc` as the global\r\n// // allocator.\r\n// #[global_allocator]\r\n// static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\r\n\r\n// fn setup() {\r\n//     console_error_panic_hook::set_once();\r\n// }\r\nuse wasm_bindgen::prelude::*;\r\n\r\n#[global_allocator]\r\nstatic ALLOCATOR: Cap\u003calloc::System\u003e = Cap::new(alloc::System, usize::max_value());\r\n\r\n#[wasm_bindgen]\r\npub fn get_heap_size() -\u003e usize {\r\n    ALLOCATOR.allocated()\r\n}\r\n\r\n#[wasm_bindgen]\r\npub struct ParserRunner;\r\n\r\n#[wasm_bindgen]\r\npub struct ParserRunnerData {\r\n    data: ParsedData\u003c'static\u003e,\r\n}\r\n\r\n#[wasm_bindgen]\r\nimpl ParserRunner {\r\n    #[wasm_bindgen(constructor)]\r\n    pub fn new() -\u003e Self {\r\n        Self\r\n    }\r\n\r\n    pub fn run_to_completion(\u0026mut self, source: \u0026str) -\u003e ParserRunnerData {\r\n        let mut parser = Parser::new(\r\n            ParserSource::from_string(source.as_bytes().to_vec()),\r\n            ParserFlags { title: true },\r\n        );\r\n\r\n        loop {\r\n            if parser.step() == ParserResult::NoInput {\r\n                break;\r\n            };\r\n        }\r\n\r\n        ParserRunnerData {\r\n            data: parser.into_data(),\r\n        }\r\n    }\r\n}\r\n\r\n#[wasm_bindgen]\r\nimpl ParserRunnerData {\r\n    pub fn get_javascript(\u0026self) -\u003e String {\r\n        javascript_writer::write(\u0026self.data.exprs, \u0026self.data.stat_starts)\r\n    }\r\n    pub fn get_html(\u0026self) -\u003e String {\r\n        let iter = self.data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cHTMLRenderer\u003e::new();\r\n        lint.write(\u0026self.data.exprs, \u0026self.data.stat_starts, iter);\r\n        String::from_utf8_lossy(\u0026lint.into_data()).to_string()\r\n    }\r\n    pub fn get_highlights(\u0026self) -\u003e Vec\u003cHighlight\u003e {\r\n        let iter = self.data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cLineRenderer\u003e::new();\r\n        lint.write(\u0026self.data.exprs, \u0026self.data.stat_starts, iter);\r\n        lint.into_data()\r\n    }\r\n}\r\n\r\n//wasm-pack build . -F wasm\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","main.rs"],"content":"#![cfg(not(feature = \"wasm\"))]\r\n\r\nuse std::{\r\n    collections::HashSet,\r\n    io::{self, Read},\r\n    mem,\r\n};\r\n\r\nuse crate::parser::{Parser, ParserFlags};\r\n\r\n#[path = \"testing/testing.rs\"]\r\nmod testing;\r\n//mod playground;\r\n\r\nmod parser_runner;\r\n\r\nmod commands;\r\nmod parser;\r\nmod writers;\r\n\r\nuse bstr::ByteSlice;\r\nuse itertools::Itertools;\r\nuse parser::ParserSource;\r\nuse parser_runner::{run_parser, RunnerFlags};\r\n\r\nfn main() {\r\n    // test_incorrect_colors();\r\n    // let t = Test;\r\n    // let ta: Box\u003cdyn Any\u003e = Box::new(Test);\r\n    // let ta2: Box\u003cdyn Test2\u003e = Box::new(Test);\r\n    // println!(\"{:?}\", t.type_id());\r\n    // println!(\"{:?}\", ta.type_id());\r\n    // println!(\"{:?}\", (*ta).type_id());\r\n    // println!(\"{:?}\", ta2.type_id());\r\n    // println!(\"{:?}\", (*(\u0026*ta2 as \u0026dyn Any)).type_id());\r\n    //playground::print_test();\r\n    //return;\r\n\r\n    println!(\"size of parser: {}\", mem::size_of::\u003cParser\u003e());\r\n\r\n    let mut args: Vec\u003cString\u003e = std::env::args().skip(1).collect();\r\n\r\n    for e in \u0026mut args {\r\n        e.make_ascii_lowercase();\r\n    }\r\n\r\n    args.sort();\r\n\r\n    let parser_flags = ParserFlags {\r\n        title: !cfg!(feature = \"no-title\"), //args.binary_search(\u0026\"not\".to_string()).is_ok(),\r\n    };\r\n\r\n    let vis_flags: RunnerFlags = RunnerFlags {\r\n        assert_steps: true,\r\n        input: true,\r\n        whole_program: true,\r\n        linted: true,\r\n        line_rendered: true,\r\n    };\r\n\r\n    run_parser(\r\n        parser_flags,\r\n        vis_flags,\r\n        ParserSource::from_stdin(), //ParserSource::from_string(MILO_POEM_2[0].to_vec())\r\n    );\r\n\r\n    let _ = io::stdin().read(\u0026mut [0u8]).unwrap();\r\n}\r\n\r\n#[allow(dead_code)]\r\nstatic MILO_POEM: [\u0026[u8]; 2] = [\r\n    b\"\r\nThe wizards utter 'paint iambically.'\r\nThe peasants hadn't choice but to obey.\r\n\\\r\nThe wizards' cruel entertainments chant\r\nand utter utter nonsense, void of weight.\r\n\\\r\nThe wizards' cursed victims utter trash;\r\nthe mages stand offended that despite\r\nintent most fair, the peasants: they dissent!\r\n\\\r\nThe wizards thought it boon to speak in verse\r\nbut overestimate the peasant's skill;\r\n'there is no point to it' the peasants thought.\r\n'What cruel poetry they thrust on us.'\r\nAnd so the peasants organized revolt.\r\n\\\r\nThey searched for mages speaking just in verse;\r\nthey thought and thought and thought 'where could they be?'\",\r\n    b\"\r\nBut long had passed; magicians marched away\r\nfrom cruel bitter thought and cursed man.\r\n\\\r\nAnd so in lack of overlords but yet\r\nstill wrought by curse the agriculturists\r\nadmitted thought that life is not so bad.\r\nDespite new vocal eccentricities,\r\ntheir burdens lifted free of mages cruel.\r\nThey thought that they were cursed, but in fact\r\n\\\r\nthe wizards had abandonded cruel thought,\r\nand left the peasants free of emperor.\r\n\\\r\nAnd so their revolution had achieved\r\na world where peasants had to speak in verse\r\nbut answered not to any cruel lord\r\nfor they had long since gone, with nothing left\r\nbut a society that slowly learned\r\nrestriction fosters creativity.\",\r\n];\r\n\r\n#[allow(dead_code)]\r\nstatic MILO_POEM_2: [\u0026[u8]; 1] = [b\"\r\n    was name les int marioooo. int luigi.!\r\n    was name2 mor int marioooo. int luigi.!\r\n    \"];\r\n\r\n// while !matches!(\r\n//     result,\r\n//     ParserResult::NoInput | ParserResult::MatchedLine(_) | ParserResult::FailedLine(_)\r\n// ) {\r\n//     result = parser.step();\r\n// }\r\n// //print!(\"{:?},\", result);\r\n// print!(\r\n//     \"{}\",\r\n//     linq_like_writer::write(\u0026parser.exprs, \u0026parser.stat_starts)\r\n// );\r\n// std::io::stdout().flush().unwrap();\r\n\r\n// println!(\r\n//     \"name of eq: {}\",\r\n//     format!(\"{:#?}\",(\u0026commands::Expr::Eq {\r\n//         locs: vec![0, 1],\r\n//         name_start: 7,\r\n//         name: \"inch\".as_bytes().to_vec(),\r\n//         value_index: 1\r\n//     }))\r\n// );\r\n//let mut buf= Vec::new();\r\n//testing::test_ast1();\r\n// let mut input =io::stdin().lock();\r\n//let stats = parser_state::parse(\u0026mut input);\r\n//println!(\"{}\",processing_writer::write(\u0026stats))\r\n//let s:String = Default::default();\r\n\r\n//parser.vars.insert(\"inch\".as_bytes().to_vec());\r\n//crate::testing::add_vars!(parser, \"inch\", \"miles\", \"furlongs\", \"longer\");\r\n//let mut result = parser.step();\r\n\r\n// loop {\r\n//     match parser.step() {\r\n//         ParserResult::MatchedLine =\u003e print(\u0026parser),\r\n//         ParserResult::FailedLine =\u003e println!(\"   parse failed\"),\r\n//         ParserResult::NoInput =\u003e break,\r\n//         _ =\u003e {}\r\n//     }\r\n// }\r\n\r\n// loop {\r\n//     match parser.step() {\r\n//         ParserResult::NoInput =\u003e break,\r\n//         state =\u003e println!(\r\n//             \"assert_step!(parser, {:?}, \\\"{}\\\", \\\"{}\\\");\",\r\n//             state,\r\n//             parser.get_state(),\r\n//             std::str::from_utf8(parser.get_word()).unwrap()\r\n//         ),\r\n//     }\r\n// }\r\n\r\n// let data = parser.into_data();\r\n// let iter = data.source.get_iter();\r\n// println!(\r\n//     \"    text input:\\n\\\"{}\\\"\",\r\n//     std::str::from_utf8(iter.cloned().collect::\u003cVec\u003c_\u003e\u003e().as_slice()).unwrap()\r\n// );\r\n// let iter = data.source.get_iter();\r\n// //input.seek(SeekFrom::Start);\r\n// //println!();\r\n// //println!(\"== {:?}\", parser.exprs.vec);\r\n// println!(\r\n//     \"   whole program:\\n{}\",\r\n//     linq_like_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n// );\r\n// let mut lint = writers::syntax_lint::SyntaxLinter::\u003c\r\n//     writers::syntax_renderers::wind_renderer::WindowsRenderer,\r\n// \u003e::new();\r\n// lint.write(\u0026data.exprs, \u0026data.stat_starts, iter);\r\n// println!(\r\n//     \"   linted:\\n{}\",\r\n//     std::str::from_utf8(\u0026lint.into_string()).unwrap()\r\n// );\r\n// println!(\r\n//     \"   java program:\\n{}\",\r\n//     processing_writer::write(\u0026parser.exprs, \u0026parser.stat_starts)\r\n// );\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","alias.rs"],"content":"use super::*;\r\nuse alias_data::*;\r\n\r\n///the state of the matching state machine\r\n#[derive(Debug, PartialEq)]\r\nenum MatchState {\r\n    Var,\r\n    Num,\r\n    Color,\r\n    StringLit,\r\n    FunctionCallExpr,\r\n    FunctionCallStat,\r\n    FindAliases,\r\n}\r\n\r\n/// used for both NoneStat and NoneExpr\r\n/// finds next command\r\n#[derive(Debug)]\r\npub struct NoneState {\r\n    ///a reference to the static data of the aliases\r\n    data: \u0026'static StaticAliasData,\r\n    ///the progress of each alias\r\n    progress: Vec\u003cu8\u003e,\r\n    ///the already parsed locs (the locations of alias characters)\r\n    locs: Vec\u003cOption\u003cVec\u003cusize\u003e\u003e\u003e,\r\n    ///the offset into the word\r\n    offset: usize,\r\n    ///the number of currently matched aliases\r\n    matched: u16,\r\n    ///the next state of the state machine\r\n    next_match_state: MatchState,\r\n}\r\n\r\nimpl ParseState for NoneState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        let aliases = (self.data.aliases)(env.aliases);\r\n        debug_assert!(aliases.len() \u003c u16::MAX as usize);\r\n\r\n        // reset on new word\r\n        self.reset(aliases.len());\r\n\r\n        self.run_match_state(env, word, rest)\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if child_index.is_some() {\r\n            // child matched successfully\r\n            MatchResult::Matched(word.pos, false)\r\n        } else {\r\n            // child did not match - continue searching\r\n            self.run_match_state(env, word, rest)\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        self.data.state_name\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::None\r\n    }\r\n}\r\n\r\nimpl NoneState {\r\n    fn new(data: \u0026'static StaticAliasData) -\u003e Self {\r\n        Self {\r\n            data,\r\n            progress: Vec::new(),\r\n            locs: Vec::new(),\r\n            offset: 0,\r\n            matched: 0,\r\n            next_match_state: MatchState::FindAliases,\r\n        }\r\n    }\r\n    ///reset state back to defaults for a new word\r\n    fn reset(\u0026mut self, length: usize) {\r\n        self.progress = vec![0u8; length];\r\n        self.locs = vec![Some(Vec::new()); length];\r\n        self.offset = 0;\r\n        self.matched = 0;\r\n        // if expr need to check if var or num\r\n        self.next_match_state = if self.data.is_expr {\r\n            //Expression\r\n            MatchState::StringLit\r\n        } else {\r\n            //Statement\r\n            MatchState::FunctionCallStat\r\n        }\r\n    }\r\n    pub fn new_stat() -\u003e Self {\r\n        Self::new(\u0026AliasData::STAT)\r\n    }\r\n    pub fn new_stat_cont() -\u003e Self {\r\n        Self::new(\u0026AliasData::STAT_CONT)\r\n    }\r\n    pub fn new_expr() -\u003e Self {\r\n        Self::new(\u0026AliasData::EXPR)\r\n    }\r\n    pub fn new_expr_cont() -\u003e Self {\r\n        Self::new(\u0026AliasData::EXPR_CONT)\r\n    }\r\n}\r\n\r\nimpl NoneState {\r\n    ///matches based on MatchState\r\n    ///Expr starts at Var, to check if it is a varible, then it checks if it is a number,\r\n    ///then it tries to find aliases in the word\r\n    ///Stat starts at the aliases directly\r\n    fn run_match_state(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        let (new_state, ret) = match self.next_match_state {\r\n            MatchState::StringLit =\u003e (\r\n                MatchState::Var,\r\n                MatchResult::ContinueWith(word.pos, get_state!(string_lit::LitStrState::new()))\r\n            ),\r\n            // is word a varible\r\n            MatchState::Var =\u003e (\r\n                MatchState::FunctionCallExpr,\r\n                MatchResult::ContinueWith(word.pos, get_state!(var::VarState::new())),\r\n            ),\r\n            // is word a function\r\n            MatchState::FunctionCallExpr =\u003e (\r\n                MatchState::Num,\r\n                MatchResult::ContinueWith(word.pos, get_state!(call_func::FunctionCallState::new()))\r\n            ),\r\n            // is word a literal number\r\n            MatchState::Num =\u003e (\r\n                MatchState::Color,\r\n                MatchResult::ContinueWith(\r\n                    word.pos,\r\n                    get_state!(num_literal::LiteralNumState::new()),\r\n                ),\r\n            ),\r\n            // is word a color\r\n            MatchState::Color =\u003e (\r\n                MatchState::FindAliases,\r\n                MatchResult::ContinueWith(word.pos, get_state!(litcolor::LiteralColorState::new())),\r\n            ),\r\n            MatchState::FunctionCallStat =\u003e (\r\n                MatchState::FindAliases,\r\n                MatchResult::ContinueWith(word.pos, get_state!(call_func::FunctionCallState::new()))\r\n            ),\r\n            \r\n            // else check aliases\r\n            MatchState::FindAliases =\u003e (MatchState::FindAliases, self.match_alias(env, word, rest)),\r\n        };\r\n        self.next_match_state = new_state;\r\n        ret\r\n    }\r\n\r\n    ///matches buildin functions based on self.data\r\n    fn match_alias(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        let aliases = (self.data.aliases)(env.aliases);\r\n\r\n        // run until end of word\r\n        for offset in self.offset..word.len() {\r\n            self.match_letters(\u0026aliases, word, offset);\r\n\r\n            // try match\r\n            while self.matched != 0 {\r\n                self.matched -= 1;\r\n                return self.find_best_match(env, \u0026aliases, offset, rest.pos);\r\n            }\r\n        }\r\n\r\n        // if default continue\r\n        if self.data.default_continue {\r\n            MatchResult::Continue(0)\r\n        // else fail\r\n        } else {\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n    ///finds the bast match of the ones to have just matched\r\n    ///Done by:\r\n    ///1. Implicitly the first to match\r\n    ///2. least length between first and last letter\r\n    ///3. then on least total location value\r\n    fn find_best_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        aliases: \u0026AliasNames,\r\n        offset: usize,\r\n        rest: usize,\r\n    ) -\u003e MatchResult {\r\n        let mut min_size = usize::MAX;\r\n        let mut min_locations = usize::MAX;\r\n        let mut min_index = u16::MAX;\r\n        for j in 0..aliases.len() {\r\n            // has finished matching\r\n            if self.progress[j] == aliases[j].len() as u8 \u0026\u0026 self.locs[j].is_some() {\r\n                let matching_locs = self.locs[j].as_ref().unwrap();\r\n\r\n                let size = matching_locs.last().unwrap() - matching_locs[0];\r\n                let location_sum: usize = matching_locs.iter().sum();\r\n\r\n                // is best match\r\n                // match on least length between first and last letter\r\n                // then on least total location value\r\n                if size \u003c min_size || (size == min_size \u0026\u0026 location_sum \u003c min_locations) {\r\n                    min_index = j as u16;\r\n                    min_size = size;\r\n                    min_locations = location_sum;\r\n                }\r\n            }\r\n        }\r\n        self.offset = offset;\r\n        env.locs = self.locs[min_index as usize].take();\r\n        for index in env.locs.as_mut().unwrap() {\r\n            *index += env.global_index;\r\n        }\r\n        //set up stack\r\n        (self.data.func)(\r\n            aliases[min_index as usize],\r\n            rest,\r\n            // move locs out of state without copy\r\n        )\r\n    }\r\n\r\n    ///match current letter at offset to all aliases\r\n    fn match_letters(\u0026mut self, aliases: \u0026AliasNames, word: \u0026Slice\u003c'_\u003e, offset: usize) {\r\n        // does letter match any commands\r\n        for i in 0..aliases.len() {\r\n            // does letter match\r\n            if self.progress[i] \u003c aliases[i].len() as u8\r\n                \u0026\u0026 word.str[offset].to_ascii_lowercase() == aliases[i][self.progress[i] as usize]\r\n            {\r\n                self.progress[i] += 1;\r\n                // add locations to locations (locs)\r\n                self.locs[i].as_mut().unwrap().push(word.pos + offset);\r\n                if self.progress[i] == aliases[i].len() as u8 {\r\n                    self.matched += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":36,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567622}},{"line":40,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":42,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":45,"address":[],"length":0,"stats":{"Line":4827858800541171718}},{"line":52,"address":[],"length":0,"stats":{"Line":4827858800541171718}},{"line":54,"address":[],"length":0,"stats":{"Line":2954361355555045393}},{"line":57,"address":[],"length":0,"stats":{"Line":1873497444986126325}},{"line":61,"address":[],"length":0,"stats":{"Line":17582052945254416388}},{"line":62,"address":[],"length":0,"stats":{"Line":17582052945254416388}},{"line":65,"address":[],"length":0,"stats":{"Line":3602879701896396829}},{"line":66,"address":[],"length":0,"stats":{"Line":3602879701896396829}},{"line":71,"address":[],"length":0,"stats":{"Line":3170534137668829190}},{"line":74,"address":[],"length":0,"stats":{"Line":3170534137668829190}},{"line":75,"address":[],"length":0,"stats":{"Line":3170534137668829190}},{"line":82,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":83,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":84,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":85,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":86,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":88,"address":[],"length":0,"stats":{"Line":9439544818968559622}},{"line":90,"address":[],"length":0,"stats":{"Line":4539628424389459974}},{"line":93,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":96,"address":[],"length":0,"stats":{"Line":1297036692682702850}},{"line":97,"address":[],"length":0,"stats":{"Line":1297036692682702850}},{"line":99,"address":[],"length":0,"stats":{"Line":16789419410837209088}},{"line":100,"address":[],"length":0,"stats":{"Line":16789419410837209088}},{"line":102,"address":[],"length":0,"stats":{"Line":2882303761517117443}},{"line":103,"address":[],"length":0,"stats":{"Line":2882303761517117443}},{"line":105,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":106,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":115,"address":[],"length":0,"stats":{"Line":11313042263954685954}},{"line":121,"address":[],"length":0,"stats":{"Line":4179340454199820292}},{"line":122,"address":[],"length":0,"stats":{"Line":4539628424389459969}},{"line":123,"address":[],"length":0,"stats":{"Line":4539628424389459969}},{"line":124,"address":[],"length":0,"stats":{"Line":4539628424389459969}},{"line":127,"address":[],"length":0,"stats":{"Line":4251398048237748196}},{"line":128,"address":[],"length":0,"stats":{"Line":4251398048237748196}},{"line":129,"address":[],"length":0,"stats":{"Line":4251398048237748196}},{"line":132,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":133,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":134,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":137,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":138,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":139,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":140,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":141,"address":[],"length":0,"stats":{"Line":3242591731706757139}},{"line":145,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":146,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":147,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":149,"address":[],"length":0,"stats":{"Line":4899916394579099650}},{"line":150,"address":[],"length":0,"stats":{"Line":4899916394579099650}},{"line":151,"address":[],"length":0,"stats":{"Line":4899916394579099650}},{"line":155,"address":[],"length":0,"stats":{"Line":10304235947423694852}},{"line":162,"address":[],"length":0,"stats":{"Line":10304235947423694852}},{"line":163,"address":[],"length":0,"stats":{"Line":10304235947423694852}},{"line":166,"address":[],"length":0,"stats":{"Line":6269010681299730438}},{"line":167,"address":[],"length":0,"stats":{"Line":14411518807585587202}},{"line":170,"address":[],"length":0,"stats":{"Line":14411518807585587202}},{"line":171,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":172,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":177,"address":[],"length":0,"stats":{"Line":6485183463413514244}},{"line":178,"address":[],"length":0,"stats":{"Line":4467570830351532034}},{"line":181,"address":[],"length":0,"stats":{"Line":2017612633061982210}},{"line":189,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":196,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":197,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":198,"address":[],"length":0,"stats":{"Line":3819052484010180615}},{"line":199,"address":[],"length":0,"stats":{"Line":8358680908399640585}},{"line":201,"address":[],"length":0,"stats":{"Line":8646911284551352368}},{"line":202,"address":[],"length":0,"stats":{"Line":3819052484010180652}},{"line":204,"address":[],"length":0,"stats":{"Line":3819052484010180652}},{"line":205,"address":[],"length":0,"stats":{"Line":3819052484010180652}},{"line":210,"address":[],"length":0,"stats":{"Line":7638104968020361306}},{"line":211,"address":[],"length":0,"stats":{"Line":3819052484010180612}},{"line":212,"address":[],"length":0,"stats":{"Line":3819052484010180612}},{"line":213,"address":[],"length":0,"stats":{"Line":3819052484010180612}},{"line":217,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":218,"address":[],"length":0,"stats":{"Line":3819052484010180610}},{"line":219,"address":[],"length":0,"stats":{"Line":8286623314361712642}},{"line":220,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":224,"address":[],"length":0,"stats":{"Line":3819052484010180614}},{"line":225,"address":[],"length":0,"stats":{"Line":3819052484010180614}},{"line":231,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":233,"address":[],"length":0,"stats":{"Line":7854277750134145031}},{"line":235,"address":[],"length":0,"stats":{"Line":11889503016258109447}},{"line":236,"address":[],"length":0,"stats":{"Line":9871890383196127394}},{"line":238,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":240,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":241,"address":[],"length":0,"stats":{"Line":1080863910568919184}},{"line":242,"address":[],"length":0,"stats":{"Line":3819052484010180752}}],"covered":92,"coverable":92},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","alias_data.rs"],"content":"use std::collections::HashSet;\r\n\r\nuse super::*;\r\n\r\nconst BASE_EXPR_ALIASES: \u0026[\u0026'static [u8]] = \u0026[\r\n    b\"int\", b\"lit\", // number makers\r\n    b\"add\", b\"sub\", b\"tim\", b\"ide\", b\"mod\", b\"log\", b\"exp\", // number operators\r\n    b\"les\", b\"mor\", b\"als\", b\"oth\", b\"par\", b\"inv\", // boolean operators\r\n];\r\n\r\nconst LIST_EXPR_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"lis\", b\"fin\", b\"ind\", b\"cou\"];\r\nconst GRAPH_EXPR_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"col\"];\r\n\r\nconst BASE_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"was\", b\"pri\", b\"whe\", b\"whi\", b\"els\", b\"not\"];\r\n\r\nconst LIST_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"fre\", b\"del\", b\"app\", b\"rep\"];\r\nconst FUNC_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[b\"fun\", b\"ret\"];\r\nconst GRAPH_STAT_ALIASES: \u0026[\u0026'static [u8]] = \u0026[\r\n    b\"arc\", b\"rec\", //shapes\r\n    b\"mov\", b\"tur\", b\"lin\", b\"bez\", //turtle\r\n    b\"sto\", b\"fil\", b\"pen\", // shape modifiers\r\n];\r\n\r\n///match alias to expr\r\nfn get_expr_state(alias: \u0026'static [u8], index: usize) -\u003e MatchResult {\r\n    MatchResult::ContinueWith(\r\n        index,\r\n        match alias {\r\n            b\"add\" =\u003e get_state!(operator::OperatorState::new_add()),\r\n            b\"sub\" =\u003e get_state!(operator::OperatorState::new_sub()),\r\n            b\"tim\" =\u003e get_state!(operator::OperatorState::new_mult()),\r\n            b\"ide\" =\u003e get_state!(operator::OperatorState::new_div()),\r\n            b\"mod\" =\u003e get_state!(operator::OperatorState::new_mod()),\r\n            b\"log\" =\u003e get_state!(operator::OperatorState::new_log()),\r\n            b\"exp\" =\u003e get_state!(operator::OperatorState::new_exp()),\r\n            b\"les\" =\u003e get_state!(operator::OperatorState::new_less_than()),\r\n            b\"mor\" =\u003e get_state!(operator::OperatorState::new_greater_than()),\r\n            b\"als\" =\u003e get_state!(operator::OperatorState::new_and()),\r\n            b\"oth\" =\u003e get_state!(operator::OperatorState::new_or()),\r\n            b\"par\" =\u003e get_state!(operator::OperatorState::new_equals()),\r\n            b\"inv\" =\u003e get_state!(operator::OperatorState::new_not()),\r\n\r\n            b\"lit\" =\u003e get_state!(multi_lit_num::MultiLitNumState::new()),\r\n            b\"int\" =\u003e get_state!(word_num::WordNumState::new()),\r\n            b\"col\" =\u003e get_state!(color::ColorState::new()),\r\n            b\"lis\" =\u003e get_state!(list::ListState::new()),\r\n            b\"fin\" =\u003e get_state!(find::FindState::new()),\r\n            b\"ind\" =\u003e get_state!(index::IndexState::new()),\r\n            b\"cou\" =\u003e get_state!(len::LengthState::new()),\r\n            _ =\u003e unreachable!(\"Got unknown alias {}\", std::str::from_utf8(alias).unwrap()),\r\n        },\r\n    )\r\n}\r\n\r\n/// match alias to stat\r\nfn get_stat_state(alias: \u0026'static [u8], index: usize) -\u003e MatchResult {\r\n    MatchResult::ContinueWith(\r\n        index,\r\n        match alias {\r\n            b\"arc\" =\u003e get_state!(circle::CircleState::new()),\r\n            b\"lin\" =\u003e get_state!(line::LineState::new()),\r\n            b\"bez\" =\u003e get_state!(bezier::BezierState::new()),\r\n            b\"was\" =\u003e get_state!(assign::AssignState::new()),\r\n            b\"rec\" =\u003e get_state!(rect::RectState::new()),\r\n            b\"pri\" =\u003e get_state!(print::PrintState::new()),\r\n            b\"whe\" =\u003e get_state!(if_stat::IfState::new()),\r\n            b\"whi\" =\u003e get_state!(while_stat::WhileState::new()),\r\n            b\"els\" =\u003e get_state!(else_stat::ElseState::new()),\r\n            b\"sto\" =\u003e get_state!(stroke::StrokeState::new()),\r\n            b\"fil\" =\u003e get_state!(fill::FillState::new()),\r\n            b\"mov\" =\u003e get_state!(move_to::MoveToState::new()),\r\n            b\"pen\" =\u003e get_state!(line_width::LineWidthState::new()),\r\n            b\"tur\" =\u003e get_state!(rotate::RotateState::new()),\r\n            b\"fun\" =\u003e get_state!(function::FunctionState::new()),\r\n            b\"ret\" =\u003e get_state!(return_stat::ReturnState::new()),\r\n            b\"app\" =\u003e get_state!(append::AppendState::new()),\r\n            b\"del\" =\u003e get_state!(delete::DeleteState::new()),\r\n            b\"rep\" =\u003e get_state!(replace::ReplaceState::new()),\r\n            b\"fre\" =\u003e get_state!(foreach::ForEachState::new()),\r\n            b\"not\" =\u003e get_state!(not::NotState::new()),\r\n            _ =\u003e unreachable!(\"Got unknown alias {}\", std::str::from_utf8(alias).unwrap()),\r\n        },\r\n    )\r\n}\r\n///A vector of alias strings\r\npub type AliasNames = Vec\u003c\u0026'static [u8]\u003e;\r\n///function to get alias strings from AliasData\r\ntype AliasSelector = fn(\u0026AliasData) -\u003e \u0026AliasNames;\r\n///fn to get the continueWith state with the corresponding string\r\ntype AliasToState = fn(alias: \u0026'static [u8], index: usize) -\u003e MatchResult;\r\n///static alias\r\n#[derive(Debug)]\r\npub struct StaticAliasData {\r\n    ///function to get alias strings from AliasData\r\n    pub aliases: AliasSelector,\r\n    ///function to get the matching continueWith state\r\n    pub func: AliasToState,\r\n    ///is this a expr alias data\r\n    pub is_expr: bool,\r\n    ///should this continue on failure of a word\r\n    pub default_continue: bool,\r\n    ///the name of the corresponding state\r\n    pub state_name: \u0026'static str,\r\n}\r\n\r\n///holds lists of all alias strings\r\n#[derive(Debug)]\r\npub struct AliasData {\r\n    pub expr: AliasNames,\r\n    pub stat: AliasNames,\r\n}\r\n\r\n///static alias data\r\nimpl AliasData {\r\n    pub const EXPR: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.expr,\r\n        func: get_expr_state,\r\n        is_expr: true,\r\n        default_continue: false,\r\n        state_name: \"NoneExpr\",\r\n    };\r\n    pub const EXPR_CONT: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.expr,\r\n        func: get_expr_state,\r\n        is_expr: true,\r\n        default_continue: true,\r\n        state_name: \"NoneExprCont\",\r\n    };\r\n\r\n    pub const STAT: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.stat,\r\n        func: get_stat_state,\r\n        is_expr: false,\r\n        default_continue: false,\r\n        state_name: \"NoneStat\",\r\n    };\r\n    pub const STAT_CONT: StaticAliasData = StaticAliasData {\r\n        aliases: |data| \u0026data.stat,\r\n        func: get_stat_state,\r\n        is_expr: false,\r\n        default_continue: true,\r\n        state_name: \"NoneStatCont\",\r\n    };\r\n}\r\n\r\nimpl AliasData {\r\n    pub fn new(imports: \u0026mut dyn Iterator\u003cItem = \u0026Import\u003e) -\u003e Self {\r\n        let mut added = HashSet::new();\r\n        let mut expr_vec = Vec::from(BASE_EXPR_ALIASES);\r\n        let mut stat_vec = Vec::from(BASE_STAT_ALIASES);\r\n\r\n        for import in imports {\r\n            if !added.contains(import) {\r\n                added.insert(*import);\r\n                let (exprs_aliases, stat_aliases) = Self::get_aliases(*import);\r\n                expr_vec.extend_from_slice(\u0026exprs_aliases);\r\n                stat_vec.extend_from_slice(\u0026stat_aliases);\r\n            }\r\n        }\r\n\r\n        Self {\r\n            expr: expr_vec,\r\n            stat: stat_vec,\r\n        }\r\n    }\r\n\r\n    pub fn all() -\u003e Self {\r\n        Self::new(\u0026mut Import::get_all().into_iter().map(|e| \u0026e.0))\r\n    }\r\n\r\n    pub fn none() -\u003e Self {\r\n        Self::new(\u0026mut std::iter::empty())\r\n    }\r\n\r\n    fn get_aliases(import: Import) -\u003e (\u0026'static [\u0026'static [u8]], \u0026'static [\u0026'static [u8]]) {\r\n        match import {\r\n            Import::List =\u003e (LIST_EXPR_ALIASES, LIST_STAT_ALIASES),\r\n            Import::Func =\u003e (\u0026[], FUNC_STAT_ALIASES),\r\n            Import::Graph =\u003e (\u0026GRAPH_EXPR_ALIASES, GRAPH_STAT_ALIASES),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":1873497444986126642}},{"line":27,"address":[],"length":0,"stats":{"Line":1873497444986126642}},{"line":28,"address":[],"length":0,"stats":{"Line":1873497444986126642}},{"line":29,"address":[],"length":0,"stats":{"Line":1873497444986126642}},{"line":30,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":306}},{"line":56,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":58,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":59,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":60,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":65,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":66,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":123,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":131,"address":[],"length":0,"stats":{"Line":2810246167479189506}},{"line":138,"address":[],"length":0,"stats":{"Line":7638104968020361216}},{"line":147,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":148,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":149,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":150,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":152,"address":[],"length":0,"stats":{"Line":1801439850948198397}},{"line":153,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":154,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":155,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":156,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":157,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":167,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":168,"address":[],"length":0,"stats":{"Line":6557241057451442186}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":176,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":177,"address":[],"length":0,"stats":{"Line":16068843470457929722}},{"line":178,"address":[],"length":0,"stats":{"Line":16068843470457929733}},{"line":179,"address":[],"length":0,"stats":{"Line":16068843470457929729}}],"covered":49,"coverable":72},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","append.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct AppendState {\r\n    count: u8,\r\n}\r\nimpl BasicState for AppendState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Append\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Append {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Append { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=1 =\u003e CloseType::Unable,\r\n            2 =\u003e CloseType::Able,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Append { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl AppendState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","assign.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct AssignState {\r\n    first: bool,\r\n}\r\nimpl ParseState for AssignState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // set expr\r\n        if self.first {\r\n            *env.expr = Expr::Assign {\r\n                var: SubStrData::new(),\r\n                value_index: usize::MAX,\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                end: End::none(),\r\n                first: false,\r\n            };\r\n            self.first = false;\r\n        }\r\n\r\n        // dont make closes varibles\r\n        let var_word = try_get_symbol_word(word, env.global_index);\r\n        if let Some(new_var) = var_word {\r\n            //set name\r\n            if let Expr::Assign { var, first, .. } = env.expr {\r\n                *first = !env.symbols.contains(\u0026new_var.name);\r\n                *var = new_var;\r\n            } else {\r\n                unreachable!()\r\n            }\r\n            // setup child state\r\n            MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        } else {\r\n            MatchResult::Continue(0)\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Some(index) = child_index {\r\n            // find ending close\r\n            let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n            match close {\r\n                // will never be a period to find even on future words\r\n                None =\u003e MatchResult::Failed,\r\n                Some(slice) =\u003e {\r\n                    if let Expr::Assign {\r\n                        var,\r\n                        value_index,\r\n                        end,\r\n                        ..\r\n                    } = env.expr\r\n                    {\r\n                        *value_index = index;\r\n                        *end = End::from_slice(\u0026slice.0, env.global_index);\r\n                        env.symbols.insert_var(var.name.to_owned());\r\n                    } else {\r\n                        unreachable!();\r\n                    }\r\n                    MatchResult::Matched(slice.0.pos, true)\r\n                }\r\n            }\r\n        } else {\r\n            // child expr failed\r\n            // if child match fail, I can never succeed\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Assign\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl AssignState {\r\n    pub fn new() -\u003e Self {\r\n        Self { first: true }\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":15564440312192434177}},{"line":47,"address":[],"length":0,"stats":{"Line":12538021362599460865}},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855880}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855873}},{"line":73,"address":[],"length":0,"stats":{"Line":144115188075855873}},{"line":77,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":78,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":81,"address":[],"length":0,"stats":{"Line":15564440312192434181}},{"line":82,"address":[],"length":0,"stats":{"Line":15564440312192434181}},{"line":87,"address":[],"length":0,"stats":{"Line":15564440312192434177}}],"covered":10,"coverable":10},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","basic_func.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse super::*;\r\n\r\n/// a super state that wants between n and m arguments and a close\r\npub trait BasicState {\r\n    /// Can this be used here. True by default\r\n    fn can_happen(\u0026self, _env: \u0026mut Environment) -\u003e bool {\r\n        true\r\n    }\r\n    /// get the name\r\n    fn get_name(\u0026self) -\u003e \u0026'static str;\r\n\r\n    /// set expr and return whether it is first\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool;\r\n\r\n    /// add children at index to self\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize);\r\n\r\n    /// can I be closed\r\n    fn can_close(\u0026self) -\u003e CloseType;\r\n\r\n    /// set end to index\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End);\r\n\r\n    fn get_type(\u0026self) -\u003e StateType;\r\n}\r\n\r\nimpl\u003cT: BasicState + Debug\u003e ParseState for T {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if !self.can_happen(env) {\r\n            MatchResult::Failed\r\n        } else {\r\n            let is_first = self.do_first(env.expr, env.locs.take().unwrap_or_default());\r\n            if is_first {\r\n                let can_close = self.can_close();\r\n                match can_close {\r\n                    CloseType::Able =\u003e {\r\n                        if is_mandatory_close(word) {\r\n                            self.set_end(env.expr, End::from_slice(\u0026word, env.global_index));\r\n                            MatchResult::Matched(word.pos, true)\r\n                            // succeeded - continue again with noncont expr\r\n                        } else {\r\n                            MatchResult::ContinueWith(\r\n                                word.pos,\r\n                                get_state!(alias::NoneState::new_expr_cont()),\r\n                            )\r\n                        }\r\n                    }\r\n                    CloseType::Force =\u003e {\r\n                        let close =\r\n                            find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                        match close {\r\n                            // will never be a period to find even on future words\r\n                            None =\u003e MatchResult::Failed,\r\n                            Some(slice) =\u003e {\r\n                                self.set_end(env.expr, End::from_slice(\u0026slice.0, env.global_index));\r\n                                MatchResult::Matched(slice.0.pos, true)\r\n                            }\r\n                        }\r\n                    }\r\n                    CloseType::Unable =\u003e {\r\n                        // cont - has required arguments\r\n                        MatchResult::ContinueWith(\r\n                            word.pos,\r\n                            get_state!(alias::NoneState::new_expr_cont()),\r\n                        )\r\n                    }\r\n                }\r\n            } else {\r\n                // not cont - may have more arguments but may not - need to find close if there\r\n                MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_expr()))\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Some(index) = child_index {\r\n            self.add_child(env.expr, index);\r\n        }\r\n\r\n        let can_close = self.can_close();\r\n\r\n        match can_close {\r\n            CloseType::Unable =\u003e {\r\n                if child_index.is_some() {\r\n                    // continue again\r\n                    MatchResult::ContinueWith(\r\n                        word.pos,\r\n                        get_state!(alias::NoneState::new_expr_cont()),\r\n                    )\r\n                } else {\r\n                    // exprcont failed on the entire rest of string - I will never match\r\n                    MatchResult::Failed\r\n                }\r\n            }\r\n            CloseType::Able =\u003e {\r\n                // I can close so I close\r\n                if is_mandatory_close(word) {\r\n                    self.set_end(env.expr, End::from_slice(\u0026word, env.global_index));\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont expr\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_expr()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n            CloseType::Force =\u003e {\r\n                // forced to close\r\n                let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                match close {\r\n                    // will never be a period to find even on future words\r\n                    None =\u003e MatchResult::Failed,\r\n                    Some(slice) =\u003e {\r\n                        self.set_end(env.expr, End::from_slice(\u0026slice.0, env.global_index));\r\n                        MatchResult::Matched(slice.0.pos, true)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \u003cSelf as BasicState\u003e::get_name(\u0026self)\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        \u003cSelf as BasicState\u003e::get_type(\u0026self)\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":1585267068834414932}},{"line":9,"address":[],"length":0,"stats":{"Line":1585267068834414932}},{"line":30,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":31,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":35,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":36,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":37,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":66,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":84,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":90,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":106,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":107,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":109,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":110,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":123,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":131,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":132,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":135,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":136,"address":[],"length":0,"stats":{"Line":1801439850948198400}}],"covered":34,"coverable":55},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","bezier.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct BezierState {\r\n    count: u8,\r\n}\r\nimpl BasicState for BezierState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Bezier\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Bezier {\r\n                locs,\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Bezier { indexes, .. } = expr {\r\n            indexes.push(index);\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        if self.count \u003c 4 {\r\n            return CloseType::Unable;\r\n        }\r\n        if self.count % 2 == 0 {\r\n            return CloseType::Able;\r\n        }\r\n        return CloseType::Unable;\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Bezier { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl BezierState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","call_func.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct FunctionCallState {\r\n    // is_first: bool,\r\n    count: u8,\r\n}\r\nimpl ParseState for FunctionCallState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // is varible in scope\r\n        if let Some(func) = env.symbols.try_get_func(\u0026word, env.global_index) {\r\n            // if func exists it should have function arguments\r\n            let arg_count = env.symbols.get_func_arg_count(\u0026func.name).unwrap();\r\n\r\n            // if args are 0 then find end\r\n            let end = if arg_count == 0 {\r\n                let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                match close {\r\n                    None =\u003e return MatchResult::Failed,\r\n                    Some(slice) =\u003e End::from_slice(\u0026slice.0, env.global_index),\r\n                }\r\n            } else {\r\n                End::none()\r\n            };\r\n\r\n            // set\r\n            *env.expr = Expr::FunctionCall {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                func,\r\n                indexes: Vec::new(),\r\n                end,\r\n            };\r\n\r\n            // match if args are 0\r\n            if arg_count == 0 {\r\n                MatchResult::Matched(end.index, true)\r\n            } else {\r\n                MatchResult::ContinueWith(rest.pos, get_state!(alias::NoneState::new_expr_cont()))\r\n            }\r\n        } else {\r\n            // did not find function\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::FunctionCall {\r\n            func, indexes, end, ..\r\n        } = env.expr\r\n        {\r\n            if let Some(index) = child_index {\r\n                indexes.push(index);\r\n                self.count += 1;\r\n            }\r\n            if let Some(arg_total) = env.symbols.get_func_arg_count(\u0026func.name) {\r\n                let can_close = self.count \u003e= arg_total;\r\n                if can_close {\r\n                    let close = find_close_slice(\u0026word, 0).or_else(|| find_close_slice(\u0026rest, 0));\r\n                    return match close {\r\n                        None =\u003e MatchResult::Failed,\r\n                        Some(slice) =\u003e {\r\n                            *end = End::from_slice(\u0026slice.0, env.global_index);\r\n                            MatchResult::Matched(slice.0.pos, true)\r\n                        }\r\n                    };\r\n                } else {\r\n                    if child_index.is_some() {\r\n                        MatchResult::ContinueWith(\r\n                            word.pos,\r\n                            get_state!(alias::NoneState::new_expr_cont()),\r\n                        )\r\n                    } else {\r\n                        MatchResult::Failed\r\n                    }\r\n                }\r\n            } else {\r\n                //varible should not have dissapeared from symbols\r\n                unreachable!()\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"FunctionCall\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl FunctionCallState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            // is_first: true,\r\n            count: 0,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":7421932185906577408}},{"line":11,"address":[],"length":0,"stats":{"Line":7998392938210000890}},{"line":16,"address":[],"length":0,"stats":{"Line":576460752303423482}},{"line":17,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":18,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711738}},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711750}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":42,"address":[],"length":0,"stats":{"Line":6845471433603153926}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":55,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":57,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":61,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":64,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":92,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":95,"address":[],"length":0,"stats":{"Line":8142508126285856780}},{"line":96,"address":[],"length":0,"stats":{"Line":8142508126285856780}},{"line":100,"address":[],"length":0,"stats":{"Line":8142508126285856774}}],"covered":29,"coverable":31},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","circle.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct CircleState {\r\n    count: u8,\r\n}\r\nimpl BasicState for CircleState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Circle\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Arc {\r\n                locs,\r\n                indexes: [usize::MAX; 4],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Arc { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1..=3 =\u003e CloseType::Able,\r\n            /*\r\n                1-argument: diameter of circle from current position\r\n                2-argument: width and height of ellipse from current position\r\n                3-argument: x and y coordinates then diameter of circle\r\n                4-argument: x and y coordinate then width and height of ellipse\r\n                Draw from the middle\r\n            */\r\n            4 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Arc { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl CircleState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1}},{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","color.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct ColorState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for ColorState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Color\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Color {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Color { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Color { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl ColorState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","delete.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct DeleteState {\r\n    count: u8,\r\n}\r\nimpl BasicState for DeleteState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Delete\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Delete {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Delete { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Delete { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl DeleteState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","else_stat.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct ElseState {\r\n    first: bool,\r\n    if_index: usize,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for ElseState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            //get some(index) if it is an \"if\"\r\n            let if_index = env.last_stat_index.and_then(|index| {\r\n                matches!(env.before.get(index), Some(Expr::If { .. })).then_some(index)\r\n            });\r\n\r\n            if let Some(index) = if_index {\r\n                if !env\r\n                    .parents\r\n                    .into_iter()\r\n                    .rev()\r\n                    .take_while(|state| state.expr_index \u003e index)\r\n                    .any(|state| state.state.get_type() == StateType::Stat)\r\n                {\r\n                    *env.expr = Expr::Else {\r\n                        locs: env.locs.take().unwrap_or_default(),\r\n                        indexes: Vec::new(),\r\n                        end: End::none(),\r\n                    };\r\n                    // go up layer\r\n                    env.symbols.add_layer();\r\n                    self.if_index = index;\r\n                }\r\n            }\r\n        }\r\n        // if \"if\" wasnt found\r\n        if self.if_index == usize::MAX {\r\n            MatchResult::Failed\r\n        // non cont stat for seeing closes\r\n        } else if self.has_stat {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n            // need a first stat - cont\r\n        } else {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        self.first = false;\r\n        if let Expr::If { else_index, .. } = \u0026mut env.before[self.if_index] {\r\n            if let Expr::Else { end, indexes, .. } = env.expr {\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if is_mandatory_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    *else_index = env.expr_index;\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            } else {\r\n                unreachable!()\r\n            }\r\n        } else {\r\n            // should be guarenteed that if_index points to if\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Else\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl ElseState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            if_index: usize::MAX,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":13,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":15,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":16,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":19,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":24,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":25,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":33,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":39,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":40,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":87,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":88,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":91,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":92,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":97,"address":[],"length":0,"stats":{"Line":792633534417207296}}],"covered":23,"coverable":23},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","fill.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct FillState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for FillState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Fill\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Fill {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Fill { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Fill { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl FillState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":21}},{"line":13,"address":[],"length":0,"stats":{"Line":21}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","find.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct FindState {\r\n    count: u8,\r\n}\r\nimpl BasicState for FindState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Find\"\r\n    }\r\n    \r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Find {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Find {indexes, ..} = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count+=1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=1 =\u003e CloseType::Unable,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!()\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Find {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl FindState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","foreach.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct ForEachState {\r\n    first: bool,\r\n    has_list: bool,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for ForEachState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            *env.expr = Expr::ForEach {\r\n                var: SubStrData::new(),\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            self.first = false;\r\n            // setup child state\r\n            // MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        }\r\n        let var_word = try_get_symbol_word(word, env.global_index);\r\n        if let Some(new_var) = var_word {\r\n            if !self.has_list {\r\n                if let Expr::ForEach { var, .. } = env.expr {\r\n                    *var = new_var;\r\n                    env.symbols.add_layer();\r\n                    env.symbols.insert_var(var.name.to_owned());\r\n                } else {\r\n                    unreachable!()\r\n                }\r\n                MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n            } else if self.has_stat {\r\n                MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n            } else {\r\n                MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n            }\r\n        } else {\r\n            MatchResult::Continue(0)\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::ForEach { indexes, end, .. } = env.expr {\r\n            if !self.has_list {\r\n                //add child and find stats\r\n                if let Some(index) = child_index {\r\n                    self.has_list = true;\r\n                    indexes.push(index);\r\n                    MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n                } else {\r\n                    // if child match fail, I can never succeed\r\n                    MatchResult::Failed\r\n                }\r\n            } else {\r\n                //and stat child\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if self.has_stat \u0026\u0026 is_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"While\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl ForEachState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            has_list: false,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":87,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":96,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":5,"coverable":5},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","function.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct FunctionState {\r\n    first: bool,\r\n    has_name: bool,\r\n    is_parsing_body: bool,\r\n    has_stat: bool,\r\n    args_count: u8,\r\n}\r\nimpl ParseState for FunctionState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            *env.expr = Expr::Function {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                func: SubStrData::new(),\r\n                args: Vec::new(),\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            self.first = false;\r\n        }\r\n\r\n        // reached the end of the string\r\n        if word.len() == 0 {\r\n            env.symbols.remove_layer();\r\n            MatchResult::Failed\r\n        } else if let Expr::Function { func, args, .. } = env.expr {\r\n            // if parsing stats in body\r\n            if self.is_parsing_body {\r\n                MatchResult::ContinueWith(rest.pos, Box::new(alias::NoneState::new_stat()))\r\n            // if doesn't yet have name\r\n            } else if !self.has_name {\r\n                if let Some(func_data) = try_get_symbol_word(word, env.global_index) {\r\n                    *func = func_data;\r\n                    //put func into new layer\r\n                    env.symbols.add_layer();\r\n                    env.symbols.insert_func(func.name.to_owned(), 0);\r\n                    self.has_name = true;\r\n                }\r\n                MatchResult::Continue(0)\r\n            //if doesn't yet have arg\r\n            } else {\r\n                if is_mandatory_close(word) {\r\n                    self.is_parsing_body = true;\r\n                    env.symbols\r\n                        .insert_func(func.name.to_owned(), self.args_count);\r\n                    return MatchResult::ContinueWith(\r\n                        rest.pos,\r\n                        Box::new(alias::NoneState::new_stat_cont()),\r\n                    );\r\n                    // if word can be a varible\r\n                } else if let Some(arg_data) = try_get_symbol_word(word, env.global_index) {\r\n                    // funtion can only have 255 arguments\r\n                    if self.args_count != 255 \u0026\u0026 !env.symbols.contains(\u0026arg_data.name) {\r\n                        env.symbols.insert_var(arg_data.name.to_owned());\r\n                        args.push(arg_data);\r\n                        self.args_count += 1;\r\n                    }\r\n                    //let arg_name = word.str.to_ascii_lowercase();\r\n                    // arg_names.push(arg_name.to_owned());\r\n                    // env.vars.insert(arg_name.to_owned());\r\n                    //env.funcs.inc_arg_count(\u0026func.name);\r\n                }\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // reached the end of the string\r\n        if word.len() == 0 {\r\n            env.symbols.remove_layer();\r\n            MatchResult::Failed\r\n        } else if let Expr::Function {\r\n            func, indexes, end, ..\r\n        } = env.expr\r\n        {\r\n            //and stat child\r\n            if let Some(index) = child_index {\r\n                indexes.push(index);\r\n            }\r\n\r\n            // close if have close\r\n            if is_mandatory_close(word) {\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                env.symbols.remove_layer();\r\n                env.symbols\r\n                    .insert_func(func.name.to_owned(), self.args_count);\r\n                MatchResult::Matched(word.pos, true)\r\n                // succeeded - continue again with noncont stat\r\n            } else if child_index.is_some() {\r\n                MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat_cont()))\r\n                // failed - pass word\r\n            } else {\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Function\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl FunctionState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            has_name: false,\r\n            is_parsing_body: false,\r\n            has_stat: false,\r\n            args_count: 0,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":13,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":14,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":15,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":16,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":17,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":18,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":19,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":21,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":25,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":34,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":38,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":39,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":41,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":44,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":48,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":49,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":55,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":111,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":112,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":115,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":116,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":121,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":36,"coverable":39},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","if_stat.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct IfState {\r\n    has_condition: bool,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for IfState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if !self.has_condition {\r\n            *env.expr = Expr::If {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                else_index: usize::MAX,\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            env.symbols.add_layer();\r\n            // setup child state\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        } else if self.has_stat {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n        } else {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::If { indexes, end, .. } = env.expr {\r\n            if !self.has_condition {\r\n                //add child and find stats\r\n                if let Some(index) = child_index {\r\n                    self.has_condition = true;\r\n                    indexes.push(index);\r\n                    MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n                } else {\r\n                    // if child match fail, I can never succeed\r\n                    MatchResult::Failed\r\n                }\r\n            } else {\r\n                //and stat child\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if self.has_stat \u0026\u0026 is_mandatory_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"If\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl IfState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            has_condition: false,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":12,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":13,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":14,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":15,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":16,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":17,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":19,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":21,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":22,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":72,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":73,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":76,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":77,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":82,"address":[],"length":0,"stats":{"Line":648518346341351424}}],"covered":17,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","index.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct IndexState {\r\n    count: u8,\r\n}\r\nimpl BasicState for IndexState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Index\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Index {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Index {indexes, ..} = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count+=1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=1 =\u003e CloseType::Unable,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!()\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Index {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl IndexState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":11,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":16,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","len.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct LengthState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for LengthState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Length\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Length {\r\n                locs,\r\n                index: usize::MAX,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, idx: usize) {\r\n        if let Expr::Length { index, .. } = expr {\r\n            *index = idx;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Length { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl LengthState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","line.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct LineState {\r\n    count: u8,\r\n}\r\nimpl BasicState for LineState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Line\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Line {\r\n                locs,\r\n                indexes: [usize::MAX; 4],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Line { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Able,\r\n            3 =\u003e CloseType::Able,\r\n            4 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Line { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl LineState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":11,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":40,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":20,"coverable":20},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","line_width.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct LineWidthState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for LineWidthState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Line Width\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::LineWidth {\r\n                locs,\r\n                child_index: usize::MAX,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::LineWidth { child_index, .. } = expr {\r\n            *child_index = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::LineWidth { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl LineWidthState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","list.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct ListState {\r\n    count: u8,\r\n}\r\nimpl BasicState for ListState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"List\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::List {\r\n                locs,\r\n                indexes: Vec::new(),\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::List {indexes, ..} = expr {\r\n            indexes.push(index);\r\n            self.count += 1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        CloseType::Able\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::List {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl ListState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":11,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":40,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":15,"coverable":15},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","litcolor.rs"],"content":"use super::*;\r\nuse litcolor_data::{get_color_word, LitColorFoundResult};\r\n#[derive(Debug)]\r\n\r\npub struct LiteralColorState {\r\n    wsf: Vec\u003cu8\u003e,\r\n}\r\n\r\nimpl ParseState for LiteralColorState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        let value = get_color_word(\u0026self.wsf, word.str);\r\n        if self.wsf == b\"\" {\r\n            match value {\r\n                LitColorFoundResult::Found =\u003e {\r\n                    *env.expr = Expr::LitCol {\r\n                        str_start: word.pos + env.global_index,\r\n                        str_length: word.len(),\r\n                        value: word.str.to_owned(),\r\n                    };\r\n                    MatchResult::Matched(rest.pos, false)\r\n                }\r\n                LitColorFoundResult::CouldFind =\u003e {\r\n                    *env.expr = Expr::LitCol {\r\n                        str_start: word.pos + env.global_index,\r\n                        str_length: usize::MAX,\r\n                        value: Vec::new(),\r\n                    };\r\n                    self.wsf\r\n                        .append(\u0026mut word.str.to_owned().to_ascii_lowercase());\r\n                    MatchResult::Continue(0)\r\n                }\r\n                LitColorFoundResult::Failed =\u003e MatchResult::Failed,\r\n                LitColorFoundResult::FoundOnLast =\u003e {\r\n                    unreachable!();\r\n                }\r\n            }\r\n        } else {\r\n            match value {\r\n                //Finishes a color name\r\n                LitColorFoundResult::Found =\u003e {\r\n                    if let Expr::LitCol {\r\n                        str_start,\r\n                        str_length,\r\n                        value,\r\n                    } = env.expr\r\n                    {\r\n                        if let Some(len) =\r\n                            (word.pos + word.len() + env.global_index).checked_sub(*str_start)\r\n                        {\r\n                            *str_length = len;\r\n                            self.wsf\r\n                                .append(\u0026mut word.str.to_owned().to_ascii_lowercase());\r\n                            *value = self.wsf.to_owned();\r\n                        } else {\r\n                            panic!(\"Expression is ending before it started!\")\r\n                        }\r\n                    } else {\r\n                        unreachable!()\r\n                    }\r\n                    MatchResult::Matched(rest.pos, false)\r\n                }\r\n                //Last word could have had more color words after it but didn't.\r\n                LitColorFoundResult::FoundOnLast =\u003e {\r\n                    if let Expr::LitCol {\r\n                        str_start,\r\n                        str_length,\r\n                        value,\r\n                    } = env.expr\r\n                    {\r\n                        if let Some(len) = (word.pos + env.global_index).checked_sub(*str_start) {\r\n                            *str_length = len;\r\n                            *value = self.wsf.to_owned();\r\n                        } else {\r\n                            panic!(\"Expression is ending before it started!\")\r\n                        }\r\n                    } else {\r\n                        unreachable!()\r\n                    }\r\n                    MatchResult::Matched(word.pos, false)\r\n                }\r\n                //Beginning of a color name, keep searching\r\n                LitColorFoundResult::CouldFind =\u003e {\r\n                    self.wsf\r\n                        .append(\u0026mut word.str.to_owned().to_ascii_lowercase());\r\n                    MatchResult::Continue(0)\r\n                }\r\n                //Cannot be a color\r\n                LitColorFoundResult::Failed =\u003e MatchResult::Failed,\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"ColorLit\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl LiteralColorState {\r\n    pub fn new() -\u003e Self {\r\n        Self { wsf: Vec::new() }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2954361355555045377}},{"line":11,"address":[],"length":0,"stats":{"Line":2954361355555045377}},{"line":12,"address":[],"length":0,"stats":{"Line":2954361355555045377}},{"line":13,"address":[],"length":0,"stats":{"Line":17726168133330272259}},{"line":15,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":16,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":17,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":18,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":20,"address":[],"length":0,"stats":{"Line":12826251738751172609}},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":24,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":32,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":38,"address":[],"length":0,"stats":{"Line":3674937295934324734}},{"line":83,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":84,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":85,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":104,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":107,"address":[],"length":0,"stats":{"Line":17726168133330272259}},{"line":108,"address":[],"length":0,"stats":{"Line":17726168133330272259}},{"line":113,"address":[],"length":0,"stats":{"Line":17726168133330272257}},{"line":114,"address":[],"length":0,"stats":{"Line":17726168133330272257}}],"covered":27,"coverable":28},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","litcolor_data.rs"],"content":"pub enum LitColorFoundResult {\r\n    ///found a color\r\n    Found,\r\n    ///found color on last word\r\n    FoundOnLast,\r\n    ///may find complete color on next word\r\n    CouldFind,\r\n    ///failed to find color\r\n    Failed,\r\n}\r\n\r\n#[rustfmt::skip]\r\npub fn get_color_word(word_so_far: \u0026[u8], word: \u0026[u8]) -\u003e LitColorFoundResult {\r\n    let cleaned_word = \u0026*word.to_ascii_lowercase();\r\n    match \u0026*word_so_far {\r\n        b\"\" =\u003e match cleaned_word {\r\n            b\"black\" | b\"silver\" | b\"gray\" | b\"maroon\" | b\"red\" | b\"purple\" | b\"fuchsia\"\r\n            | b\"navy\" | b\"teal\"\r\n            | b\"aquamarine\" | b\"azure\" | b\"beige\" | b\"bisque\" | b\"brown\" | b\"chartreuse\" | b\"chocolate\"\r\n            | b\"coral\" | b\"crimson\" | b\"cornsilk\" | b\"cyan\" | b\"firebrick\" | b\"gainsboro\"\r\n            | b\"gold\" | b\"goldenrod\" | b\"grey\" | b\"honeydew\" | b\"indigo\" | b\"ivory\" | b\"khaki\" \r\n            | b\"lawngreen\" | b\"linen\" | b\"magenta\" | b\"moccasin\" | b\"orchid\"\r\n            | b\"aliceblue\" | b\"antiquewhite\" | b\"blanchedalmond\" | b\"blueviolet\" | b\"burlywood\"\r\n            | b\"cadetblue\" | b\"cornflowerblue\" | b\"darkblue\" | b\"darkcyan\" | b\"darkgoldenrod\" \r\n            | b\"darkgray\" | b\"darkgreen\" | b\"darkgrey\" | b\"darkkhaki\" | b\"darkmagenta\"\r\n            | b\"darkolivegreen\" | b\"darkorange\" | b\"darkorchid\" | b\"darkred\" | b\"darksalmon\"\r\n            | b\"darkseagreen\" | b\"darkslateblue\" | b\"darkslategray\" | b\"darkslategrey\" | b\"darkturquoise\"\r\n            | b\"darkviolet\" | b\"deeppink\" | b\"deepskyblue\" | b\"dimgray\" | b\"dimgrey\" | b\"dodgerblue\"\r\n            | b\"floralwhite\" | b\"forestgreen\" | b\"ghostwhite\" | b\"greenyellow\"\r\n            | b\"hotpink\" | b\"indianred\" | b\"lavenderblush\" | b\"lemonchiffon\"\r\n            | b\"lightblue\" | b\"lightcoral\" | b\"lightcyan\" | b\"lightgoldenrodyellow\" | b\"lightgray\"\r\n            | b\"lightgreen\" | b\"lightgrey\" | b\"lightpink\" | b\"lightsalmon\" | b\"lightseagreen\"\r\n            | b\"lightskyblue\" | b\"lightslategray\" | b\"lightslategrey\" | b\"lightsteelblue\" | b\"lightyellow\"\r\n            | b\"limegreen\" | b\"mediumaquamarine\" | b\"mediumblue\" | b\"mediumorchid\" | b\"mediumpurple\"\r\n            | b\"mediumseagreen\" | b\"mediumslateblue\" | b\"mediumspringgreen\" | b\"mediumturquoise\"\r\n            | b\"mediumvioletred\" | b\"midnightblue\" | b\"mintcream\" | b\"mistyrose\" | b\"navajowhite\"\r\n            | b\"oldlace\" | b\"olivedrab\" | b\"orangered\" | b\"palegoldenrod\" | b\"palegreen\" | b\"paleturquoise\"\r\n            | b\"palevioletred\" | b\"papayawhip\" | b\"peachpuff\" | b\"peru\" | b\"pink\" | b\"plum\" | b\"powderblue\"\r\n            | b\"rebeccapurple\" | b\"rosybrown\" | b\"royalblue\" | b\"saddlebrown\" | b\"salmon\"\r\n            | b\"sandybrown\" | b\"seagreen\" | b\"seashell\" | b\"sienna\" | b\"skyblue\" | b\"slateblue\"\r\n            | b\"slategray\" | b\"slategrey\" | b\"snow\" | b\"springgreen\" | b\"steelblue\" | b\"tan\"\r\n            | b\"thistle\" | b\"tomato\" | b\"transparent\" | b\"turquoise\" | b\"violet\" | b\"wheat\"\r\n            | b\"whitesmoke\" | b\"yellowgreen\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"alice\" | b\"antique\" | b\"blanched\" | b\"blue\" | b\"burly\" | b\"cadet\" | b\"cornflower\"\r\n            | b\"corn\" | b\"dark\" | b\"deep\" | b\"dim\" | b\"dodger\" | b\"fire\" | b\"floral\" | b\"forest\"\r\n            | b\"ghost\" | b\"golden\" | b\"green\" | b\"honey\" | b\"hot\" | b\"indian\" | b\"lavender\"\r\n            | b\"lawn\" | b\"lemon\" | b\"light\" | b\"lime\" | b\"medium\" | b\"midnight\" | b\"mint\"\r\n            | b\"misty\" | b\"navajo\" | b\"old\" | b\"olive\" | b\"orange\" | b\"pale\" | b\"papaya\"\r\n            | b\"peach\" | b\"powder\" | b\"rebecca\" | b\"rosy\" | b\"royal\" | b\"saddle\" | b\"sandy\"\r\n            | b\"sea\" | b\"sky\" | b\"slate\" | b\"spring\" | b\"steel\" | b\"white\" | b\"yellow\" | b\"aqua\"\r\n            | b\"darkgolden\" | b\"darkolive\" | b\"darksea\" | b\"darkslate\" | b\"deepsky\"\r\n            | b\"lightgolden\" | b\"lightgoldenrod\" | b\"lightsea\" | b\"lightsky\" | b\"lightslate\"\r\n            | b\"mediumaqua\" | b\"mediumsea\" | b\"mediumslate\" | b\"mediumspring\"\r\n            | b\"mediumviolet\" | b\"palegolden\" | b\"paleviolet\" | b\"lightsteel\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"alice\" =\u003e  match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"antique\" =\u003e  match cleaned_word {\r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"aqua\" =\u003e match cleaned_word {\r\n            b\"marine\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"blanched\" =\u003e  match cleaned_word {\r\n            b\"almond\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"blue\" =\u003e  match cleaned_word {\r\n            b\"violet\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"burly\" =\u003e  match cleaned_word {\r\n            b\"wood\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"cadet\" =\u003e  match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"cornflower\" =\u003e  match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"corn\" =\u003e match cleaned_word {\r\n            b\"flower\" =\u003e LitColorFoundResult::CouldFind,\r\n            b\"silk\" =\u003e LitColorFoundResult::Found,\r\n            b\"flowerblue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"dark\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"cyan\" | b\"goldenrod\" | b\"gray\" | b\"green\" | b\"grey\" | b\"khaki\"\r\n            | b\"magenta\" | b\"olivegreen\" | b\"orange\" | b\"orchid\" | b\"red\" | b\"salmon\"\r\n            | b\"seagreen\" | b\"slateblue\" | b\"slategray\" | b\"slategrey\" | b\"turquoise\"\r\n            | b\"violet\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"golden\" | b\"olive\" | b\"sea\" | b\"slate\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"deep\" =\u003e match cleaned_word {\r\n            b\"pink\" | b\"skyblue\" =\u003e LitColorFoundResult::Found,\r\n            b\"sky\" =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"dim\" =\u003e match cleaned_word {\r\n            b\"gray\" | b\"grey\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"dodger\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"fire\" =\u003e match cleaned_word {\r\n            b\"brick\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"floral\" =\u003e match cleaned_word {\r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"forest\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"ghost\" =\u003e match cleaned_word { \r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"golden\" =\u003e match cleaned_word {\r\n            b\"rod\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"green\" =\u003e  match cleaned_word {\r\n            b\"yellow\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"honey\" =\u003e match cleaned_word {\r\n            b\"dew\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"hot\" =\u003e match cleaned_word {\r\n            b\"pink\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"indian\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lavender\" =\u003e match cleaned_word {\r\n            b\"blush\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"lawn\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lemon\" =\u003e match cleaned_word {\r\n            b\"chiffon\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"light\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"coral\" | b\"cyan\" | b\"goldenrodyellow\" | b\"gray\" | b\"green\" | b\"grey\"\r\n            | b\"pink\" | b\"salmon\" | b\"seagreen\" | b\"skyblue\" | b\"slategray\" | b\"slategrey\"\r\n            | b\"steelblue\" | b\"yellow\" \r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"goldenrod\" | b\"golden\" | b\"sea\" | b\"sky\" | b\"slate\" | b\"steel\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"steel\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lime\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"medium\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"orchid\" | b\"purple\" | b\"seagreen\" | b\"slateblue\" | b\"springgreen\"\r\n            | b\"turquoise\" | b\"violetred\"  | b\"aquamarine\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"sea\" | b\"slate\" | b\"spring\" | b\"violet\" | b\"aqua\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"spring\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"midnight\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mint\" =\u003e match cleaned_word {\r\n            b\"cream\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"misty\" =\u003e match cleaned_word {\r\n            b\"rose\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"navajo\" =\u003e match cleaned_word {\r\n            b\"white\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"old\" =\u003e match cleaned_word {\r\n            b\"lace\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"olive\" =\u003e match cleaned_word {\r\n            b\"drab\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"orange\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"pale\" =\u003e match cleaned_word {\r\n            b\"goldenrod\" | b\"green\" | b\"turquoise\" | b\"violetred\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            b\"golden\" | b\"violet\"\r\n                =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"papaya\" =\u003e match cleaned_word {\r\n            b\"whip\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"peach\" =\u003e match cleaned_word {\r\n            b\"puff\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"powder\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"rebecca\" =\u003e match cleaned_word {\r\n            b\"purple\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darkgolden\" =\u003e match cleaned_word {\r\n            b\"rod\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darkolive\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darksea\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"darkslate\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"gray\" | b\"grey\" \r\n                =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        }\r\n        b\"deepsky\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightgolden\" =\u003e match cleaned_word {\r\n            b\"rodyellow\" =\u003e LitColorFoundResult::Found,\r\n            b\"rod\" =\u003e LitColorFoundResult::CouldFind,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightgoldenrod\" =\u003e match cleaned_word {\r\n            b\"yellow\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightsea\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightsky\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightslate\" =\u003e match cleaned_word {\r\n            b\"gray\" | b\"grey\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"lightsteel\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumsea\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumslate\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumspring\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumviolet\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"mediumaqua\" =\u003e match cleaned_word {\r\n            b\"marine\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        }\r\n        b\"palegolden\" =\u003e match cleaned_word {\r\n            b\"rod\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"paleviolet\" =\u003e match cleaned_word {\r\n            b\"red\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"rosy\" =\u003e match cleaned_word {\r\n            b\"brown\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"royal\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"saddle\" =\u003e match cleaned_word {\r\n            b\"brown\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"sandy\" =\u003e match cleaned_word {\r\n            b\"brown\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"sea\" =\u003e match cleaned_word {\r\n            b\"green\" | b\"shell\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"sky\" =\u003e match cleaned_word {\r\n            b\"blue\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"slate\" =\u003e match cleaned_word {\r\n            b\"blue\" | b\"gray\" | b\"grey\"\r\n                =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::Failed\r\n        },\r\n        b\"white\" =\u003e match cleaned_word {\r\n            b\"smoke\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        },\r\n        b\"yellow\" =\u003e match cleaned_word {\r\n            b\"green\" =\u003e LitColorFoundResult::Found,\r\n            _ =\u003e LitColorFoundResult::FoundOnLast\r\n        }\r\n        _ =\u003e LitColorFoundResult::Failed\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":14,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":15,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":16,"address":[],"length":0,"stats":{"Line":2233785415175766019}},{"line":17,"address":[],"length":0,"stats":{"Line":6557241057451442191}},{"line":19,"address":[],"length":0,"stats":{"Line":2810246167479189510}},{"line":20,"address":[],"length":0,"stats":{"Line":6773413839565225987}},{"line":23,"address":[],"length":0,"stats":{"Line":9655717601082343430}},{"line":24,"address":[],"length":0,"stats":{"Line":3891110078048108547}},{"line":25,"address":[],"length":0,"stats":{"Line":3170534137668829187}},{"line":31,"address":[],"length":0,"stats":{"Line":2089670227099910147}},{"line":34,"address":[],"length":0,"stats":{"Line":2017612633061982211}},{"line":35,"address":[],"length":0,"stats":{"Line":3674937295934324742}},{"line":44,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":57,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":59,"address":[],"length":0,"stats":{"Line":3819052484010180605}},{"line":60,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":16645304222761353212}},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":16212958658533785596}},{"line":68,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":10016005571271983100}},{"line":72,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":84,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":9079256848778919932}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":92,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":93,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":98,"address":[],"length":0,"stats":{"Line":7926335344172072960}},{"line":99,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":102,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":104,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":108,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":7421932185906577404}},{"line":113,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":6269010681299730428}},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":125,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":133,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":141,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":142,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":144,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":145,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":149,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":153,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":157,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":160,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":161,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":165,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":169,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":170,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":172,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":173,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":174,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":178,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":182,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":183,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":185,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":186,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":187,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":188,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":189,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":190,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":194,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":198,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":202,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":206,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":210,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":214,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":218,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":219,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":221,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":222,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":223,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":225,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":226,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":227,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":228,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":229,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":233,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":237,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":241,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":249,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":2666130979403333628}},{"line":253,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":257,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":261,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":262,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":266,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":1729382256910270460}},{"line":270,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":271,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":1152921504606846972}},{"line":275,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":279,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":283,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":287,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":291,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":295,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":299,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":648518346341351420}},{"line":303,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":307,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":311,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":315,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":319,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":323,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":327,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":331,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":335,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":339,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":340,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":344,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":348,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":349,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":353,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":354,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":356,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":357,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":358,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":360,"address":[],"length":0,"stats":{"Line":0}}],"covered":183,"coverable":246},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","move_to.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct MoveToState {\r\n    count: u8,\r\n}\r\nimpl BasicState for MoveToState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"MoveTo\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::MoveTo {\r\n                locs,\r\n                indexes: [usize::MAX; 2],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::MoveTo { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::MoveTo { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl MoveToState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","multi_lit_num.rs"],"content":"use super::*;\r\nuse num_literal::get_number;\r\n\r\n#[derive(Debug, PartialEq)]\r\npub enum VarOrInt {\r\n    Var(SubStrData),\r\n    Int(i64),\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct MultiLitNumState {\r\n    first: bool,\r\n    any_vars: bool,\r\n}\r\n\r\nimpl ParseState for MultiLitNumState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            let locs = env.locs.take().unwrap_or_default();\r\n            self.first = false;\r\n\r\n            let (end, single_value) = if is_mandatory_close(word) {\r\n                (End::from_slice(\u0026word, env.global_index), Some(0))\r\n            } else {\r\n                (End::none(), None)\r\n            };\r\n\r\n            *env.expr = Expr::MultiLitNum {\r\n                str_start: word.pos + env.global_index,\r\n                locs,\r\n                end,\r\n                single_value,\r\n                values: Vec::new(),\r\n            };\r\n\r\n            if single_value.is_some() {\r\n                return MatchResult::Matched(word.pos, true);\r\n            }\r\n        }\r\n        if let Expr::MultiLitNum {\r\n            values,\r\n            end,\r\n            single_value,\r\n            ..\r\n        } = env.expr\r\n        {\r\n            if is_mandatory_close(word) {\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                if !self.any_vars {\r\n                    *single_value = Self::get_final_value(values);\r\n                }\r\n\r\n                MatchResult::Matched(word.pos, true)\r\n            } else {\r\n                //let lower = word.str.to_ascii_lowercase();\r\n                if let Some(var) = env.symbols.try_get_var(word, env.global_index) {\r\n                    self.any_vars = true;\r\n                    values.push(VarOrInt::Var(var));\r\n                } else if let Some(num_value) = get_number(word.str) {\r\n                    values.push(VarOrInt::Int(num_value % 10));\r\n                } else {\r\n                    values.push(VarOrInt::Int((word.len() as i64) % 10));\r\n                }\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"MultiLitNum\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl MultiLitNumState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            first: true,\r\n            any_vars: false,\r\n        }\r\n    }\r\n    pub fn get_final_value(values: \u0026Vec\u003cVarOrInt\u003e) -\u003e Option\u003ci64\u003e {\r\n        let mut val = Some(0i64);\r\n        for i in values.into_iter() {\r\n            if let VarOrInt::Int(i_val) = *i {\r\n                if let Some(var) = val {\r\n                    val = var\r\n                        .checked_mul(10_i64)\r\n                        .and_then(|val| val.checked_add(i_val))\r\n                } else {\r\n                    //overflowed\r\n                    return None;\r\n                }\r\n            } else {\r\n                unreachable!()\r\n            }\r\n        }\r\n\r\n        val\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":3026418949592973313}},{"line":18,"address":[],"length":0,"stats":{"Line":3026418949592973313}},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":31,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":32,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":33,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":37,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":82,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":91,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":97,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":99,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":100,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":101,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":104,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":28,"coverable":28},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","not.rs"],"content":"use super::*;\r\n\r\n/// state for num\r\n#[derive(Debug)]\r\npub struct NotState;\r\nimpl ParseState for NotState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // wait for non . word to start\r\n        if is_close(word) {\r\n            MatchResult::Continue(0)\r\n        } else {\r\n            // find close\r\n            let close = find_close_slice(rest, 0);\r\n            //close exists - match\r\n            if let Some(close) = close {\r\n                *env.expr = Expr::Not {\r\n                    locs: env.locs.take().unwrap_or_default(),\r\n                    str_start: word.pos + env.global_index,\r\n                    str_len: word.len(),\r\n                    word:word.str.to_ascii_lowercase(),\r\n                    end: End::from_slice(\u0026close.0, env.global_index),\r\n                };\r\n                env.nots.insert(word.str.to_ascii_lowercase());\r\n                MatchResult::Matched(close.0.pos, true)\r\n            } else {\r\n                // did not find close - fail\r\n                MatchResult::Failed\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Num\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl NotState {\r\n    pub fn new() -\u003e Self {\r\n        Self\r\n    }\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","num_literal.rs"],"content":"use core::str;\r\n\r\nuse super::*;\r\n#[derive(Debug)]\r\n\r\npub struct LiteralNumState {}\r\n\r\nimpl ParseState for LiteralNumState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // try parse number\r\n        let value = get_number(word.str);\r\n\r\n        // if value exists - match\r\n        if let Some(value) = value {\r\n            *env.expr = Expr::LitNum {\r\n                str_start: word.pos + env.global_index,\r\n                str_length: word.len(),\r\n                value,\r\n            };\r\n            MatchResult::Matched(rest.pos, false)\r\n        } else {\r\n            // word is not a number\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"NumLit\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl LiteralNumState {\r\n    pub fn new() -\u003e Self {\r\n        Self {}\r\n    }\r\n}\r\n\r\npub fn get_number(word: \u0026[u8]) -\u003e Option\u003ci64\u003e {\r\n    get_number_word(word).or_else(|| get_number_literal(word))\r\n}\r\n\r\nfn get_number_literal(mut word: \u0026[u8]) -\u003e Option\u003ci64\u003e {\r\n    let mut neg = 1i64;\r\n    if word.starts_with(b\"-\") {\r\n        neg = -1;\r\n        word = \u0026word[1..]\r\n    }\r\n\r\n    let number = || String::from_utf8(word[2..].to_vec()).ok();\r\n    let num = {\r\n        if word.starts_with(b\"0x\") {\r\n            i64::from_str_radix(\u0026number()?, 16)\r\n        } else if word.starts_with(b\"0o\") {\r\n            i64::from_str_radix(\u0026number()?, 8)\r\n        } else if word.starts_with(b\"0b\") {\r\n            i64::from_str_radix(\u0026number()?, 2)\r\n        } else {\r\n            let number = String::from_utf8(word.to_vec()).ok()?;\r\n            i64::from_str_radix(\u0026number, 10)\r\n        }\r\n    };\r\n    num.ok().and_then(|num| Some(num * neg))\r\n}\r\n\r\nfn get_number_word(word: \u0026[u8]) -\u003e Option\u003ci64\u003e {\r\n    let first_binding = word.to_ascii_lowercase();\r\n    let temp_binding = String::from_utf8_lossy(\u0026*\u0026first_binding);\r\n    let split_match: Vec\u003c\u0026str\u003e = temp_binding.split(\"-\").collect();\r\n    let mut rev_values = Vec::new();\r\n    //TODO: Enforce that each number must be less than the last, and you can't do like eleven-one\r\n    for item in split_match {\r\n        let next_value: i64 = match item {\r\n            \"and\" =\u003e continue,\r\n            \"zero\" =\u003e 0,\r\n            \"one\" =\u003e 1,\r\n            \"two\" =\u003e 2,\r\n            \"three\" =\u003e 3,\r\n            \"four\" =\u003e 4,\r\n            \"five\" =\u003e 5,\r\n            \"six\" =\u003e 6,\r\n            \"seven\" =\u003e 7,\r\n            \"eight\" =\u003e 8,\r\n            \"nine\" =\u003e 9,\r\n            \"ten\" =\u003e 10,\r\n            \"eleven\" =\u003e 11,\r\n            \"dozen\" =\u003e 12,\r\n            \"twelve\" =\u003e 12,\r\n            \"thirteen\" =\u003e 13,\r\n            \"fourteen\" =\u003e 14,\r\n            \"fifteen\" =\u003e 15,\r\n            \"sixteen\" =\u003e 16,\r\n            \"seventeen\" =\u003e 17,\r\n            \"eighteen\" =\u003e 18,\r\n            \"nineteen\" =\u003e 19,\r\n            \"twenty\" =\u003e 20,\r\n            \"score\" =\u003e 20,\r\n            \"thirty\" =\u003e 30,\r\n            \"forty\" =\u003e 40,\r\n            \"fifty\" =\u003e 50,\r\n            \"sixty\" =\u003e 60,\r\n            \"seventy\" =\u003e 70,\r\n            \"eighty\" =\u003e 80,\r\n            \"ninety\" =\u003e 90,\r\n            \"hundred\" =\u003e 100,\r\n            \"thousand\" =\u003e 1000,\r\n            \"million\" =\u003e 1000000,\r\n            \"billion\" =\u003e 1000000000,\r\n            _ =\u003e return None,\r\n        };\r\n        rev_values.push(next_value);\r\n    }\r\n    if rev_values.len() == 0 {\r\n        return None;\r\n    }\r\n    get_number_word_from_list(\u0026rev_values, 0, rev_values.len())\r\n}\r\n\r\nfn get_number_word_from_list(values: \u0026Vec\u003ci64\u003e, min_index: usize, max_index: usize) -\u003e Option\u003ci64\u003e {\r\n    let mut max_val = min_index;\r\n    for i in min_index + 1..max_index {\r\n        if values[i] \u003e values[max_val] {\r\n            max_val = i;\r\n        }\r\n    }\r\n    if max_index - min_index \u003e 1 {\r\n        match values[max_val] {\r\n            20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100 | 1000 | 10000 | 100000 | 1000000\r\n            | 1000000000 =\u003e (),\r\n            _ =\u003e return None,\r\n        }\r\n    }\r\n    let left_side_val = if max_val == min_index {\r\n        1\r\n    } else {\r\n        match get_number_word_from_list(values, min_index, max_val) {\r\n            Some(value) =\u003e value,\r\n            _ =\u003e return None,\r\n        }\r\n    };\r\n    let right_side_val = if max_val == max_index - 1 {\r\n        0\r\n    } else {\r\n        match get_number_word_from_list(values, max_val + 1, max_index) {\r\n            Some(value) =\u003e value,\r\n            _ =\u003e return None,\r\n        }\r\n    };\r\n    Some(left_side_val * values[max_val] + right_side_val)\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":11,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":14,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":23,"address":[],"length":0,"stats":{"Line":17726168133330272258}},{"line":38,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":39,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":42,"address":[],"length":0,"stats":{"Line":3242591731706757124}},{"line":43,"address":[],"length":0,"stats":{"Line":3242591731706757124}},{"line":48,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":53,"address":[],"length":0,"stats":{"Line":5980780305148018690}},{"line":54,"address":[],"length":0,"stats":{"Line":14123288431433875460}},{"line":57,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":58,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":59,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927938}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927938}},{"line":64,"address":[],"length":0,"stats":{"Line":2161727821137838084}},{"line":65,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":66,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":2161727821137838082}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":74,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":80,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":81,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":82,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":83,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":84,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":86,"address":[],"length":0,"stats":{"Line":18158513697557839876}},{"line":87,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189639682}},{"line":89,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":90,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":91,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":92,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":93,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":94,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":95,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":96,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":97,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":98,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":99,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":100,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":101,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":102,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":103,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":104,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":105,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":106,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":107,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":108,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":109,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":110,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":111,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":112,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":113,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":114,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":115,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":116,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":117,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":118,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":119,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":120,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":121,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":122,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":123,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":127,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":130,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":133,"address":[],"length":0,"stats":{"Line":4683743612465315842}},{"line":134,"address":[],"length":0,"stats":{"Line":4683743612465315842}},{"line":135,"address":[],"length":0,"stats":{"Line":5980780305148018690}},{"line":136,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":137,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":140,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":141,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":143,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":147,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":148,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":150,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":151,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":156,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":158,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":159,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":160,"address":[],"length":0,"stats":{"Line":0}}],"covered":88,"coverable":92},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","operator.rs"],"content":"use basic_func::BasicState;\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug)]\r\npub struct OperatorState {\r\n    fn_type: OperatorType,\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for OperatorState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        match self.fn_type {\r\n            OperatorType::Add =\u003e \"Add\",\r\n            OperatorType::Mult =\u003e \"Mult\",\r\n            OperatorType::Sub =\u003e \"Sub\",\r\n            OperatorType::Div =\u003e \"Div\",\r\n            OperatorType::Mod =\u003e \"Mod\",\r\n            OperatorType::Exp =\u003e \"Exp\",\r\n            OperatorType::Log =\u003e \"Log\",\r\n            OperatorType::LessThan =\u003e \"LessThan\",\r\n            OperatorType::GreaterThan =\u003e \"GreaterThan\",\r\n            OperatorType::And =\u003e \"And\",\r\n            OperatorType::Or =\u003e \"Or\",\r\n            OperatorType::Equals =\u003e \"Equals\",\r\n            OperatorType::Not =\u003e \"Not\",\r\n        }\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Operator {\r\n                locs,\r\n                func_type: self.fn_type,\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Operator { indexes, .. } = expr {\r\n            indexes.push(index);\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    // this is a mess\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match (self.fn_type, self.count) {\r\n            (OperatorType::Add, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Sub, 1) =\u003e CloseType::Able,\r\n            (OperatorType::Sub, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Mult, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Div, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Mod, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Exp, 1) =\u003e CloseType::Able,\r\n            (OperatorType::Exp, 2) =\u003e CloseType::Force,\r\n            (OperatorType::Log, 1) =\u003e CloseType::Able,\r\n            (OperatorType::Log, 2) =\u003e CloseType::Force,\r\n            (OperatorType::LessThan, 2) =\u003e CloseType::Force,\r\n            (OperatorType::GreaterThan, 2) =\u003e CloseType::Force,\r\n            (OperatorType::And, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Or, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Equals, 2..) =\u003e CloseType::Able,\r\n            (OperatorType::Not, 1) =\u003e CloseType::Force,\r\n            _ =\u003e CloseType::Unable,\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Operator { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl OperatorState {\r\n    fn new(fn_type: OperatorType) -\u003e Self {\r\n        Self { fn_type, count: 0 }\r\n    }\r\n\r\n    pub fn new_add() -\u003e Self {\r\n        Self::new(OperatorType::Add)\r\n    }\r\n\r\n    pub fn new_sub() -\u003e Self {\r\n        Self::new(OperatorType::Sub)\r\n    }\r\n\r\n    pub fn new_mult() -\u003e Self {\r\n        Self::new(OperatorType::Mult)\r\n    }\r\n\r\n    pub fn new_div() -\u003e Self {\r\n        Self::new(OperatorType::Div)\r\n    }\r\n\r\n    pub fn new_mod() -\u003e Self {\r\n        Self::new(OperatorType::Mod)\r\n    }\r\n\r\n    pub fn new_exp() -\u003e Self {\r\n        Self::new(OperatorType::Exp)\r\n    }\r\n\r\n    pub fn new_log() -\u003e Self {\r\n        Self::new(OperatorType::Log)\r\n    }\r\n\r\n    pub fn new_less_than() -\u003e Self {\r\n        Self::new(OperatorType::LessThan)\r\n    }\r\n\r\n    pub fn new_greater_than() -\u003e Self {\r\n        Self::new(OperatorType::GreaterThan)\r\n    }\r\n\r\n    pub fn new_and() -\u003e Self {\r\n        Self::new(OperatorType::And)\r\n    }\r\n\r\n    pub fn new_or() -\u003e Self {\r\n        Self::new(OperatorType::Or)\r\n    }\r\n\r\n    pub fn new_equals() -\u003e Self {\r\n        Self::new(OperatorType::Equals)\r\n    }\r\n\r\n    pub fn new_not() -\u003e Self {\r\n        Self::new(OperatorType::Not)\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":13,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":31,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":34,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":35,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":36,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":37,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":38,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":39,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":40,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":41,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":44,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":57,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":58,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":89,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":98,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}}],"covered":24,"coverable":72},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","print.rs"],"content":"use alias::NoneState;\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct PrintState {\r\n    count: usize\r\n}\r\n\r\nimpl ParseState for PrintState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        let found_close = is_mandatory_close(word);\r\n\r\n        if self.count == 0 {\r\n            let mut end = End::none();\r\n\r\n            // \"pri .\" - useful for newline? - can change later\r\n            if found_close {\r\n                end = End::from_slice(\u0026word, env.global_index)\r\n            }\r\n\r\n            *env.expr = Expr::Print {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                indexes: Vec::new(),\r\n                single_word: None,\r\n                single_word_start: usize::MAX,\r\n                end,\r\n            };\r\n        }\r\n\r\n        if let Expr::Print { single_word, end, single_word_start, .. } = env.expr {\r\n            if found_close {\r\n                // set end\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                MatchResult::Matched(word.pos, true)\r\n            } else {\r\n                //get first word for \"pri hi.\"\r\n                if self.count == 0 {\r\n                   *single_word = Some(word.str.to_vec());\r\n                   *single_word_start = word.pos;\r\n                }\r\n                self.count += 1;\r\n                MatchResult::ContinueWith(word.pos, get_state!(NoneState::new_expr()))\r\n            }\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::Print { indexes, end, single_word, .. } = env.expr {\r\n            if let Some(index) = child_index {\r\n                indexes.push(index);\r\n                *single_word = None;\r\n            }else if self.count == 1 {\r\n                self.count+=1;\r\n                return MatchResult::Continue(0);\r\n            }else{\r\n                *single_word = None;\r\n            }\r\n            self.count+=1;\r\n            if is_mandatory_close(word){\r\n                *end = End::from_slice(\u0026word, env.global_index);\r\n                MatchResult::Matched(word.pos, true)\r\n            }else if child_index.is_some(){\r\n                MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_expr_cont()))\r\n            }else{\r\n                MatchResult::Continue(0)\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Print\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl PrintState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            count: 0\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":58,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":59,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":62,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":63,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":64,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":69,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":70,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":71,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":72,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":73,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":75,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":83,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":86,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":87,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":92,"address":[],"length":0,"stats":{"Line":2377900603251621888}}],"covered":19,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","rect.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct RectState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for RectState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Rect\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Rect {\r\n                locs,\r\n                indexes: [usize::MAX; 4],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Rect { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1..=3 =\u003e CloseType::Able,\r\n            /*\r\n                1-argument: width of square from current position\r\n                2-argument: width and height of rectangle from current position\r\n                3-argument: x and y coordinates then width of square\r\n                4-argument: x and y coordinate then width and height of rectangle\r\n                Draw from the middle\r\n            */\r\n            4 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Rect { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl RectState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":13,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":17,"coverable":18},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","replace.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\npub struct ReplaceState {\r\n    count: u8,\r\n}\r\nimpl BasicState for ReplaceState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Replace\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool { \r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Replace {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none()\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Replace {indexes, ..} = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count+=1;\r\n        }else{\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0..=2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!()\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Replace {end, ..} = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n}\r\n\r\nimpl ReplaceState {\r\n    pub fn new () -\u003e Self {\r\n        Self {count: 0}\r\n    }\r\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","return_stat.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct ReturnState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for ReturnState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Return\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn can_happen(\u0026self, env: \u0026mut Environment) -\u003e bool {\r\n        env.parents.into_iter().any(|state| {\r\n            matches!(\r\n                env.before.get(state.expr_index),\r\n                Some(Expr::Function { .. })\r\n            )\r\n        })\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Return {\r\n                locs,\r\n                index: None,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, idx: usize) {\r\n        if let Expr::Return { index, .. } = expr {\r\n            *index = Some(idx);\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Able,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Return { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl ReturnState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":13,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":21,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":23,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":21,"coverable":21},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","rotate.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct RotateState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for RotateState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Rotate\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Rotate {\r\n                locs,\r\n                index: usize::MAX,\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, idx: usize) {\r\n        if let Expr::Rotate { index, .. } = expr {\r\n            *index = idx;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Rotate { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl RotateState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","string_lit.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug, PartialEq)]\r\npub enum VarOrStr {\r\n    Var(SubStrData),\r\n    Str(Vec\u003cu8\u003e)\r\n}\r\n#[derive(Debug)]\r\npub struct LitStrState {first: bool, current_str_start: usize, current_str_end: usize}\r\n\r\nimpl ParseState for LitStrState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // let g = 0;\r\n        // black_box(\u0026g);\r\n        // println!(\"G{}\", g);\r\n        \r\n        if word.len() == 1 \u0026\u0026 word.str[0] == b'\"'{\r\n            if self.first {\r\n                self.first=false;\r\n                *env.expr = Expr::LitString {\r\n                    str_start: word.pos + env.global_index,\r\n                    str:Vec::new(),\r\n                    str_end: usize::MAX\r\n                };\r\n                self.current_str_start=word.pos + env.global_index + 1;\r\n                MatchResult::Continue(0)\r\n            } else {\r\n                if let Expr::LitString { str, str_end, .. } = env.expr{\r\n                    //Add current str\r\n                    self.current_str_end = word.pos + env.global_index;\r\n                    if self.current_str_end \u003e self.current_str_start {\r\n                        str.push(VarOrStr::Str(env.full_text[self.current_str_start..self.current_str_end].to_vec()));\r\n                    }\r\n                    *str_end = self.current_str_end;\r\n                    MatchResult::Matched(rest.pos, false)\r\n                }else{\r\n                    unreachable!()\r\n                }\r\n            }\r\n        } else {\r\n            if self.first {\r\n                MatchResult::Failed\r\n            } else {\r\n                if let Expr::LitString { str, .. } = env.expr{\r\n                    if let Some(var) = env.symbols.try_get_var(word, env.global_index){\r\n                        self.current_str_end = word.pos + env.global_index;\r\n                        if self.current_str_end \u003e self.current_str_start {\r\n                            str.push(VarOrStr::Str(env.full_text[self.current_str_start..self.current_str_end].to_vec()));\r\n                        }\r\n                        str.push(VarOrStr::Var(var));\r\n                        self.current_str_start = rest.pos;\r\n                    }\r\n                    MatchResult::Continue(0)\r\n                }else{\r\n                    unreachable!()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"StringLit\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\n\r\nimpl LitStrState {\r\n    pub fn new() -\u003e Self {\r\n        Self {first: true, current_str_start: usize::MAX, current_str_end: usize::MAX}\r\n    }\r\n}\r\n\r\n//pri hi. pri hello world. pri \"hello world\".\r\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":75,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":78,"address":[],"length":0,"stats":{"Line":4539628424389459972}},{"line":79,"address":[],"length":0,"stats":{"Line":4539628424389459972}},{"line":84,"address":[],"length":0,"stats":{"Line":4539628424389459970}}],"covered":5,"coverable":5},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","stroke.rs"],"content":"use super::*;\r\nuse crate::parser::CloseType;\r\nuse basic_func::BasicState;\r\n\r\n#[derive(Debug)]\r\n\r\npub struct StrokeState {\r\n    count: u8,\r\n}\r\n\r\nimpl BasicState for StrokeState {\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Stroke\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n\r\n    fn do_first(\u0026self, expr: \u0026mut Expr, locs: Vec\u003cusize\u003e) -\u003e bool {\r\n        let ret = self.count == 0;\r\n        if ret {\r\n            *expr = Expr::Stroke {\r\n                locs,\r\n                indexes: [usize::MAX; 3],\r\n                end: End::none(),\r\n            }\r\n        }\r\n        ret\r\n    }\r\n\r\n    fn add_child(\u0026mut self, expr: \u0026mut Expr, index: usize) {\r\n        if let Expr::Stroke { indexes, .. } = expr {\r\n            indexes[self.count as usize] = index;\r\n            self.count += 1;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn can_close(\u0026self) -\u003e CloseType {\r\n        match self.count {\r\n            0 =\u003e CloseType::Unable,\r\n            1 =\u003e CloseType::Able,\r\n            2 =\u003e CloseType::Unable,\r\n            3 =\u003e CloseType::Force,\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    fn set_end(\u0026mut self, expr: \u0026mut Expr, index: End) {\r\n        if let Expr::Stroke { end, .. } = expr {\r\n            *end = index;\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n}\r\n\r\nimpl StrokeState {\r\n    pub fn new() -\u003e Self {\r\n        Self { count: 0 }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","title.rs"],"content":"use bstr::ByteSlice;\r\n\r\nuse super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct TitleState {\r\n    parsing_names: bool,\r\n    is_author_closed: bool,\r\n    data: Title,\r\n}\r\nimpl ParseState for TitleState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.parsing_names {\r\n            // names cannot be more than 255\r\n            if word.len() \u003e 255 {\r\n                return MatchResult::Continue(0);\r\n            }\r\n            let separator = Self::is_separator(word.str);\r\n            // is name\r\n            if separator.close_count == 0 {\r\n                if self.is_author_closed {\r\n                    // first author already done\r\n                    if self.data.authors.len() \u003e= 1 {\r\n                        self.add_imports(word.str, word.pos);\r\n                    }\r\n                    self.data\r\n                        .authors\r\n                        .push((word.str.to_vec(), word.pos, word.str.len()));\r\n                } else {\r\n                    // will always exist\r\n                    let author = self.data.authors.last_mut().unwrap();\r\n                    author.0.push(b' ');\r\n                    author.0.extend_from_slice(\u0026word.str);\r\n                    author.2 = word.end() - author.1;\r\n                    // second author started\r\n                    if self.data.authors.len() \u003e= 2 {\r\n                        self.add_imports(word.str, word.pos);\r\n                    }\r\n                }\r\n                self.is_author_closed = false;\r\n                MatchResult::Continue(0)\r\n                // is name close\r\n            } else if separator.only_forced {\r\n                self.is_author_closed = true;\r\n                self.data.delim.push((word.pos, separator.close_length));\r\n\r\n                MatchResult::Continue(0)\r\n                // is total close\r\n            } else {\r\n                self.data.delim.push((word.pos, separator.close_length));\r\n                let title = mem::replace(\u0026mut self.data, Title::new());\r\n                *env.expr = Expr::Title { data: title };\r\n                MatchResult::Matched(word.pos, true)\r\n            }\r\n        } else if word.len() \u003e= 2 \u0026\u0026 word.str.to_ascii_lowercase() == b\"by\" {\r\n            self.data\r\n                .title\r\n                .extend_from_slice(\u0026env.full_text[..word.pos].trim());\r\n            self.data.by_start = word.pos;\r\n            self.parsing_names = true;\r\n\r\n            MatchResult::Continue(0)\r\n        } else {\r\n            let slice = find_newline(\u0026rest, 0);\r\n            if let Some(newline) = slice {\r\n                let offset = newline.pos - rest.pos;\r\n                MatchResult::Continue(offset)\r\n            // did not find another new line -- poem has ended -- will never match\r\n            } else {\r\n                MatchResult::Failed\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Title\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::None\r\n    }\r\n}\r\n\r\nimpl TitleState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            parsing_names: false,\r\n            is_author_closed: true,\r\n            data: Title::new(),\r\n        }\r\n    }\r\n\r\n    ///returns and optinal length of the close\r\n    fn is_separator(str: \u0026[u8]) -\u003e CloseData {\r\n        if str.len() \u003e= 3 \u0026\u0026 str == b\"and\" {\r\n            CloseData {\r\n                close_count: 1,\r\n                close_length: 3,\r\n                only_forced: true,\r\n            }\r\n        } else if str.len() \u003e= 1 \u0026\u0026 str == b\"\u0026\" {\r\n            CloseData {\r\n                close_count: 1,\r\n                close_length: 1,\r\n                only_forced: true,\r\n            }\r\n        } else {\r\n            get_close_data(str)\r\n        }\r\n    }\r\n    fn add_imports(\u0026mut self, name: \u0026[u8], index: usize) {\r\n        let lower_name = name.to_ascii_lowercase();\r\n        let imports = Import::get_all();\r\n        if let Some((offset, _, imp_index)) =\r\n            parser_structs::try_get_best_val(\u0026lower_name, \u0026mut imports.iter().map(|e| e.1), \u0026|_| {\r\n                true\r\n            })\r\n        {\r\n            self.data.imports.push((\r\n                imports[imp_index].0,\r\n                offset as usize + index,\r\n                imports[imp_index].1.len() as u8,\r\n            ))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","var.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct VarState;\r\nimpl ParseState for VarState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        // is varible in scope\r\n        if let Some(var) = env.symbols.try_get_var(\u0026word, env.global_index) {\r\n            *env.expr = Expr::Var { var };\r\n            MatchResult::Matched(rest.pos, false)\r\n        } else {\r\n            // future words could be varible names\r\n            MatchResult::Failed\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"Var\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl VarState {\r\n    pub fn new() -\u003e Self {\r\n        Self\r\n    }\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":4251398048237748226}},{"line":8,"address":[],"length":0,"stats":{"Line":5260204364768739330}},{"line":13,"address":[],"length":0,"stats":{"Line":3242591731706757122}},{"line":28,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":29,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":32,"address":[],"length":0,"stats":{"Line":4251398048237748228}},{"line":33,"address":[],"length":0,"stats":{"Line":4251398048237748228}},{"line":37,"address":[],"length":0,"stats":{"Line":4251398048237748226}},{"line":38,"address":[],"length":0,"stats":{"Line":4251398048237748226}}],"covered":9,"coverable":9},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","while_stat.rs"],"content":"use super::*;\r\n/// state for equals\r\n#[derive(Debug)]\r\npub struct WhileState {\r\n    has_condition: bool,\r\n    has_stat: bool,\r\n}\r\nimpl ParseState for WhileState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, _rest: \u0026Slice) -\u003e MatchResult {\r\n        if !self.has_condition {\r\n            *env.expr = Expr::While {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                indexes: Vec::new(),\r\n                end: End::none(),\r\n            };\r\n            env.symbols.add_layer();\r\n            // setup child state\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_expr_cont()))\r\n        } else if self.has_stat {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat()))\r\n        } else {\r\n            MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child_index: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        if let Expr::While { indexes, end, .. } = env.expr {\r\n            if !self.has_condition {\r\n                //add child and find stats\r\n                if let Some(index) = child_index {\r\n                    self.has_condition = true;\r\n                    indexes.push(index);\r\n                    MatchResult::ContinueWith(word.pos, Box::new(alias::NoneState::new_stat_cont()))\r\n                } else {\r\n                    // if child match fail, I can never succeed\r\n                    MatchResult::Failed\r\n                }\r\n            } else {\r\n                //and stat child\r\n                if let Some(index) = child_index {\r\n                    self.has_stat = true;\r\n                    indexes.push(index);\r\n                }\r\n\r\n                // close if have close\r\n                if self.has_stat \u0026\u0026 is_mandatory_close(word) {\r\n                    *end = End::from_slice(\u0026word, env.global_index);\r\n                    env.symbols.remove_layer();\r\n                    MatchResult::Matched(word.pos, true)\r\n                    // succeeded - continue again with noncont stat\r\n                } else if child_index.is_some() {\r\n                    MatchResult::ContinueWith(word.pos, get_state!(alias::NoneState::new_stat()))\r\n                    // failed - pass word\r\n                } else {\r\n                    MatchResult::Continue(0)\r\n                }\r\n            }\r\n        } else {\r\n            unreachable!()\r\n        }\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"While\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Stat\r\n    }\r\n}\r\n\r\nimpl WhileState {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            has_condition: false,\r\n            has_stat: false,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":10,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":11,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":12,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":16,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":18,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":70,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":73,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":74,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":13,"coverable":16},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser","word_num.rs"],"content":"use std::usize;\r\n\r\nuse super::*;\r\n\r\n/// state for num\r\n#[derive(Debug)]\r\npub struct WordNumState {\r\n    first: bool,\r\n}\r\nimpl ParseState for WordNumState {\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult {\r\n        if self.first {\r\n            *env.expr = Expr::WordNum {\r\n                locs: env.locs.take().unwrap_or_default(),\r\n                str_start: usize::MAX,\r\n                str_len: 0,\r\n                end: End::none(),\r\n            };\r\n            self.first = false;\r\n        }\r\n\r\n        // wait for non . word to start\r\n        if is_close(word) {\r\n            MatchResult::Continue(0)\r\n        } else {\r\n            // find close\r\n            let close = find_close_slice(rest, 0);\r\n            //close exists - match\r\n            if let Some(close) = close {\r\n                if let Expr::WordNum {\r\n                    str_start,\r\n                    str_len,\r\n                    end,\r\n                    ..\r\n                } = env.expr\r\n                {\r\n                    *str_start = word.pos + env.global_index;\r\n                    *str_len = word.len();\r\n                    *end = End::from_slice(\u0026close.0, env.global_index);\r\n                }\r\n\r\n                MatchResult::Matched(close.0.pos, true)\r\n            } else {\r\n                // did not find close - fail\r\n                MatchResult::Failed\r\n            }\r\n        }\r\n    }\r\n\r\n    fn step_match(\r\n        \u0026mut self,\r\n        _env: \u0026mut Environment,\r\n        _child_index: Option\u003cusize\u003e,\r\n        _word: \u0026Slice,\r\n        _rest: \u0026Slice,\r\n    ) -\u003e MatchResult {\r\n        // has no child to match - fn should never be called\r\n        unreachable!()\r\n    }\r\n\r\n    fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        \"WordNum\"\r\n    }\r\n\r\n    fn get_type(\u0026self) -\u003e StateType {\r\n        StateType::Expr\r\n    }\r\n}\r\nimpl WordNumState {\r\n    pub fn new() -\u003e Self {\r\n        Self { first: true }\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":12,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":13,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":16,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":23,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":62,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":24,"coverable":25},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser.rs"],"content":"#![allow(dead_code)]\r\n#[path = \"parser_source.rs\"]\r\npub(crate) mod parser_source;\r\nuse bstr::ByteSlice;\r\npub(crate) use parser_source::*;\r\n// other stucts\r\n#[path = \"parser_structs.rs\"]\r\npub(crate) mod parser_structs;\r\npub(crate) use parser_structs::*;\r\n\r\nmod alias;\r\npub(crate) mod alias_data;\r\nmod append;\r\nmod assign;\r\nmod basic_func;\r\nmod call_func;\r\nmod color;\r\nmod delete;\r\nmod else_stat;\r\nmod fill;\r\nmod find;\r\nmod foreach;\r\nmod function;\r\nmod if_stat;\r\nmod index;\r\nmod len;\r\nmod list;\r\nmod litcolor;\r\nmod litcolor_data;\r\nmod move_to;\r\nmod not;\r\nmod operator;\r\nmod replace;\r\npub(crate) mod string_lit;\r\nmod stroke;\r\nmod title;\r\nmod var;\r\nmod while_stat;\r\n\r\nmod bezier;\r\nmod circle;\r\nmod line;\r\nmod print;\r\nmod rect;\r\nmod return_stat;\r\nmod rotate;\r\n\r\nmod line_width;\r\npub(crate) mod multi_lit_num;\r\nmod num_literal;\r\nmod word_num;\r\n\r\n#[path = \"testing/mod.rs\"]\r\nmod testing;\r\n\r\nuse crate::commands::*;\r\nuse rangemap::RangeSet;\r\nuse std::{collections::HashMap, fmt::Debug, mem};\r\n\r\nuse alias_data::AliasData;\r\n\r\n#[derive(Debug, PartialEq, Clone, Copy, Hash, Eq)]\r\npub enum Import {\r\n    List,\r\n    Func,\r\n    Graph,\r\n}\r\n\r\nimpl Import {\r\n    pub fn get_name(\u0026self) -\u003e \u0026'static str {\r\n        match self {\r\n            Import::List =\u003e \"List\",\r\n            Import::Func =\u003e \"Func\",\r\n            Import::Graph =\u003e \"Graph\",\r\n        }\r\n    }\r\n    pub fn get_all() -\u003e \u0026'static [(Import, \u0026'static [u8])] {\r\n        \u0026[\r\n            (Import::List, b\"list\"),\r\n            (Import::Func, b\"func\"),\r\n            (Import::Graph, b\"graph\"),\r\n        ]\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Title {\r\n    pub title: Vec\u003cu8\u003e,\r\n    // the imports: (name, position, length)\r\n    pub authors: Vec\u003c(Vec\u003cu8\u003e, usize, usize)\u003e,\r\n    // the imports: (type, position, length)\r\n    pub imports: Vec\u003c(Import, usize, u8)\u003e,\r\n    // the sepatators: (position, length)\r\n    pub delim: Vec\u003c(usize, u8)\u003e,\r\n    // the start of \"by\"\r\n    pub by_start: usize,\r\n}\r\nimpl Title {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            title: Vec::new(),\r\n            authors: Vec::new(),\r\n            imports: Vec::new(),\r\n            delim: Vec::new(),\r\n            by_start: usize::MAX,\r\n        }\r\n    }\r\n}\r\n// impl Title{\r\n//     pub fn empty()-\u003eSelf{\r\n//         Self {\r\n//             title: b\"No Title\".to_vec(),\r\n//             authors: vec![(b\"No Author\".to_vec()],\r\n//             imports: Vec::new(),\r\n//             delim: Vec::new(),\r\n//         }\r\n//     }\r\n// }\r\n///The data that is currently parsed\r\n#[derive(Debug)]\r\npub struct ParsedData\u003c'a\u003e {\r\n    ///the array of parsed exprs\r\n    pub exprs: ExprArena,\r\n    ///the start indexes of statements\r\n    pub stat_starts: Vec\u003cusize\u003e,\r\n    ///the set of current varibles\r\n    pub symbols: SymbolSet,\r\n    /// the ignored values\r\n    pub nots: IgnoreSet,\r\n    ///the parserSource that is used\r\n    pub source: ParserSource\u003c'a\u003e,\r\n    // ///the title and authors\r\n    // pub title: Option\u003cTitle\u003e,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Parser\u003c'a\u003e {\r\n    ///the currently parsed data\r\n    pub data: ParsedData\u003c'a\u003e,\r\n    ///the stack of states\r\n    stack: Vec\u003cState\u003e,\r\n    ///the last state that was dropped (if the last step Matched or Failed)\r\n    last_state: Option\u003cState\u003e,\r\n    ///is the parser currently paring or line or did last step end (see ParserResult::is_end)\r\n    parsing_line: bool,\r\n    ///the global position without respect to ParserSource buffers\r\n    pos: usize,\r\n    ///the last match result\r\n    last_result: LastMatchResult,\r\n    ///the static alias data\r\n    aliases: AliasData,\r\n    ///the number of times the current slice should repeat\r\n    repeat_count: u8,\r\n    /// the index of the last matched state\r\n    stat_indexes: Vec\u003cusize\u003e,\r\n    /// the hash map of ranges of failed exprs\r\n    cached_fails: HashMap\u003c\u0026'static str, RangeSet\u003cusize\u003e\u003e,\r\n    ///does the parser need to parse a title\r\n    parse_title: bool,\r\n}\r\n\r\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\r\n    ///make a new parser with a source and command flags\r\n    pub fn new(source: ParserSource\u003c'a\u003e, flags: ParserFlags) -\u003e Self {\r\n        // let title = (!flags.title).then(|| Title {\r\n        //     title: b\"No Title\".to_vec(),\r\n        //     author: vec![b\"No Author\".to_vec()],\r\n        //     imports:\r\n        // });\r\n        let aliases = if flags.title {\r\n            AliasData::none()\r\n        } else {\r\n            AliasData::all()\r\n        };\r\n\r\n        Parser {\r\n            data: ParsedData {\r\n                exprs: ExprArena { vec: Vec::new() },\r\n                stat_starts: Vec::new(),\r\n                symbols: SymbolSet::new(),\r\n                nots: IgnoreSet::new(),\r\n                source,\r\n                // title,\r\n            },\r\n            parse_title: flags.title,\r\n            stack: Vec::new(),\r\n            last_state: None,\r\n            pos: 0,\r\n            parsing_line: false,\r\n            last_result: LastMatchResult::None,\r\n            aliases,\r\n            repeat_count: 0,\r\n            stat_indexes: Vec::new(),\r\n            cached_fails: HashMap::new(),\r\n        }\r\n    }\r\n    ///get the last state\r\n    pub fn get_last_state\u003c'b\u003e(\u0026'b self) -\u003e Option\u003c\u0026'b State\u003e {\r\n        self.last_state.as_ref().or_else(|| self.stack.last())\r\n    }\r\n\r\n    ///get the name of the last state\r\n    pub fn get_last_state_name(\u0026self) -\u003e \u0026'static str {\r\n        self.get_last_state()\r\n            .map_or(\u0026\"None\", |state| state.state.get_name())\r\n    }\r\n\r\n    ///get the current stack and length\r\n    pub fn get_parser_stack(\u0026self) -\u003e (String, usize) {\r\n        let mut str = self.stack.iter().fold(String::new(), |mut str, state| {\r\n            str += \u0026format!(\"{}:{}, \", state.state.get_name(), state.last_parse);\r\n            str\r\n        });\r\n        str.pop();\r\n        str.pop();\r\n        (str, self.stack.len())\r\n    }\r\n\r\n    ///get the slice that was last used + index\r\n    pub fn get_last_word\u003c'b\u003e(\u0026'b self) -\u003e (\u0026'b [u8], usize) {\r\n        // (if self.last_result == LastMatchResult::Failed {\r\n        //     self.get_last_state()\r\n        // } else {\r\n        //     self.stack.last()\r\n        // })\r\n        self.get_last_state().map_or((b\"\", usize::MAX), |state| {\r\n            (\r\n                Self::get_slice(self.data.source.get_line(), state.last_parse)\r\n                    .0\r\n                    .str,\r\n                state.last_parse,\r\n            )\r\n        })\r\n    }\r\n\r\n    ///convert the parser into its data\r\n    ///also drops the stdin from the ParserSource\r\n    pub fn into_data(mut self) -\u003e ParsedData\u003c'a\u003e {\r\n        self.data.source.drop_input();\r\n        self.data\r\n    }\r\n}\r\n\r\n///the parser - Woah!!\r\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\r\n    ///step the parser\r\n    ///\r\n    pub fn step(\u0026mut self) -\u003e ParserResult {\r\n        let is_first = !self.parsing_line;\r\n        if is_first {\r\n            // push match stat on first step of line\r\n            if !self.setup_first() {\r\n                return ParserResult::NoInput;\r\n            } else {\r\n                return ParserResult::Start;\r\n            }\r\n        }\r\n        //debug time\r\n        // let _debug = only_debug!(Vec::from_iter(\r\n        //     self.stack.iter().map(|x| (x.expr_index, x.last_parse))\r\n        // ));\r\n        // let _debug2 = only_debug!(Vec::from_iter(\r\n        //     self.stack.iter().map(|x| x.state.get_name())\r\n        // ));\r\n        // let _expr = only_debug!(self.data.exprs.vec);\r\n        // let _expr2 = only_debug!(lisp_like_writer::write(\r\n        //     \u0026self.data.exprs,\r\n        //     \u0026self.data.stat_starts\r\n        // ));\r\n        // let _expr_short = only_debug!(Vec::from_iter(self.data.exprs.vec.iter().map(|e| {\r\n        //     let mut str = format!(\"{:?}\", e);\r\n        //     str.truncate(str.find(\" \").unwrap_or(str.len()));\r\n        //     str\r\n        // })));\r\n        // let _last = only_debug!(self.last_result);\r\n\r\n        self.last_state = None;\r\n        // get curr frame\r\n        let stack_index = self.stack.len() - 1;\r\n        let (parents, frame_arr) = self.stack.split_at_mut(stack_index);\r\n        let frame = \u0026mut frame_arr[0];\r\n\r\n        let id = frame.state.get_name();\r\n        // does the failing range of the state include the current parsing location\r\n        let must_fail = self\r\n            .cached_fails\r\n            .get(id)\r\n            .is_some_and(|range| range.contains(\u0026frame.last_parse));\r\n\r\n        if must_fail \u0026\u0026 !cfg!(feature = \"no-cache\") {\r\n            self.failed_func();\r\n            return ParserResult::CachedFail;\r\n        }\r\n        // should always be in bounds\r\n        // spilt at mut for borrow safety\r\n        // get (parents, this[0] and children[1..])\r\n        let parents_this = self.data.exprs.vec.split_at_mut(frame.expr_index);\r\n        //let _splits1 = format!(\"{:?}\", parents_this);\r\n        // get (this, children)\r\n        let this_children = parents_this.1.split_at_mut_checked(1);\r\n        //let _splits = format!(\"{:?} {:?}\", _splits1, this_children);\r\n\r\n        // default_expr is used on failing back to a none state,\r\n        // the corrisponding expr no longer exists\r\n        let mut expr = \u0026mut Expr::NoneExpr;\r\n        let mut after: \u0026mut [Expr] = \u0026mut [];\r\n        let before = parents_this.0;\r\n        if let Some(split) = this_children {\r\n            //should always be safe\r\n            expr = split.0.first_mut().unwrap();\r\n            after = split.1;\r\n        }\r\n\r\n        // let _self_expr = format!(\"{:?}\", expr);\r\n        //black_box(\u0026_debug);\r\n        //let mut last_stat = None;\r\n\r\n        // // // if last expr matched\r\n        // if let Some(index) = self.last_match_index {\r\n        //     // let last_stat_index = self.data.exprs[last_stat];\r\n        //     last_stat = split1.0.get_mut(index);\r\n        // }\r\n\r\n        // setup slice\r\n        let line = self.data.source.get_line();\r\n        let mut start = frame.last_parse;\r\n        let (mut word, mut rest) = Self::get_slice(line, start);\r\n\r\n        //New ignore code location\r\n        while self.data.nots.try_get_val(\u0026word, 0).is_some() {\r\n            start = rest.pos;\r\n            (word, rest) = Self::get_slice(line, start);\r\n        }\r\n\r\n        // setup env\r\n        let mut env = Environment {\r\n            expr,\r\n            parents,\r\n            after,\r\n            before,\r\n            last_stat_index: self.stat_indexes.last().cloned(),\r\n            expr_index: frame.expr_index,\r\n            symbols: \u0026mut self.data.symbols,\r\n            nots: \u0026mut self.data.nots,\r\n            locs: None,\r\n            global_index: self.pos,\r\n            aliases: \u0026self.aliases,\r\n            full_text: line,\r\n        };\r\n\r\n        let last_result = mem::replace(\u0026mut self.last_result, LastMatchResult::None);\r\n\r\n        // run step function\r\n        let mut result = match last_result {\r\n            LastMatchResult::None | LastMatchResult::Continue =\u003e {\r\n                frame.state.step(\u0026mut env, \u0026word, \u0026rest)\r\n            }\r\n            LastMatchResult::New(locs) =\u003e {\r\n                env.locs = locs;\r\n                frame.state.step(\u0026mut env, \u0026word, \u0026rest)\r\n            }\r\n            LastMatchResult::Matched(child_index) =\u003e {\r\n                frame\r\n                    .state\r\n                    .step_match(\u0026mut env, Some(child_index), \u0026word, \u0026rest)\r\n            }\r\n            LastMatchResult::Failed =\u003e frame.state.step_match(\u0026mut env, None, \u0026word, \u0026rest),\r\n        };\r\n\r\n        // run aftermath\r\n        let new_locs = env.locs.take();\r\n\r\n        // reached end of line - upgrade result to failed\r\n        if word.len() == 0 \u0026\u0026 matches!(result, MatchResult::Continue(0)) {\r\n            result = MatchResult::Failed;\r\n        }\r\n\r\n        match result {\r\n            // I matched - return to last expr on stack with success\r\n            MatchResult::Matched(index, bool) =\u003e self.matched_func(index, bool),\r\n            // continue parsing child\r\n            MatchResult::ContinueWith(index, state) =\u003e {\r\n                self.continue_with_func(index, state, new_locs)\r\n            }\r\n            // continue with me\r\n            MatchResult::Continue(index) =\u003e self.continue_func(rest.pos + index),\r\n            // I failed, go back on stack with fail\r\n            MatchResult::Failed =\u003e self.failed_func(),\r\n        }\r\n    }\r\n\r\n    ///this function is called if the step fails\r\n    fn failed_func(\u0026mut self) -\u003e ParserResult {\r\n        let state = self.stack.pop().unwrap();\r\n\r\n        let state_type = state.state.get_type();\r\n        if state_type == StateType::Stat {\r\n            // remove self\r\n            while self\r\n                .stat_indexes\r\n                .last()\r\n                .is_some_and(|index| *index \u003e state.expr_index)\r\n            {\r\n                self.stat_indexes.pop();\r\n            }\r\n        } else {\r\n            //insert the range of parsed words into map\r\n            let id = state.state.get_name();\r\n            self.cached_fails\r\n                .entry(id)\r\n                .or_insert(RangeSet::new())\r\n                .insert(state.first_parse..state.last_parse + 1);\r\n        }\r\n\r\n        let state_pos = state.expr_index;\r\n        self.data.exprs.vec.truncate(state_pos);\r\n        //let _test = format!(\"{:?}\", state);\r\n        self.repeat_count = 0;\r\n\r\n        self.last_state = Some(state);\r\n\r\n        self.last_result = LastMatchResult::Failed;\r\n        // failed final stat - couldn't parse anything on line\r\n        if self.stack.is_empty() {\r\n            self.parsing_line = false;\r\n            self.parse_title = false;\r\n            self.data.stat_starts.pop();\r\n            ParserResult::FailedLine\r\n        } else {\r\n            // setup result for next step\r\n            ParserResult::Failed\r\n        }\r\n    }\r\n\r\n    ///this function is called if the step coninues\r\n    fn continue_func(\u0026mut self, new_index: usize) -\u003e ParserResult {\r\n        let stack_index = self.stack.len() - 1;\r\n        let frame = \u0026mut self.stack[stack_index];\r\n\r\n        self.repeat_count = 0;\r\n        // change match starting location to after word\r\n        frame.last_parse = new_index;\r\n\r\n        self.last_result = LastMatchResult::Continue;\r\n\r\n        ParserResult::Continue\r\n    }\r\n    ///this function is called if the step coninues with\r\n    fn continue_with_func(\r\n        \u0026mut self,\r\n        index: usize,\r\n        state: Box\u003cdyn ParseState\u003e,\r\n        locs: Option\u003cVec\u003cusize\u003e\u003e,\r\n    ) -\u003e ParserResult {\r\n        let mut expr_index = self.data.exprs.vec.len();\r\n        self.repeat_count = 0;\r\n        // replace none exprs\r\n        if self.data.exprs.vec.last().is_some_and(|e| e.is_none()) {\r\n            self.data.exprs.vec.pop();\r\n            expr_index -= 1;\r\n        }\r\n        self.data.exprs.vec.push(Expr::NoneExpr);\r\n        self.stack.push(State {\r\n            expr_index,\r\n            first_parse: index,\r\n            last_parse: index,\r\n            state,\r\n        });\r\n\r\n        self.last_result = LastMatchResult::New(locs);\r\n\r\n        ParserResult::ContinueWith\r\n    }\r\n\r\n    ///this function is called if the step matches\r\n    fn matched_func(\u0026mut self, mut index: usize, closed: bool) -\u003e ParserResult {\r\n        let state = self.stack.pop().unwrap();\r\n        let expr_index = state.expr_index;\r\n        if state.state.get_type() == StateType::Stat {\r\n            // add self\r\n            self.stat_indexes.push(expr_index);\r\n            // stats can change parse ablility -- reset cached fails\r\n            self.cached_fails = HashMap::new();\r\n        }\r\n        self.last_state = Some(state);\r\n\r\n        // matched final stat\r\n        if self.stack.is_empty() {\r\n            if self.parse_title {\r\n                if let Expr::Title { data } = \u0026self.data.exprs[expr_index] {\r\n                    self.aliases = AliasData::new(\u0026mut data.imports.iter().map(|e| \u0026e.0))\r\n                } else {\r\n                    unreachable!()\r\n                };\r\n            }\r\n            self.parse_title = false;\r\n            // setup next\r\n            self.add_new_start_state(index);\r\n            ParserResult::MatchedLine\r\n        } else {\r\n            if closed {\r\n                let line = self.data.source.get_line();\r\n                self.repeat_count += 1;\r\n                // get needed counts\r\n                let cd = get_close_data(\u0026line[index..]);\r\n                if self.repeat_count \u003e= cd.close_count {\r\n                    index += cd.close_length as usize;\r\n                    self.repeat_count = 0;\r\n                }\r\n            }\r\n            // setup result for next step\r\n            self.last_result = LastMatchResult::Matched(expr_index);\r\n            let parent_state = self.stack.last_mut().unwrap();\r\n            parent_state.last_parse = index;\r\n\r\n            // remove parent expr from cachefail map\r\n            self.cached_fails.remove(parent_state.state.get_name());\r\n            ParserResult::Matched\r\n        }\r\n    }\r\n    ///get a (word,rest) that starts at start\r\n    fn get_slice(line: \u0026[u8], mut start: usize) -\u003e (Slice, Slice) {\r\n        //let line = line.as_bytes();\r\n        start = start.min(line.len());\r\n\r\n        let slice = Slice {\r\n            str: \u0026line[start..],\r\n            pos: start,\r\n        };\r\n        get_next_slice(\u0026slice, 0)\r\n    }\r\n    ///setup the a new line for parsing\r\n    fn setup_first(\u0026mut self) -\u003e bool {\r\n        let line = self.data.source.get_line();\r\n        self.pos += line.len();\r\n        let data = self.data.source.new_line();\r\n        if let Some(data) = data {\r\n            let found_data = data.trim().len() \u003e 0;\r\n            if found_data {\r\n                self.add_new_start_state(0);\r\n                self.parsing_line = true;\r\n            }\r\n            found_data\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n    ///setup a noneStat on the stack\r\n    fn add_new_start_state(\u0026mut self, new_index: usize) {\r\n        // if need to parse title -- put it on stack\r\n        let state = if self.parse_title {\r\n            get_state!(title::TitleState::new())\r\n        } else {\r\n            get_state!(alias::NoneState::new_stat_cont())\r\n        };\r\n\r\n        // push match stat on first step of line\r\n        let expr_index = self.data.exprs.vec.len();\r\n\r\n        self.data.exprs.vec.push(Expr::NoneStat);\r\n\r\n        self.stack.push(State {\r\n            expr_index,\r\n            first_parse: new_index,\r\n            last_parse: new_index,\r\n            state,\r\n        });\r\n\r\n        self.data.stat_starts.push(expr_index);\r\n        self.last_result = LastMatchResult::None;\r\n        self.cached_fails = HashMap::new();\r\n    }\r\n}\r\n\r\n// /// https://stackoverflow.com/questions/31101915/how-to-implement-trim-for-vecu8\r\n// pub fn trim_ascii_whitespace(x: \u0026[u8]) -\u003e \u0026[u8] {\r\n//     let from = match x.iter().position(|x| !x.is_ascii_whitespace()) {\r\n//         Some(i) =\u003e i,\r\n//         None =\u003e return \u0026x[0..0],\r\n//     };\r\n//     let to = x.iter().rposition(|x| !x.is_ascii_whitespace()).unwrap();\r\n//     \u0026x[from..=to]\r\n// }\r\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":78,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":79,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":80,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":81,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":170,"address":[],"length":0,"stats":{"Line":13690942867206307840}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":16068843470457929727}},{"line":177,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":185,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":186,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":193,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":194,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":239,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":240,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":248,"address":[],"length":0,"stats":{"Line":11889503016258109441}},{"line":249,"address":[],"length":0,"stats":{"Line":11889503016258109441}},{"line":250,"address":[],"length":0,"stats":{"Line":11889503016258109441}},{"line":252,"address":[],"length":0,"stats":{"Line":13763000461244235824}},{"line":253,"address":[],"length":0,"stats":{"Line":16068843470457929776}},{"line":255,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":277,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":279,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":280,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":281,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":283,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":285,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":286,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":287,"address":[],"length":0,"stats":{"Line":16573246628723425233}},{"line":288,"address":[],"length":0,"stats":{"Line":4683743612465315793}},{"line":290,"address":[],"length":0,"stats":{"Line":936748722493063171}},{"line":291,"address":[],"length":0,"stats":{"Line":936748722493063169}},{"line":292,"address":[],"length":0,"stats":{"Line":936748722493063169}},{"line":297,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":300,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":305,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":306,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":307,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":308,"address":[],"length":0,"stats":{"Line":7421932185906577358}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":15636497906230362088}},{"line":331,"address":[],"length":0,"stats":{"Line":13}},{"line":332,"address":[],"length":0,"stats":{"Line":13}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":15636497906230362062}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":13618885273168379829}},{"line":358,"address":[],"length":0,"stats":{"Line":9871890383196127232}},{"line":359,"address":[],"length":0,"stats":{"Line":9871890383196127232}},{"line":360,"address":[],"length":0,"stats":{"Line":9871890383196127232}},{"line":362,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":363,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":364,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":365,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":367,"address":[],"length":0,"stats":{"Line":4323455642275676166}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":5044031582654955543}},{"line":375,"address":[],"length":0,"stats":{"Line":16573246628723425280}},{"line":378,"address":[],"length":0,"stats":{"Line":15636497906230362056}},{"line":380,"address":[],"length":0,"stats":{"Line":5908722711110090771}},{"line":382,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":383,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":386,"address":[],"length":0,"stats":{"Line":16357073846609641487}},{"line":388,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":393,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":394,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":396,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":397,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":399,"address":[],"length":0,"stats":{"Line":1297036692682702863}},{"line":400,"address":[],"length":0,"stats":{"Line":1297036692682702863}},{"line":401,"address":[],"length":0,"stats":{"Line":1297036692682702863}},{"line":402,"address":[],"length":0,"stats":{"Line":2377900603251621906}},{"line":404,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":408,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":409,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":410,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":411,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":412,"address":[],"length":0,"stats":{"Line":1008806316530991090}},{"line":415,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":416,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":418,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":420,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":422,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":424,"address":[],"length":0,"stats":{"Line":2089670227099910145}},{"line":425,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":426,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":427,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":428,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":431,"address":[],"length":0,"stats":{"Line":4395513236313604097}},{"line":436,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":437,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":438,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":440,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":442,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":444,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":446,"address":[],"length":0,"stats":{"Line":16357073846609641473}},{"line":449,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":455,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":456,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":458,"address":[],"length":0,"stats":{"Line":17437937757178560533}},{"line":459,"address":[],"length":0,"stats":{"Line":3098476543630901267}},{"line":460,"address":[],"length":0,"stats":{"Line":3098476543630901267}},{"line":462,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":463,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":464,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":465,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":466,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":467,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":470,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":472,"address":[],"length":0,"stats":{"Line":10664523917613334529}},{"line":522,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":524,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":527,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":530,"address":[],"length":0,"stats":{"Line":15636497906230362113}},{"line":533,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":534,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":535,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":536,"address":[],"length":0,"stats":{"Line":13763000461244235820}},{"line":537,"address":[],"length":0,"stats":{"Line":11457157452030541909}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":540,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":541,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":543,"address":[],"length":0,"stats":{"Line":16140901064495857666}},{"line":545,"address":[],"length":0,"stats":{"Line":16068843470457929731}},{"line":549,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":551,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":552,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":15780613094306217981}},{"line":558,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":560,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":562,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":563,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":564,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":565,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":566,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":569,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":570,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":571,"address":[],"length":0,"stats":{"Line":15780613094306217984}}],"covered":144,"coverable":179},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser_runner.rs"],"content":"// pub enum ParserVisuals{\r\n\r\n// }\r\n\r\nuse std::time::SystemTime;\r\n\r\nuse crate::{\r\n    parser::{ParsedData, Parser, ParserFlags, ParserResult, ParserSource},\r\n    writers::{\r\n        javascript_writer, lisp_like_writer,\r\n        syntax_lint::SyntaxLinter,\r\n        syntax_renderers::{line_renderer::LineRenderer, wind_renderer::WindowsRenderer},\r\n    },\r\n};\r\n\r\n#[derive(Clone, Copy)]\r\npub struct RunnerFlags {\r\n    pub assert_steps: bool,\r\n    #[allow(dead_code)]\r\n    pub input: bool,\r\n    pub whole_program: bool,\r\n    pub linted: bool,\r\n    pub line_rendered: bool,\r\n}\r\n\r\npub fn run_state(state: ParserResult, parser: \u0026Parser, parser_flags: RunnerFlags, step_count: u64) {\r\n    let count = if cfg!(feature = \"speed\") { 1000000 } else { 1 };\r\n\r\n    if parser_flags.assert_steps {\r\n        if step_count % count == 0 {\r\n            let (word, index) = parser.get_last_word();\r\n            let (stack, length) = parser.get_parser_stack();\r\n            println!(\r\n                \"step:{}\\nword:[{}:{}]\\nreturn:[{:?}]\\nstack:{}[{}]\",\r\n                step_count,\r\n                std::str::from_utf8(word).unwrap(),\r\n                index,\r\n                state,\r\n                length,\r\n                stack\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\npub fn run_after(data: ParsedData, parser_flags: RunnerFlags) {\r\n    // if parser_flags.input {\r\n    //     let iter = data.source.get_iter();\r\n    //     println!(\r\n    //         \"    text input:\\n\\\"{}\\\"\",\r\n    //         std::str::from_utf8(iter.cloned().collect::\u003cVec\u003c_\u003e\u003e().as_slice()).unwrap()\r\n    //     );\r\n    // }\r\n    if parser_flags.whole_program {\r\n        println!(\r\n            \"   whole program:\\n{}\",\r\n            lisp_like_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n        );\r\n        println!(\r\n            \"   JavaScript output:\\n{}\",\r\n            javascript_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n        );\r\n    }\r\n    if parser_flags.linted {\r\n        let iter = data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cWindowsRenderer\u003e::new();\r\n        lint.write(\u0026data.exprs, \u0026data.stat_starts, iter);\r\n        println!(\r\n            \"   linted:\\n{}\",\r\n            std::str::from_utf8(\u0026lint.into_data()).unwrap()\r\n        );\r\n    }\r\n    if parser_flags.line_rendered {\r\n        let iter = data.source.get_iter();\r\n        let mut lint = SyntaxLinter::\u003cLineRenderer\u003e::new();\r\n        lint.write(\u0026data.exprs, \u0026data.stat_starts, iter);\r\n        println!(\"   line renderered:\\n{:?}\", lint.into_data());\r\n    }\r\n}\r\n\r\npub fn run_parser(parser_flags: ParserFlags, vis_flags: RunnerFlags, source: ParserSource) {\r\n    // println!(\"Input text to be parsed:\");\r\n    let mut parser = Parser::new(source, parser_flags);\r\n    let mut step_count = 0;\r\n    let start = SystemTime::now();\r\n    loop {\r\n        match parser.step() {\r\n            ParserResult::NoInput =\u003e break,\r\n            state =\u003e run_state(state, \u0026parser, vis_flags, step_count),\r\n        }\r\n        step_count += 1;\r\n    }\r\n    let end = SystemTime::now();\r\n    let duration = end.duration_since(start).unwrap();\r\n    println!(\r\n        \"took {} seconds with {} steps\",\r\n        duration.as_secs(),\r\n        step_count\r\n    );\r\n\r\n    let data = parser.into_data();\r\n\r\n    run_after(data, vis_flags);\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser_source.rs"],"content":"use std::{\r\n    fmt::Debug,\r\n    io::{stdin, BufRead, StdinLock},\r\n    iter::{self, Flatten},\r\n};\r\n\r\nuse bstr::{ByteSlice, ByteVec};\r\n\r\npub type ParserSourceIter\u003c'a\u003e = Flatten\u003cstd::vec::IntoIter\u003cBox\u003cdyn Iterator\u003cItem = \u0026'a u8\u003e + 'a\u003e\u003e\u003e;\r\n\r\nmacro_rules! make_iter {\r\n    ($expr:expr) =\u003e {\r\n        Box::new($expr) as Box\u003cdyn iter::Iterator\u003cItem = \u0026u8\u003e\u003e\r\n    };\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Source\u003c'a\u003e {\r\n    Stdin {\r\n        source: Option\u003cStdinLock\u003c'a\u003e\u003e,\r\n        start: usize,\r\n        buf: Vec\u003cu8\u003e,\r\n    },\r\n    File,\r\n    String {\r\n        str: Vec\u003cu8\u003e,\r\n        first: bool,\r\n    },\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct ParserSource\u003c'a\u003e {\r\n    sources: Vec\u003cSource\u003c'a\u003e\u003e,\r\n    index: usize,\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    pub fn from_stdin() -\u003e Self {\r\n        Self {\r\n            sources: Vec::new(),\r\n            index: 0,\r\n        }\r\n        .add_stdin()\r\n    }\r\n    pub fn from_string(str: Vec\u003cu8\u003e) -\u003e Self {\r\n        Self {\r\n            sources: Vec::new(),\r\n            index: 0,\r\n        }\r\n        .add_string(str)\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    pub fn add_stdin(mut self) -\u003e Self {\r\n        self.sources.push(Source::Stdin {\r\n            source: Some(stdin().lock()),\r\n            start: 0,\r\n            buf: Vec::new(),\r\n        });\r\n        self\r\n    }\r\n\r\n    pub fn add_string(mut self, mut str: Vec\u003cu8\u003e) -\u003e Self {\r\n        // if last is not newline - add it\r\n        if does_str_need_newline(\u0026str) {\r\n            str.push(b'\\n');\r\n        }\r\n\r\n        for slice in str.split_str(\"\\n\\n\") {\r\n            let mut str = slice.to_vec();\r\n            str.push_str(b\"\\n\\n\");\r\n            self.sources.push(Source::String { str, first: true });\r\n        }\r\n\r\n        self\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    pub fn get_line\u003c'b\u003e(\u0026'b self) -\u003e \u0026'b [u8] {\r\n        match \u0026self.sources[self.index] {\r\n            Source::Stdin { start, buf, .. } =\u003e \u0026buf[*start..],\r\n            Source::File =\u003e todo!(),\r\n            Source::String { str, first } =\u003e {\r\n                // if getting before new line is set - return nothing\r\n                if *first {\r\n                    \u0026[]\r\n                } else {\r\n                    \u0026str\r\n                }\r\n            }\r\n        }\r\n    }\r\n    pub fn new_line\u003c'b\u003e(\u0026'b mut self) -\u003e Option\u003c\u0026'b [u8]\u003e {\r\n        loop {\r\n            if self.index \u003e= self.sources.len() {\r\n                return None;\r\n            }\r\n            let has_failed = match \u0026mut self.sources[self.index] {\r\n                Source::Stdin { source, start, buf } =\u003e {\r\n                    if let Some(stdin) = source {\r\n                        Self::get_from_stdin(stdin, start, buf)\r\n                    } else {\r\n                        true\r\n                    }\r\n                }\r\n                Source::File =\u003e todo!(),\r\n                Source::String { first, .. } =\u003e {\r\n                    let ret = *first;\r\n                    *first = false;\r\n                    !ret\r\n                }\r\n            };\r\n            if has_failed {\r\n                self.index += 1;\r\n            } else {\r\n                return Some(self.get_line());\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn drop_input(\u0026mut self) {\r\n        for s in \u0026mut self.sources {\r\n            if let Source::Stdin { source, .. } = s {\r\n                *source = None;\r\n            }\r\n        }\r\n    }\r\n    pub fn get_iter\u003c'b\u003e(\u0026'b self) -\u003e ParserSourceIter {\r\n        let mut ret = Vec::new();\r\n        let mut add_newline = false;\r\n        for s in \u0026self.sources {\r\n            if add_newline {\r\n                ret.push(make_iter!(iter::once(\u0026b'\\n')));\r\n            }\r\n            let iter;\r\n            (iter, add_newline) = match s {\r\n                Source::Stdin { buf, .. } =\u003e (make_iter!(buf.iter()), false),\r\n                Source::File =\u003e todo!(),\r\n                Source::String { str, .. } =\u003e (make_iter!(str.iter()), does_str_need_newline(str)),\r\n            };\r\n            ret.push(iter);\r\n        }\r\n        ret.into_iter().flatten()\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e ParserSource\u003c'a\u003e {\r\n    /// get input from stdin stoping on 0 len input\r\n    /// returns has_failed\r\n    fn get_from_stdin(stdin: \u0026mut StdinLock\u003c'a\u003e, start: \u0026mut usize, buf: \u0026mut Vec\u003cu8\u003e) -\u003e bool {\r\n        println!(\"Input text to be parsed:\");\r\n        let mut has_input = false;\r\n        // let mut has_first_empty = false;\r\n        *start = buf.len();\r\n        loop {\r\n            let mut new_input = Vec::new();\r\n            let has_failed = stdin.read_until(b'\\n', \u0026mut new_input).is_err();\r\n\r\n            // remove newlines if it exists\r\n            while !new_input.is_empty() {\r\n                let last = *new_input.last().unwrap();\r\n                if last == b'\\n' || last == b'\\r' {\r\n                    new_input.pop();\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if has_failed || new_input.len() == 0 {\r\n                // if has_first_empty {\r\n                buf.push(b'\\n');\r\n                return !has_input;\r\n            }\r\n            //     } else {\r\n            //         has_first_empty = true;\r\n            //     }\r\n            // } else {\r\n            //     has_first_empty = false;\r\n            // }\r\n\r\n            has_input = true;\r\n            if buf.len() == 0 {\r\n                *buf = new_input;\r\n            } else {\r\n                buf.append(\u0026mut new_input);\r\n            }\r\n            buf.push(b'\\n');\r\n        }\r\n    }\r\n}\r\n\r\nfn does_str_need_newline(str: \u0026Vec\u003cu8\u003e) -\u003e bool {\r\n    !str.last().is_some_and(|f| *f == b'\\n')\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":47,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":50,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":66,"address":[],"length":0,"stats":{"Line":13690942867206307842}},{"line":67,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":70,"address":[],"length":0,"stats":{"Line":11457157452030541827}},{"line":71,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":72,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":73,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":76,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":81,"address":[],"length":0,"stats":{"Line":11673330234144325633}},{"line":82,"address":[],"length":0,"stats":{"Line":11673330234144325633}},{"line":83,"address":[],"length":0,"stats":{"Line":18446744073709551565}},{"line":85,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":87,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":88,"address":[],"length":0,"stats":{"Line":16068843470457929780}},{"line":90,"address":[],"length":0,"stats":{"Line":14051230837395947521}},{"line":95,"address":[],"length":0,"stats":{"Line":13763000461244235826}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":11457157452030541877}},{"line":98,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":100,"address":[],"length":0,"stats":{"Line":13835058055282163763}},{"line":101,"address":[],"length":0,"stats":{"Line":51}},{"line":102,"address":[],"length":0,"stats":{"Line":48}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":110,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":111,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":112,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":115,"address":[],"length":0,"stats":{"Line":16140901064495857667}},{"line":116,"address":[],"length":0,"stats":{"Line":16140901064495857667}},{"line":118,"address":[],"length":0,"stats":{"Line":16140901064495857665}},{"line":123,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":124,"address":[],"length":0,"stats":{"Line":11457157452030541828}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":195,"address":[],"length":0,"stats":{"Line":11313042263954685952}}],"covered":47,"coverable":81},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","parser_structs.rs"],"content":"use bstr::ByteSlice;\r\nuse quickscope::ScopeMap;\r\nuse std::{\r\n    collections::HashSet,\r\n    fmt::{self, Debug},\r\n    usize,\r\n};\r\n\r\nuse super::{alias_data::AliasData, Expr};\r\n\r\npub fn try_get_best_val\u003c'a\u003e(\r\n    name: \u0026[u8],\r\n    iter: \u0026mut dyn Iterator\u003cItem = \u0026'a [u8]\u003e,\r\n    pred: \u0026dyn Fn(\u0026[u8]) -\u003e bool,\r\n) -\u003e Option\u003c(u8, \u0026'a [u8], usize)\u003e {\r\n    let mut max_var_length = 0u8;\r\n    let mut var_data: Option\u003c(u8, \u0026[u8], usize)\u003e = None;\r\n    for (index, str) in iter.enumerate() {\r\n        let is_longer = str.len() as u8 \u003e= max_var_length;\r\n        // if var could be in word\r\n        if is_longer \u0026\u0026 name.len() \u003e= str.len() \u0026\u0026 (pred)(str) {\r\n            // if found\r\n            if let Some(str_index) = name.find(str) {\r\n                let is_better = var_data.as_ref().map_or(true, |\u0026(old_index, _, _)| {\r\n                    is_longer || (str_index as u8) \u003c old_index\r\n                });\r\n\r\n                if is_better {\r\n                    max_var_length = str.len() as u8;\r\n                    var_data = Some((str_index as u8, str, index));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var_data\r\n}\r\n/// remove skip indexes outside of var str and fix indexes for ones inside, returns var start in term of word start\r\nfn convert_skip_indexes(skip_indexes: \u0026mut Vec\u003cu8\u003e, var_start: u8, var_len: u8) -\u003e u8 {\r\n    let mut start_index = 0u8;\r\n    while start_index \u003c skip_indexes.len() as u8 {\r\n        if skip_indexes[start_index as usize] \u003c= var_start + start_index {\r\n            start_index += 1;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    let start = var_start + start_index;\r\n    let var_end = start + var_len;\r\n    skip_indexes.drain(..start_index as usize);\r\n\r\n    let end_index = skip_indexes\r\n        .iter()\r\n        .position(|\u0026v| v \u003e var_end)\r\n        .unwrap_or(skip_indexes.len());\r\n    skip_indexes.drain(end_index..);\r\n\r\n    for val in skip_indexes {\r\n        *val -= start;\r\n    }\r\n    start\r\n}\r\n\r\nfn try_get_from_iter\u003c'a\u003e(\r\n    word: \u0026Slice,\r\n    iter: \u0026mut dyn Iterator\u003cItem = \u0026'a [u8]\u003e,\r\n    global_index: usize,\r\n    pred: \u0026dyn Fn(\u0026[u8]) -\u003e bool,\r\n) -\u003e Option\u003cSubStrData\u003e {\r\n    if word.len() \u003e 255 {\r\n        return None;\r\n    }\r\n    // remove ' and make lowercase\r\n    let (name, mut skip_indexes) = get_var_name_and_skips(word.str);\r\n    let var_data = try_get_best_val(\u0026name, iter, pred);\r\n\r\n    if let Some((var_start, name, _)) = var_data {\r\n        let start = convert_skip_indexes(\u0026mut skip_indexes, var_start, name.len() as u8);\r\n\r\n        Some(SubStrData {\r\n            start: global_index + word.pos + start as usize,\r\n            name: name.to_vec(),\r\n            skip_indexes,\r\n        })\r\n    } else {\r\n        None\r\n    }\r\n}\r\nenum Symbol {\r\n    ///symbol is a varible\r\n    Var,\r\n    ///symbol is a function with a number of arguments\r\n    Func(u8),\r\n}\r\n\r\npub struct SymbolSet {\r\n    set: ScopeMap\u003cVec\u003cu8\u003e, Symbol\u003e,\r\n}\r\nimpl SymbolSet {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            set: ScopeMap::new(),\r\n        }\r\n    }\r\n    pub fn insert_var(\u0026mut self, mut name: Vec\u003cu8\u003e) {\r\n        name.make_ascii_lowercase();\r\n        self.set.define(name, Symbol::Var);\r\n    }\r\n    pub fn insert_func(\u0026mut self, mut name: Vec\u003cu8\u003e, args: u8) {\r\n        name.make_ascii_lowercase();\r\n        self.set.define(name, Symbol::Func(args));\r\n    }\r\n    pub fn add_layer(\u0026mut self) {\r\n        self.set.push_layer();\r\n    }\r\n    pub fn remove_layer(\u0026mut self) {\r\n        self.set.pop_layer();\r\n    }\r\n    pub fn contains(\u0026self, name: \u0026[u8]) -\u003e bool {\r\n        let lower = name.to_ascii_lowercase();\r\n        self.set.contains_key(\u0026lower)\r\n    }\r\n    pub fn get_func_arg_count(\u0026self, name: \u0026Vec\u003cu8\u003e) -\u003e Option\u003cu8\u003e {\r\n        let lower = name.to_ascii_lowercase();\r\n        if let Some(Symbol::Func(count)) = self.set.get(\u0026lower) {\r\n            Some(*count)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n    ///returns (index in word, varible name)\r\n    ///\r\n    pub fn try_get_var(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n        try_get_from_iter(\r\n            word,\r\n            \u0026mut self.set.keys().map(|e| e.as_slice()),\r\n            global_index,\r\n            \u0026|name| matches!(self.set.get(name), Some(Symbol::Var)),\r\n        )\r\n    }\r\n\r\n    pub fn try_get_func(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n        try_get_from_iter(\r\n            word,\r\n            \u0026mut self.set.keys().map(|e| e.as_slice()),\r\n            global_index,\r\n            \u0026|name| matches!(self.set.get(name), Some(Symbol::Func(..))),\r\n        )\r\n    }\r\n}\r\nimpl Debug for SymbolSet {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        f.debug_struct(\"SymbolSet\").finish()\r\n    }\r\n}\r\n\r\npub struct IgnoreSet {\r\n    set: HashSet\u003cVec\u003cu8\u003e\u003e,\r\n}\r\n\r\nimpl IgnoreSet {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            set: HashSet::new(),\r\n        }\r\n    }\r\n    pub fn insert(\u0026mut self, name: Vec\u003cu8\u003e) {\r\n        let lower = name.to_ascii_lowercase();\r\n        self.set.insert(lower);\r\n    }\r\n    pub fn contains(\u0026self, name: \u0026Vec\u003cu8\u003e) -\u003e bool {\r\n        let lower = name.to_ascii_lowercase();\r\n        self.set.contains(\u0026lower)\r\n    }\r\n    ///returns (index in word, length)\r\n    pub fn try_get_val(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n        if word.len() \u003e 255 {\r\n            return None;\r\n        }\r\n        // remove ' and make lowercase\r\n        let (name, mut skip_indexes) = get_var_name_and_skips(word.str);\r\n        let var_data =\r\n            try_get_best_val(\u0026name, \u0026mut self.set.iter().map(|e| e.as_slice()), \u0026|_| true);\r\n\r\n        if let Some((var_start, name, _)) = var_data {\r\n            let start = convert_skip_indexes(\u0026mut skip_indexes, var_start, name.len() as u8);\r\n\r\n            Some(SubStrData {\r\n                start: global_index + word.pos + start as usize,\r\n                name: name.to_vec(),\r\n                skip_indexes,\r\n            })\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\nimpl Debug for IgnoreSet {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        f.debug_struct(\"IgnoreSet\").finish()\r\n    }\r\n}\r\n\r\n// pub struct FuncSet {\r\n//     /// set with \u003cname, arg_count\u003e\r\n//     set: ScopeMap\u003cVec\u003cu8\u003e, usize\u003e,\r\n// }\r\n\r\n// impl FuncSet {\r\n//     pub fn new() -\u003e Self {\r\n//         Self {\r\n//             set: ScopeMap::new(),\r\n//         }\r\n//     }\r\n//     pub fn insert(\u0026mut self, name: Vec\u003cu8\u003e, arg_count: usize) {\r\n//         self.set.define(name, arg_count);\r\n//     }\r\n//     pub fn add_layer(\u0026mut self) {\r\n//         self.set.push_layer();\r\n//     }\r\n//     pub fn remove_layer(\u0026mut self) {\r\n//         self.set.pop_layer();\r\n//     }\r\n//     pub fn contains(\u0026self, name: Vec\u003cu8\u003e) -\u003e bool {\r\n//         self.set.contains_key(\u0026name)\r\n//     }\r\n//     pub fn try_get_func(\u0026self, word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n//         if word.len() \u003e 255 {\r\n//             return None;\r\n//         }\r\n//         // remove ' and make lowercase\r\n//         let (name, mut skip_indexes) = get_var_name_and_skips(word.str);\r\n//         let var_data = try_get_val(\u0026name, \u0026mut self.set.keys());\r\n\r\n//         if let Some((var_start, name)) = var_data {\r\n//             let start = convert_skip_indexes(\u0026mut skip_indexes, var_start, name.len() as u8);\r\n\r\n//             Some(SubStrData {\r\n//                 start: global_index + word.pos + start as usize,\r\n//                 name: name.to_vec(),\r\n//                 skip_indexes,\r\n//             })\r\n//         } else {\r\n//             None\r\n//         }\r\n//     }\r\n\r\n//     pub fn get_arg_count(\u0026self, name: \u0026[u8]) -\u003e Option\u003c\u0026usize\u003e {\r\n//         self.set.get(name)\r\n//     }\r\n// pub fn inc_arg_count(\u0026mut self, name: \u0026[u8]) {\r\n//     if let Some(val) = self.set.get(name) {\r\n//         //Increment in above scope.\r\n//         self.set.define(name.to_vec(), val + 1);\r\n//     }\r\n// }\r\n// }\r\n\r\n// impl Debug for FuncSet {\r\n//     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n//         f.debug_struct(\"FuncSet\").finish()\r\n//     }\r\n// }\r\n#[derive(PartialEq, Debug)]\r\npub struct SubStrData {\r\n    pub name: Vec\u003cu8\u003e,\r\n    pub start: usize,\r\n    pub skip_indexes: Vec\u003cu8\u003e,\r\n}\r\n\r\nimpl SubStrData {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            start: usize::MAX,\r\n            name: Vec::new(),\r\n            skip_indexes: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\n\r\n/// a state on the stack\r\npub struct State {\r\n    pub expr_index: usize,\r\n    pub first_parse: usize,\r\n    pub last_parse: usize,\r\n    pub state: Box\u003cdyn ParseState\u003e,\r\n}\r\n\r\n/// a macro to change the a ParseState to a generic box\r\nmacro_rules! get_state {\r\n    ($state:expr) =\u003e {\r\n        Box::new($state) as Box\u003cdyn ParseState\u003e\r\n    };\r\n}\r\npub(crate) use get_state;\r\n\r\n// macro_rules! only_debug {\r\n//     ($expr:expr) =\u003e {\r\n//         if cfg!(debug_assertions) {\r\n//             format!(\"{:?}\", $expr)\r\n//         } else {\r\n//             Default::default()\r\n//         }\r\n//     };\r\n// }\r\n// pub(crate) use only_debug;\r\n\r\n/// add or remove commands based on flags\r\n#[derive(Default, Debug)]\r\npub struct ParserFlags {\r\n    pub title: bool,\r\n}\r\n\r\n#[derive(PartialEq, Eq, Debug)]\r\npub enum StateType {\r\n    /// for NoneExpr and NoneStat\r\n    /// is replaceble\r\n    None,\r\n    Expr,\r\n    Stat,\r\n}\r\n\r\n/// A state (which goes onto the parser stack)\r\npub trait ParseState: Debug {\r\n    /// called first time to setup the state and after the state continues\r\n    fn step(\u0026mut self, env: \u0026mut Environment, word: \u0026Slice, rest: \u0026Slice) -\u003e MatchResult;\r\n\r\n    /// called after match or fail\r\n    fn step_match(\r\n        \u0026mut self,\r\n        env: \u0026mut Environment,\r\n        child: Option\u003cusize\u003e,\r\n        word: \u0026Slice,\r\n        rest: \u0026Slice,\r\n    ) -\u003e MatchResult;\r\n\r\n    /// gets the name of the state\r\n    fn get_name(\u0026self) -\u003e \u0026'static str;\r\n\r\n    fn get_type(\u0026self) -\u003e StateType;\r\n}\r\n\r\n///a struct for closing character with an index and a length\r\n#[derive(PartialEq, Debug, Clone, Copy)]\r\npub struct End {\r\n    pub index: usize,\r\n    pub count: u8,\r\n}\r\n\r\nimpl End {\r\n    /// make new end from index and close length\r\n    pub fn new(index: usize, count: u8) -\u003e Self {\r\n        Self { index, count }\r\n    }\r\n\r\n    pub fn from_slice(slice: \u0026Slice, global_index: usize) -\u003e Self {\r\n        End::new(slice.pos + global_index, slice.str.len() as u8)\r\n    }\r\n\r\n    pub fn none() -\u003e Self {\r\n        End::new(usize::MAX, 0)\r\n    }\r\n}\r\n\r\n/// the result of a step or stepmatch function\r\n#[derive(Debug)]\r\npub enum MatchResult {\r\n    /// returned to go to the parent state with the index to now parse from and whether the state closed on it\r\n    Matched(usize, bool),\r\n    /// returned to add a child onto the stack with an index and the state to continue with\r\n    ContinueWith(usize, Box\u003cdyn ParseState\u003e),\r\n    /// returned to give the same state with the offset (usually 0)\r\n    Continue(usize),\r\n    /// returned to go to the parent state with a failure\r\n    Failed,\r\n}\r\n\r\n///the result of the last match\r\n///None means that the parser just started\r\n///New means that continuewith was returned with the locs if they exist\r\n///The rest are the same as MatchResult\r\n#[derive(PartialEq, Debug)]\r\npub enum LastMatchResult {\r\n    None,\r\n    New(Option\u003cVec\u003cusize\u003e\u003e),\r\n    Matched(usize),\r\n    Failed,\r\n    Continue,\r\n}\r\n\r\n///The state that is returned each step\r\n///NoInput means that the parser ran out of input text\r\n///Start means that the parser just started (it is never returned)\r\n///MatchedLine means that the parser just matched a statement\r\n///FailedLine means that the parser just reached the end of a buffer without matching\r\n///The rest are the same as MatchResult and returned accordingly   \r\n#[derive(PartialEq, Debug, Clone, Copy)]\r\npub enum ParserResult {\r\n    NoInput,\r\n    Start,\r\n\r\n    MatchedLine,\r\n    FailedLine,\r\n\r\n    Matched,\r\n    ContinueWith,\r\n    Continue,\r\n    Failed,\r\n    /// this fail was cached earlier\r\n    CachedFail,\r\n}\r\n\r\n///is the state able to be closed\r\n///either it can't, it can, or it must.\r\n#[derive(Debug)]\r\npub enum CloseType {\r\n    Unable,\r\n    Able,\r\n    Force,\r\n}\r\n\r\nimpl ParserResult {\r\n    /// is the parser result an end (is it MatchedLine, FailedLine, or NoInput)\r\n    pub fn is_end(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            ParserResult::MatchedLine | ParserResult::FailedLine | ParserResult::NoInput\r\n        )\r\n    }\r\n}\r\n\r\n///the parser enviorment\r\npub struct Environment\u003c'a\u003e {\r\n    ///The set of current varibles\r\n    pub symbols: \u0026'a mut SymbolSet,\r\n    ///The set of current ignored values\r\n    pub nots: \u0026'a mut IgnoreSet,\r\n    ///The list of expressions\r\n    pub expr: \u0026'a mut Expr,\r\n    ///the index of this expr\r\n    pub expr_index: usize,\r\n    ///the exprs before this\r\n    pub parents: \u0026'a [State],\r\n    ///the exprs before this\r\n    pub before: \u0026'a mut [Expr],\r\n    ///the exprs after this\r\n    pub after: \u0026'a mut [Expr],\r\n    ///The last matched expr if exists\r\n    pub last_stat_index: Option\u003cusize\u003e,\r\n    ///The current locs (locations of the alias characters)\r\n    pub locs: Option\u003cVec\u003cusize\u003e\u003e,\r\n    /// the global index (with multiple input buffers)\r\n    pub global_index: usize,\r\n    /// reference to static AliasData\r\n    pub aliases: \u0026'a AliasData,\r\n    pub full_text: \u0026'a [u8],\r\n}\r\n\r\n///a slice of the input text\r\n#[derive(PartialEq)]\r\npub struct Slice\u003c'a\u003e {\r\n    ///the string itself\r\n    pub str: \u0026'a [u8],\r\n    ///the position relative to the buffer\r\n    pub pos: usize,\r\n}\r\n\r\n///Slice Debug impl\r\nimpl\u003c'a\u003e fmt::Debug for Slice\u003c'a\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        f.debug_struct(\"Slice\")\r\n            .field(\"str\", \u0026String::from_utf8_lossy(\u0026self.str))\r\n            .field(\"pos\", \u0026self.pos)\r\n            .finish()\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e Slice\u003c'a\u003e {\r\n    ///the length of the slice\r\n    ///the same as .str.len()\r\n    pub fn len(\u0026self) -\u003e usize {\r\n        self.str.len()\r\n    }\r\n    ///the end of the slice relative to the buffer\r\n    pub fn end(\u0026self) -\u003e usize {\r\n        self.pos + self.str.len()\r\n    }\r\n    ///returns a new slice that is shortened by offset\r\n    pub fn offset(\u0026self, offset: usize) -\u003e Slice {\r\n        Slice {\r\n            str: \u0026self.str[offset..],\r\n            pos: self.pos + offset,\r\n        }\r\n    }\r\n}\r\n\r\n///the chars that are counted as being part of words\r\nconst OTHER_CHARS: \u0026[u8] = b\"-+^/'\";\r\n///can the char be part of a word\r\nfn is_valid_word_char(char: u8) -\u003e bool {\r\n    char.is_ascii_alphanumeric() || OTHER_CHARS.contains(\u0026char)\r\n}\r\n\r\n///chars that close functions\r\nconst END_CHARS: \u0026[u8] = b\".?!,:\";\r\n///can the char close a command\r\nfn is_valid_close_char(char: u8) -\u003e bool {\r\n    END_CHARS.contains(\u0026char)\r\n}\r\n\r\n///the chars that are returned single but are not closes\r\nconst NON_CLOSE_CHARS: \u0026[u8] = b\"\\\"\u0026\";\r\n///shoudl the char be made into a 1 len slice\r\npub fn is_non_close_but_still_single(char: u8) -\u003e bool {\r\n    NON_CLOSE_CHARS.contains(\u0026char)\r\n}\r\n\r\n/// does slice consist of a closing character\r\npub fn is_close(slice: \u0026Slice) -\u003e bool {\r\n    // does str close something\r\n    get_close_data(slice.str).close_length != 0\r\n}\r\n\r\n/// For when a close is forced rather than able.\r\npub fn is_mandatory_close(slice: \u0026Slice) -\u003e bool {\r\n    let cd = get_close_data(slice.str);\r\n    cd.close_length != 0 \u0026\u0026 !cd.only_forced\r\n}\r\n\r\n///get the next valid word and the rest of the string as decided by is_valid_word_char()\r\n///returns (word,rest)\r\npub fn get_next_word\u003c'a\u003e(slice: \u0026Slice\u003c'a\u003e, mut start: usize) -\u003e (Slice\u003c'a\u003e, Slice\u003c'a\u003e) {\r\n    // find start of word\r\n    start = start.min(slice.len());\r\n    while start \u003c slice.len() \u0026\u0026 !is_valid_word_char(slice.str[start]) {\r\n        start += 1;\r\n    }\r\n\r\n    // find end of word\r\n    let mut end = start;\r\n    while end \u003c slice.len() \u0026\u0026 is_valid_word_char(slice.str[end]) {\r\n        end += 1;\r\n    }\r\n\r\n    (\r\n        Slice {\r\n            str: \u0026slice.str[start..end],\r\n            pos: slice.pos + start,\r\n        },\r\n        Slice {\r\n            str: \u0026slice.str[end..],\r\n            pos: slice.pos + end,\r\n        },\r\n    )\r\n}\r\npub struct CloseData {\r\n    pub close_count: u8,\r\n    pub close_length: u8,\r\n    pub only_forced: bool,\r\n}\r\n/// gets the number of times the characters at line[index] should be repeated and the offset after\r\n/// returns (repeat_count,offset)\r\npub fn get_close_data(line: \u0026[u8]) -\u003e CloseData {\r\n    if line.len() \u003e= 3 \u0026\u0026 line[..3] == b\"...\"[..] {\r\n        CloseData {\r\n            close_count: 10,\r\n            close_length: 3,\r\n            only_forced: false,\r\n        }\r\n    } else if line.len() \u003e= 3 \u0026\u0026 line[..3] == b\"---\"[..] {\r\n        CloseData {\r\n            close_count: 3,\r\n            close_length: 3,\r\n            only_forced: false,\r\n        }\r\n    } else if line.len() \u003e= 2 \u0026\u0026 line[..2] == b\"--\"[..] {\r\n        CloseData {\r\n            close_count: 2,\r\n            close_length: 2,\r\n            only_forced: false,\r\n        }\r\n    } else if line.len() \u003e= 1 {\r\n        match line[0] {\r\n            b'.' | b':' =\u003e CloseData {\r\n                close_count: 1,\r\n                close_length: 1,\r\n                only_forced: false,\r\n            },\r\n            b',' | b';' =\u003e CloseData {\r\n                close_count: 1,\r\n                close_length: 1,\r\n                only_forced: true,\r\n            },\r\n            b'?' | b'!' =\u003e CloseData {\r\n                close_count: 2,\r\n                close_length: 1,\r\n                only_forced: false,\r\n            },\r\n            _ =\u003e CloseData {\r\n                close_count: 0,\r\n                close_length: 0,\r\n                only_forced: false,\r\n            },\r\n        }\r\n    } else {\r\n        CloseData {\r\n            close_count: 0,\r\n            close_length: 0,\r\n            only_forced: false,\r\n        }\r\n    }\r\n}\r\n\r\n///gets the next slice. a slice consists of either a word or a closing character\r\npub fn get_next_slice\u003c'a\u003e(slice: \u0026Slice\u003c'a\u003e, mut start: usize) -\u003e (Slice\u003c'a\u003e, Slice\u003c'a\u003e) {\r\n    // find start of word\r\n    start = start.min(slice.len());\r\n    while start \u003c slice.len()\r\n        \u0026\u0026 !is_valid_word_char(slice.str[start])\r\n        \u0026\u0026 !is_valid_close_char(slice.str[start])\r\n        \u0026\u0026 !is_non_close_but_still_single(slice.str[start])\r\n    {\r\n        start += 1;\r\n    }\r\n\r\n    // find end of word\r\n    let mut end = start;\r\n\r\n    let close_data = get_close_data(\u0026slice.str[start..]);\r\n    if close_data.close_length != 0 {\r\n        end += close_data.close_length as usize;\r\n    } else if end \u003c slice.len() \u0026\u0026 is_non_close_but_still_single(slice.str[start]) {\r\n        end += 1;\r\n    } else {\r\n        while end \u003c slice.len() \u0026\u0026 is_valid_word_char(slice.str[end]) {\r\n            end += 1;\r\n        }\r\n    }\r\n\r\n    (\r\n        Slice {\r\n            str: \u0026slice.str[start..end],\r\n            pos: slice.pos + start,\r\n        },\r\n        Slice {\r\n            str: \u0026slice.str[end..],\r\n            pos: slice.pos + end,\r\n        },\r\n    )\r\n}\r\n\r\n/// returns the rest after the end of the word\r\npub fn find_word_end\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, start: usize) -\u003e Slice\u003c'a\u003e {\r\n    // find end of word\r\n\r\n    let mut end = start.min(slice.len());\r\n    while end \u003c slice.len() \u0026\u0026 is_valid_word_char(slice.str[end]) {\r\n        end += 1;\r\n    }\r\n    //let test = end \u003c slice.len();\r\n    //end = end.min(slice.len());\r\n    Slice {\r\n        str: \u0026slice.str[end..],\r\n        pos: slice.pos + end,\r\n    }\r\n}\r\n\r\n/// returns (close, rest) after finding close\r\npub fn find_close_slice\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, mut start: usize) -\u003e Option\u003c(Slice, Slice)\u003e {\r\n    // find end char\r\n    let mut close_len = 0;\r\n    while start \u003c slice.len() {\r\n        close_len = get_close_data(\u0026slice.str[start..]).close_length;\r\n        if close_len == 0 {\r\n            start += 1;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if start \u003c slice.len() {\r\n        // find end of period\r\n        let end = start + close_len as usize;\r\n        Some((\r\n            Slice {\r\n                str: \u0026slice.str[start..end],\r\n                pos: slice.pos + start,\r\n            },\r\n            Slice {\r\n                str: \u0026slice.str[end..],\r\n                pos: slice.pos + end,\r\n            },\r\n        ))\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n/// returns the rest after finding the next closing character\r\npub fn find_close\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, start: usize) -\u003e Option\u003cSlice\u003c'_\u003e\u003e {\r\n    find_close_slice(slice, start).map(|s| s.1)\r\n}\r\n\r\npub fn get_var_name_and_skips(word: \u0026[u8]) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n    let mut name = Vec::new();\r\n    let mut skips = Vec::new();\r\n    for j in 0..word.len() {\r\n        if word[j] == b'\\'' {\r\n            skips.push(j as u8);\r\n        } else {\r\n            name.push(word[j].to_ascii_lowercase());\r\n        }\r\n    }\r\n    (name, skips)\r\n}\r\n\r\npub fn try_get_symbol_word(word: \u0026Slice, global_index: usize) -\u003e Option\u003cSubStrData\u003e {\r\n    if word.len() \u003e= 3\r\n        \u0026\u0026 word.len() \u003c= 255\r\n        \u0026\u0026 !is_close(word)\r\n        \u0026\u0026 !is_non_close_but_still_single(word.str[0])\r\n    {\r\n        let (name, skip_indexes) = get_var_name_and_skips(word.str);\r\n\r\n        // vars cant be empty\r\n        if name.is_empty() {\r\n            None\r\n        } else {\r\n            Some(SubStrData {\r\n                start: global_index + word.pos,\r\n                name,\r\n                skip_indexes,\r\n            })\r\n        }\r\n    } else {\r\n        None\r\n    }\r\n}\r\n///get a slice that starts at the next \\n\r\npub fn find_newline\u003c'a\u003e(slice: \u0026'a Slice\u003c'a\u003e, mut start: usize) -\u003e Option\u003cSlice\u003c'_\u003e\u003e {\r\n    while start \u003c slice.len() {\r\n        let char = slice.str[start];\r\n        if char == b'\\n' {\r\n            break;\r\n        } else {\r\n            start += 1;\r\n        }\r\n    }\r\n\r\n    if start \u003c slice.len() {\r\n        let end = start;\r\n        Some(Slice {\r\n            str: \u0026slice.str[start..end],\r\n            pos: slice.pos + start,\r\n        })\r\n    } else {\r\n        None\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":12177733392409821184}},{"line":16,"address":[],"length":0,"stats":{"Line":12177733392409821184}},{"line":17,"address":[],"length":0,"stats":{"Line":12177733392409821184}},{"line":18,"address":[],"length":0,"stats":{"Line":1441151880758558773}},{"line":19,"address":[],"length":0,"stats":{"Line":7710162562058289205}},{"line":21,"address":[],"length":0,"stats":{"Line":1224979098644774969}},{"line":23,"address":[],"length":0,"stats":{"Line":4107282860161892350}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":28,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":29,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":30,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":35,"address":[],"length":0,"stats":{"Line":12177733392409821237}},{"line":38,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":39,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":40,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":41,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":44,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":48,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":49,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":50,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":52,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":54,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":58,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":59,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":64,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":70,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":14987979559889010680}},{"line":75,"address":[],"length":0,"stats":{"Line":14987979559889010680}},{"line":77,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":78,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":80,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":81,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":82,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":83,"address":[],"length":0,"stats":{"Line":1585267068834414600}},{"line":86,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":100,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":102,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":105,"address":[],"length":0,"stats":{"Line":15492382718154506241}},{"line":106,"address":[],"length":0,"stats":{"Line":15492382718154506241}},{"line":107,"address":[],"length":0,"stats":{"Line":15492382718154506241}},{"line":109,"address":[],"length":0,"stats":{"Line":1224979098644774913}},{"line":110,"address":[],"length":0,"stats":{"Line":1224979098644774913}},{"line":111,"address":[],"length":0,"stats":{"Line":1224979098644774913}},{"line":113,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":114,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":116,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":117,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":119,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":120,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":121,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":123,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":124,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":125,"address":[],"length":0,"stats":{"Line":2017612633061982209}},{"line":126,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":135,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":136,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":137,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":138,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":142,"address":[],"length":0,"stats":{"Line":7421932185906577410}},{"line":144,"address":[],"length":0,"stats":{"Line":7421932185906577410}},{"line":145,"address":[],"length":0,"stats":{"Line":144115188075855876}},{"line":146,"address":[],"length":0,"stats":{"Line":7421932185906577410}},{"line":147,"address":[],"length":0,"stats":{"Line":1008806316530991110}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":16068843470457929734}},{"line":164,"address":[],"length":0,"stats":{"Line":16068843470457929734}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":177,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":178,"address":[],"length":0,"stats":{"Line":44}},{"line":181,"address":[],"length":0,"stats":{"Line":15636497906230362068}},{"line":182,"address":[],"length":0,"stats":{"Line":15636497906230362068}},{"line":183,"address":[],"length":0,"stats":{"Line":15636497906230362068}},{"line":185,"address":[],"length":0,"stats":{"Line":44}},{"line":186,"address":[],"length":0,"stats":{"Line":44}},{"line":188,"address":[],"length":0,"stats":{"Line":44}},{"line":189,"address":[],"length":0,"stats":{"Line":44}},{"line":190,"address":[],"length":0,"stats":{"Line":44}},{"line":191,"address":[],"length":0,"stats":{"Line":44}},{"line":194,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":276,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":277,"address":[],"length":0,"stats":{"Line":16068843470457929728}},{"line":355,"address":[],"length":0,"stats":{"Line":6413125869375586305}},{"line":359,"address":[],"length":0,"stats":{"Line":3026418949592973316}},{"line":360,"address":[],"length":0,"stats":{"Line":3026418949592973316}},{"line":363,"address":[],"length":0,"stats":{"Line":3386706919782612994}},{"line":364,"address":[],"length":0,"stats":{"Line":3386706919782612994}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":2}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":485,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":488,"address":[],"length":0,"stats":{"Line":474}},{"line":489,"address":[],"length":0,"stats":{"Line":474}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":15924728282382073856}},{"line":504,"address":[],"length":0,"stats":{"Line":16140901064495857406}},{"line":510,"address":[],"length":0,"stats":{"Line":17077649786988921032}},{"line":511,"address":[],"length":0,"stats":{"Line":17077649786988921032}},{"line":517,"address":[],"length":0,"stats":{"Line":2089670227099910168}},{"line":518,"address":[],"length":0,"stats":{"Line":2089670227099910168}},{"line":522,"address":[],"length":0,"stats":{"Line":16573246628723425334}},{"line":524,"address":[],"length":0,"stats":{"Line":16573246628723425334}},{"line":528,"address":[],"length":0,"stats":{"Line":13402712491054596097}},{"line":529,"address":[],"length":0,"stats":{"Line":13402712491054596097}},{"line":530,"address":[],"length":0,"stats":{"Line":936748722493063169}},{"line":535,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":537,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":538,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":539,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":543,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":544,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":545,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":549,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":550,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":551,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":553,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":554,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":555,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":566,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":567,"address":[],"length":0,"stats":{"Line":2522015791327477812}},{"line":573,"address":[],"length":0,"stats":{"Line":11313042263954685917}},{"line":579,"address":[],"length":0,"stats":{"Line":13690942867206307839}},{"line":585,"address":[],"length":0,"stats":{"Line":3674937295934324694}},{"line":586,"address":[],"length":0,"stats":{"Line":9799832789158199246}},{"line":618,"address":[],"length":0,"stats":{"Line":17582052945254416425}},{"line":620,"address":[],"length":0,"stats":{"Line":17582052945254416425}},{"line":621,"address":[],"length":0,"stats":{"Line":15564440312192434261}},{"line":622,"address":[],"length":0,"stats":{"Line":3386706919782613058}},{"line":623,"address":[],"length":0,"stats":{"Line":17077649786988920891}},{"line":624,"address":[],"length":0,"stats":{"Line":17654110539292344347}},{"line":626,"address":[],"length":0,"stats":{"Line":16429131440647569452}},{"line":630,"address":[],"length":0,"stats":{"Line":17582052945254416446}},{"line":632,"address":[],"length":0,"stats":{"Line":17582052945254416446}},{"line":633,"address":[],"length":0,"stats":{"Line":17942340915444056126}},{"line":634,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":635,"address":[],"length":0,"stats":{"Line":5404319552844595274}},{"line":636,"address":[],"length":0,"stats":{"Line":1224979098644774917}},{"line":638,"address":[],"length":0,"stats":{"Line":16861477004875137202}},{"line":639,"address":[],"length":0,"stats":{"Line":5260204364768739360}},{"line":644,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":645,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":646,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":648,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":649,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":650,"address":[],"length":0,"stats":{"Line":17582052945254416421}},{"line":656,"address":[],"length":0,"stats":{"Line":864691128455135401}},{"line":659,"address":[],"length":0,"stats":{"Line":864691128455135401}},{"line":660,"address":[],"length":0,"stats":{"Line":2233785415175766354}},{"line":661,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":666,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":667,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":672,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":674,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":675,"address":[],"length":0,"stats":{"Line":6269010681299730433}},{"line":676,"address":[],"length":0,"stats":{"Line":5260204364768739329}},{"line":677,"address":[],"length":0,"stats":{"Line":11673330234144325634}},{"line":678,"address":[],"length":0,"stats":{"Line":6413125869375586305}},{"line":680,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":683,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":685,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":686,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":687,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":688,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":689,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":691,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":692,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":693,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":697,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":10016005571271983105}},{"line":707,"address":[],"length":0,"stats":{"Line":10016005571271983105}},{"line":708,"address":[],"length":0,"stats":{"Line":10016005571271983105}},{"line":709,"address":[],"length":0,"stats":{"Line":3746994889972252728}},{"line":710,"address":[],"length":0,"stats":{"Line":17726168133330272529}},{"line":711,"address":[],"length":0,"stats":{"Line":5548434740920451290}},{"line":713,"address":[],"length":0,"stats":{"Line":6629298651489369949}},{"line":716,"address":[],"length":0,"stats":{"Line":10016005571271983159}},{"line":719,"address":[],"length":0,"stats":{"Line":16501189034685497344}},{"line":720,"address":[],"length":0,"stats":{"Line":16501189034685497344}},{"line":721,"address":[],"length":0,"stats":{"Line":16285016252571713537}},{"line":722,"address":[],"length":0,"stats":{"Line":16285016252571713537}},{"line":723,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":725,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":728,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":732,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":733,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":734,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":738,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":742,"address":[],"length":0,"stats":{"Line":1}},{"line":743,"address":[],"length":0,"stats":{"Line":1}},{"line":744,"address":[],"length":0,"stats":{"Line":1}},{"line":745,"address":[],"length":0,"stats":{"Line":1}},{"line":746,"address":[],"length":0,"stats":{"Line":1}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":1}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":1}}],"covered":202,"coverable":224},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","playground.rs"],"content":"use crate::{\r\n    commands::{Expr, ExprArena},\r\n    parser::{Parser, ParserSource},\r\n    writers::{syntax_lint::SyntaxLinter, syntax_renderers::wind_renderer::WindowsRenderer},\r\n};\r\n\r\n// pub fn print_test() {\r\n//     let source = ParserSource::from_string(\"was test num . seven ..\".into());\r\n//     let exp1 = ExprArena {\r\n//         vec: vec![\r\n//             Expr::Assign {\r\n//                 locs: vec![0, 1, 2],\r\n//                 name_start: 4,\r\n//                 name: \"test\".into(),\r\n//                 value_index: 1,\r\n//                 end: 22,\r\n//             },\r\n//             Expr::WordNum {\r\n//                 locs: vec![9, 10, 11],\r\n//                 str_start: 13,\r\n//                 str: \".\".into(),\r\n//                 end: 21,\r\n//             },\r\n//         ],\r\n//     };\r\n//     let exp2 = ExprArena {\r\n//         vec: vec![\r\n//             Expr::Assign {\r\n//                 locs: vec![0, 1, 2],\r\n//                 name_start: 4,\r\n//                 name: \"test\".into(),\r\n//                 value_index: 1,\r\n//                 end: 22,\r\n//             },\r\n//             Expr::WordNum {\r\n//                 locs: vec![9, 10, 11],\r\n//                 str_start: 15,\r\n//                 str: \"seven\".into(),\r\n//                 end: 21,\r\n//             },\r\n//         ],\r\n//     };\r\n//     let exp3 = ExprArena {\r\n//         vec: vec![\r\n//             Expr::Assign {\r\n//                 locs: vec![0, 1, 2],\r\n//                 name_start: 4,\r\n//                 name: \"test\".into(),\r\n//                 value_index: 1,\r\n//                 end: 21,\r\n//             },\r\n//             Expr::MultiLitNum {\r\n//                 locs: vec![],\r\n//                 str_start: 15,\r\n//                 str_length: 5,\r\n//                 value: 7,\r\n//                 end: usize::MAX,\r\n//             },\r\n//         ],\r\n//     };\r\n//     let exps = vec![exp1, exp2, exp3];\r\n//     for exp in exps {\r\n//         let mut lint = SyntaxLinter::\u003cWindowsRenderer\u003e::new();\r\n//         lint.write(\u0026exp, \u0026[0], source.get_iter());\r\n//         println!(\"{}\", std::str::from_utf8(\u0026lint.into_string()).unwrap());\r\n//     }\r\n// }\r\n\r\npub fn size_test() {}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","mod.rs"],"content":"mod test_word_funcs;\r\n\r\nmod parsing_tests_simple;\r\nmod test_assign_vars;\r\nmod test_closing;\r\nmod test_if_while;\r\nmod test_lit_int;\r\nmod test_numbers;\r\nmod test_operators;\r\nmod test_print;\r\nmod test_colors;\r\n\r\nmod testing;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","parsing_tests_simple.rs"],"content":"#[cfg(test)]\r\nmod tests_simple {\r\n    use ntest::timeout;\r\n\r\n    // use crate::parser::*;\r\n    use crate::testing::*;\r\n\r\n\r\n   \r\n\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_for_each() {\r\n        let data = run_parser!(b\"fre value lis 1 2 3. pri value..\");\r\n         check_lisp!(data,\r\n            \"(foreach@0,1,2$31 value (list@10,11,12$19 (litnum 1@14$$1) (litnum 2@16$$1) (litnum 3@18$$1)) then:\\\r\n            \\n  (print@21,22,23$30 (var \\\"value\\\"@25))\\n)\"\r\n        );\r\n    }\r\n\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_ret_out_of_function() {\r\n        let data = run_parser!(b\"fun func. ret one! ret. pri hello. ret. func.\");\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$17 \\\"func\\\"@4 (args) (return@10,11,12$17 (litnum 1@14$$3)))\\n(print@24,25,26$33 \\\"hello\\\"@28)\\n(\\\"func\\\"@40 )\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_0_arg_function() {\r\n        let data = run_parser!(b\"fun F'unc'. pri hi... fun'c.\");\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$18$$3 \\\"func\\\"@4|1,5 (args) (print@12,13,14$18$$3 \\\"hi\\\"@16))\\n(\\\"func\\\"@22|3 )\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_multi_arg_function() {\r\n        let data = run_parser!(b\"fun 'cause can't 'cause 'w'ow. p'ri hi! 'cause one two three. \\\r\n        c'a'us'e one two. cause one. cause.\"\r\n            );\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$38 \\\"cause\\\"@4|0 (args \\\"cant\\\"@11|3 \\\"wow\\\"@24|0,2) \\\r\n            (print@31,33,34$38 \\\"hi\\\"@36))\\n(\\\"cause\\\"@41 (litnum 1@47$$3) (litnum 2@51$$3))\\n\\\r\n            (\\\"cause\\\"@62|1,3 (litnum 1@71$$3) (litnum 2@75$$3))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_infinite_loop_function() {\r\n        let data = run_parser!(\r\n            b\"fun in'finite. infi'n'ite... 'infinite'? pri \\\"this will never print\\\".\");\r\n         check_lisp!(data,\r\n            \"(function@0,1,2$25$$3 \\\"infinite\\\"@4|2 (args) (\\\"infinite\\\"@15|4,6 ))\\n\\\r\n            (\\\"infinite\\\"@30|8 )\\n(print@41,42,43$68 \\\"this will never print\\\"@45)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_function_fail() {\r\n        let data = run_parser!(b\"fun func. pri hi.\");\r\n         check_lisp!(data,\r\n            \"(function@4,5,6$16 \\\"pri\\\"@10 (args) )\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_line_4() {\r\n        let data = run_parser!( b\"lin one two three four!\");\r\n         check_lisp!(data,\r\n            \"(line@0,1,2$22 (litnum 1@4$$3) (litnum 2@8$$3) (litnum 3@12$$5) (litnum 4@18$$4))\"\r\n        );\r\n    }\r\n    \r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_double_newline() {\r\n        let data = run_parser!( b\"was twelve\\ntwo.\\nwas twelve\\n\\ntwo.\");\r\n         check_lisp!(data,\r\n            \"(assign@0,1,2$14 \\\"twelve\\\"@4 (litnum 2@11$$3))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_assign_vars.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_was_one_letter_var() {\r\n        let data = run_parser!(b\"was a mario two.\");\r\n        check_lisp!(data, \"(assign@0,1,2$15 \\\"mario\\\"@6 (litnum 2@12$$3))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_var_apostrophes() {\r\n        let data = run_parser!(b\"wasn't 'cause one. was only b'e'ca'use'.\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@0,1,2$17 \\\"cause\\\"@7|0 (litnum 1@14$$3))\\n\\\r\n            (assign@19,20,21$39 \\\"only\\\"@23 (var \\\"cause\\\"@32|2))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_varible_substrings() {\r\n        let data = run_parser!(\r\n            b\"was cat one. was car cat. was car car. was cart cater. was cater handcarts.\"\r\n        );\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@0,1,2$11 \\\"cat\\\"@4 (litnum 1@8$$3))\\n\\\r\n            (assign@13,14,15$24 \\\"car\\\"@17 (var \\\"cat\\\"@21))\\n\\\r\n            (assign@26,27,28$37 mut \\\"car\\\"@30 (var \\\"car\\\"@34))\\n\\\r\n            (assign@39,40,41$53 \\\"cart\\\"@43 (var \\\"cat\\\"@48))\\n\\\r\n            (assign@55,56,57$74 \\\"cater\\\"@59 (var \\\"cart\\\"@69))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    // #[timeout(1000)]\r\n    fn test_assign_no_end() {\r\n        let data = run_parser!(b\"was cat one. was car two\");\r\n        check_lisp!(data, \"(assign@0,1,2$11 \\\"cat\\\"@4 (litnum 1@8$$3))\");\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_closing.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_ellipsis_6_close() {\r\n        let data = run_parser!(b\"It was sub sub sub sub sub sub one...\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@3,4,5$34$$3 \\\"sub\\\"@7 (-@11,12,13$34$$3 (-@15,16,17$34$$3 \\\r\n            (-@19,20,21$34$$3 (-@23,24,25$34$$3 (-@27,28,29$34$$3 (litnum 1@31$$3)))))))\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_2_peirod() {\r\n        let data = run_parser!(b\"It was sub sub one..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@3,4,5$19 \\\"sub\\\"@7 (-@11,12,13$18 (litnum 1@15$$3)))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_ellipsis_overload_12() {\r\n        let data = run_parser!(b\"It was sub sub sub sub sub sub sub sub sub sub sub sub one......\");\r\n        check_lisp!(data,\r\n            \"(assign@3,4,5$61$$3 \\\"sub\\\"@7 (-@11,12,13$61$$3 (-@15,16,17$58$$3 (-@19,20,21$58$$3 (-@23,24,25$58$$3 \\\r\n            (-@27,28,29$58$$3 (-@31,32,33$58$$3 (-@35,36,37$58$$3 (-@39,40,41$58$$3 (-@43,44,45$58$$3 \\\r\n            (-@47,48,49$58$$3 (-@51,52,53$58$$3 (litnum 1@55$$3)))))))))))))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_colors.rs"],"content":"#[cfg(test)]\r\nmod test_colors {\r\n    use std::collections::HashSet;\r\n\r\n    use crate::{parser::foreach, testing::*};\r\n    use bstr::ByteSlice;\r\n    use itertools::Itertools;\r\n    use ntest::timeout;\r\n\r\n    const COLOR_STR: \u0026[u8] = include_bytes!(\"colors.txt\");\r\n\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_correct_colors_separate() {\r\n        for line in COLOR_STR.lines() {\r\n            let mut str = b\"was mario \".to_vec();\r\n            str.extend_from_slice(line);\r\n            str.push(b'.');\r\n            let no_spaces = line.replace(b\" \", b\"\");\r\n\r\n            let length = line.len();\r\n            let data = run_parser!(\u0026str);\r\n            check_lisp!(\r\n                data,\r\n                format!(\r\n                    \"(assign@0,1,2${} \\\"mario\\\"@4 (litcol {}@10$${}))\",\r\n                    length + 10,\r\n                    std::str::from_utf8(\u0026no_spaces).unwrap(),\r\n                    length\r\n                ),\r\n                format!(\"testing: {}\", std::str::from_utf8(line).unwrap())\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_correct_colors_together() {\r\n        for line in COLOR_STR.lines() {\r\n            let spaces = line.find_iter(b\" \").powerset();\r\n            for curr_spaces in spaces {\r\n                let mut str = b\"was mario \".to_vec();\r\n                let mut curr_color = line.to_vec();\r\n                for space in curr_spaces.into_iter().rev() {\r\n                    curr_color.remove(space);\r\n                }\r\n                str.extend_from_slice(\u0026curr_color);\r\n                str.push(b'.');\r\n                let no_spaces = line.replace(b\" \", b\"\");\r\n\r\n                let length = curr_color.len();\r\n                let data = run_parser!(\u0026str);\r\n                check_lisp!(\r\n                    data,\r\n                    format!(\r\n                        \"(assign@0,1,2${} \\\"mario\\\"@4 (litcol {}@10$${}))\",\r\n                        length + 10,\r\n                        std::str::from_utf8(\u0026no_spaces).unwrap(),\r\n                        length\r\n                    ),\r\n                    format!(\"testing: {}\", std::str::from_utf8(\u0026curr_color).unwrap())\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//     fn test_incorrect_colors(num: u8) {\r\n//         let mut correct = HashSet::new();\r\n//         let mut words = HashSet::new();\r\n//         for line in COLOR_STR.lines() {\r\n//             correct.insert(line.replace(b\" \", b\"\"));\r\n//             for word in line.split_str(b\" \") {\r\n//                 words.insert(word);\r\n//             }\r\n//         }\r\n//         println!(\r\n//             \"words: {:?}\",\r\n//             correct\r\n//                 .iter()\r\n//                 .map(|str| std::str::from_utf8(str).unwrap())\r\n//                 .collect::\u003cVec\u003c_\u003e\u003e()\r\n//         );\r\n//         let perms = words.iter().permutations(num.into());\r\n//         let perms_vec = perms.clone().count();\r\n//         println!(\"length: {}\", perms_vec);\r\n//         for (index, color) in perms.enumerate() {\r\n//             let no_spaces = color\r\n//                 .iter()\r\n//                 .flat_map(|str| str.into_iter().cloned())\r\n//                 .collect::\u003cVec\u003c_\u003e\u003e();\r\n//             if !correct.contains(\u0026no_spaces) {\r\n//                 println!(\"{}:{}\", index, std::str::from_utf8(\u0026no_spaces).unwrap())\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     #[test]\r\n//     #[timeout(1000)]\r\n//     fn test_incorrect_colors_1() {\r\n//         test_incorrect_colors(1);\r\n//     }\r\n// }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_if_while.rs"],"content":"#[cfg(test)]\r\nmod tests_lit_int {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_else_pri() {\r\n        let data = run_parser!(b\"whe one pri yes! else pri no:(:(\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$15 (litnum 1@4$$3) then:\\n  (print@8,9,10$15 \\\"yes\\\"@12)\\n)\\n(else@17,18,19$30\\\r\n            \\n  (print@22,23,24$28 \\\"no\\\"@26)\\n)\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_space_else_pri() {\r\n        let data = run_parser!(b\"whe one pri yes. Or. pri maybe. Else pri no:( sadge :(\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$19 (litnum 1@4$$3) then:\\n  (print@8,9,10$15 \\\"yes\\\"@12)\\n)\\n(print@21,22,23$30 \\\"maybe\\\"@25)\\n(print@37,38,39$43 \\\"no\\\"@41)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_space_else_rect() {\r\n        let data =\r\n            run_parser!(b\"whe one pri yes! Recording one two. Else pri no:( double sadge :(\");\r\n        check_lisp!(\r\n            data,\r\n            \"(if@0,1,2$15 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$15 \\\"yes\\\"@12)\\n)\\n\\\r\n            (rect@17,18,19$34 (litnum 1@27$$3) (litnum 2@31$$3))\\n\\\r\n            (print@41,42,43$47 \\\"no\\\"@45)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_else_past() {\r\n        let data = run_parser!(b\"whels one whi one pri hi..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(while@10,11,12$25 (litnum 1@14$$3) then:\\n  (print@18,19,20$24 \\\"hi\\\"@22)\\n)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_double_else() {\r\n        let data = run_parser!(b\"whe one pri good.. els els pri bad...\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$17 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$16 \\\"good\\\"@12)\\n)\\n\\\r\n            (else@19,20,21$34$$3\\n  (print@27,28,29$34$$3 \\\"bad\\\"@31)\\n)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_double_else_last() {\r\n        let data = run_parser!(b\"whe one pri good.. els pri bad. els...\");\r\n        check_lisp!(data,\r\n            \"(if@0,1,2$17 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$16 \\\"good\\\"@12)\\n)\\n\\\r\n            (else@19,20,21$35$$3\\n  (print@23,24,25$30 \\\"bad\\\"@27)\\n)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_else_simple() {\r\n        let data = run_parser!(b\"whe one pri one. pri two.. els pri three. pri four..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(if@0,1,2$25 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$15 (litnum 1@12$$3))\\n  \\\r\n            (print@17,18,19$24 (litnum 2@21$$3))\\n)\\n\\\r\n            (else@27,28,29$51\\n  \\\r\n            (print@31,32,33$40 (litnum 3@35$$5))\\n  \\\r\n            (print@42,43,44$50 (litnum 4@46$$4))\\n)\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_if_inside_fail() {\r\n        let data = run_parser!(b\"whe one pri one. els. whe one els. pri two..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(if@0,1,2$20 (litnum 1@4$$3) then:\\n  \\\r\n            (print@8,9,10$15 (litnum 1@12$$3))\\n)\\n\\\r\n            (if@22,23,24$43 (litnum 1@26$$3) then:\\n  \\\r\n            (print@35,36,37$42 (litnum 2@39$$3))\\n)\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_lit_int.rs"],"content":"#[cfg(test)]\r\nmod tests_lit_int {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_wizards_with_double_close() {\r\n        let data = run_parser!(b\"The wizards were literally nine at most!\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@4,7,10$39 \\\"were\\\"@12 (litnum@17,18,19$39 924))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_wizards_with_double_close_ellipsis() {\r\n        let data = run_parser!(b\"The wizards were literally nine at most...\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@4,7,10$39$$3 \\\"were\\\"@12 (litnum@17,18,19$39$$3 924))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_lit_zero() {\r\n        let data = run_parser!(b\"The wizards were literally...\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@4,7,10$26$$3 \\\"were\\\"@12 (litnum@17,18,19$26$$3 0))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_lit_close_early() {\r\n        let data = run_parser!(b\"It was nice int. nice two..\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@3,4,5$26 \\\"nice\\\"@7 (wordnum@12,13,14$25 4@17))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_multilitnum_overflow_fail() {\r\n        let data = run_parser!(\r\n            b\"was having little or no money in my purse, and nothing particular to interest me on shore, \\\r\n            I thought I would sail about a little and see the watery part of the world!\");\r\n        check_lisp!(data,\r\n            \"(assign@0,1,2$165 \\\"having\\\"@4 \\\r\n            (multilitnum@11,12,13$165 2 2 5 2 2 5 1 3 7 0 2 8 2 2 5 1 1 7 1 5 4 5 1 6 3 3 3 6 4 2 3 5))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_in_word_hyphen() {\r\n        let data = run_parser!(b\"I was about to learn in-depth mathematics -- It was crazy!\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@2,3,4$42$$2 \\\"about\\\"@6 (wordnum@21,22,27$42$$2 11@30))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_word_no_close() {\r\n        let data = run_parser!(b\"I was two two. was into a two\");\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@2,3,4$13 \\\"two\\\"@6 (litnum 2@10$$3))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_numbers.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n    \r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn set_var_to_seven() {\r\n        let data = run_parser!(b\"I was going to be seventy.\");\r\n        check_lisp!(data, \"(assign@2,3,4$25 \\\"going\\\"@6 (litnum 70@18$$7))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn set_var_to_seven_with_ellipsis() {\r\n        let data = run_parser!(b\"I was always seventy-seven....\");\r\n        check_lisp!(data, \"(assign@2,3,4$26$$3 \\\"always\\\"@6 (litnum 77@13$$13))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_complicated_litnum() {\r\n        let data = run_parser!(\r\n            b\"I was always one-hundred-and-twenty-three-thousand-three-hundred-and-two....\"\r\n        );\r\n        check_lisp!(\r\n            data,\r\n            \"(assign@2,3,4$72$$3 \\\"always\\\"@6 (litnum 123302@13$$59))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_twenty_one_litnum() {\r\n        let data = run_parser!(b\"I was always twenty-one....\");\r\n        check_lisp!(data, \"(assign@2,3,4$23$$3 \\\"always\\\"@6 (litnum 21@13$$10))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_zero() {\r\n        let data = run_parser!(b\"I was always zero....\");\r\n        check_lisp!(data, \"(assign@2,3,4$17$$3 \\\"always\\\"@6 (litnum 0@13$$4))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn make_gettysburg() {\r\n        let data = run_parser!(b\"I was always four-score-and-seven....\");\r\n        check_lisp!(data, \"(assign@2,3,4$33$$3 \\\"always\\\"@6 (litnum 87@13$$20))\");\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn do_not_make_gas_station() {\r\n        let data = run_parser!(b\"I was always seven-eleven two.\");\r\n        check_lisp!(data, \"(assign@2,3,4$29 \\\"always\\\"@6 (litnum 2@26$$3))\");\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_operators.rs"],"content":"#[cfg(test)]\r\nmod tests_assign_var {\r\n    // use crate::parser::*;\r\n    // use crate::testing::*;\r\n    // use ntest::timeout;\r\n\r\n    }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_print.rs"],"content":"#[cfg(test)]\r\nmod tests_lit_int {\r\n    use crate::testing::*;\r\n    use ntest::timeout;\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_print_no_vars() {\r\n        let data = run_parser!( b\"pri hi. pri hello world. pri \\\"hello world\\\".\");\r\n         check_lisp!(data,\r\n            \"(print@0,1,2$6 \\\"hi\\\"@4)\\n(print@8,9,10$23 )\\n(print@25,26,27$42 \\\"hello world\\\"@29)\"\r\n        );\r\n    }\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_print_vars() {\r\n        let data = run_parser!( b\"was test 4. pri one test two test. pri test. pri four.\");\r\n         check_lisp!(data,\r\n            \"(assign@0,1,2$10 \\\"test\\\"@4 (litnum 4@9$$1))\\n(print@12,13,14$33 (litnum 1@16$$3) (var \\\"test\\\"@20) (litnum 2@25$$3) (var \\\"test\\\"@29))\\n(print@35,36,37$43 (var \\\"test\\\"@39))\\n(print@45,46,47$53 (litnum 4@49$$4))\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_pri_mult_str() {\r\n        let data = run_parser!( b\"pri \\\"mario\\\" \\\"luigi\\\"!\");\r\n         check_lisp!(data,\r\n            \"(print@0,1,2$19 \\\"mario\\\"@4 \\\"luigi\\\"@12)\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[timeout(1000)]\r\n    fn test_pri_varible_casing() {\r\n        let data = run_parser!(b\"was hi1 one. was HI2 two. pri hi1 Hi1 hi2 Hi2.\");\r\n         check_lisp!(data,\r\n            \"(assign@0,1,2$11 \\\"hi1\\\"@4 (litnum 1@8$$3))\\n(assign@13,14,15$24 \\\"hi2\\\"@17 (litnum 2@21$$3))\\n\\\r\n            (print@26,27,28$45 (var \\\"hi1\\\"@30) (var \\\"hi1\\\"@34) (var \\\"hi2\\\"@38) (var \\\"hi2\\\"@42))\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","test_word_funcs.rs"],"content":"#[cfg(test)]\r\nmod tests {\r\n    use crate::parser::*;\r\n    use crate::testing::test_lib::*;\r\n\r\n    // get_next_word\r\n\r\n    #[test]\r\n    fn test_get_next_word_simple() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"asdf   \", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"   \", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" asdf  \", 1), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"  \", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"  asdf \", 0), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\" \", 6))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_word_no_space_end() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"\", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 3), new_slice(\"\", 7))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"  asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 4), new_slice(\"\", 8))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_word_fails() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"\", 2), 0),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" \", 4), 0),\r\n            (new_slice(\"\", 5), new_slice(\"\", 5))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\" \", 8), 0),\r\n            (new_slice(\"\", 9), new_slice(\"\", 9))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_word_out() {\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"a \", 0), 2),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"a \", 0), 3),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_word(\u0026new_slice(\"a \", 0), 4),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n    }\r\n\r\n    // find_word_end\r\n    #[test]\r\n    fn test_find_word_end_after() {\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 0),\r\n            new_slice(\" a b c\", 0)\r\n        );\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 1),\r\n            new_slice(\" b c\", 2)\r\n        );\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 2),\r\n            new_slice(\" b c\", 2)\r\n        );\r\n        assert_eq!(\r\n            find_word_end(\u0026new_slice(\" a b c\", 0), 3),\r\n            new_slice(\" c\", 4)\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_word_end_fails() {\r\n        assert_eq!(find_word_end(\u0026new_slice(\"\", 0), 0), new_slice(\"\", 0));\r\n        assert_eq!(find_word_end(\u0026new_slice(\" \", 0), 0), new_slice(\" \", 0));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a\", 0), 0), new_slice(\"\", 1));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a \", 0), 0), new_slice(\" \", 1));\r\n        assert_eq!(find_word_end(\u0026new_slice(\" a\", 0), 0), new_slice(\" a\", 0));\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_word_end_out() {\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a \", 0), 2), new_slice(\"\", 2));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a  \", 0), 3), new_slice(\"\", 3));\r\n        assert_eq!(find_word_end(\u0026new_slice(\"a  \", 0), 4), new_slice(\"\", 3));\r\n    }\r\n\r\n    // find_end_close\r\n    #[test]\r\n    fn test_find_close_slice_only() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\".\", 0), 0),\r\n            Some((new_slice(\".\", 0), new_slice(\"\", 1)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"!\", 0), 0),\r\n            Some((new_slice(\"!\", 0), new_slice(\"\", 1)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"...\", 0), 0),\r\n            Some((new_slice(\"...\", 0), new_slice(\"\", 3)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_after() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a . b \", 0), 1),\r\n            Some((new_slice(\".\", 2), new_slice(\" b \", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a ! b \", 0), 0),\r\n            Some((new_slice(\"!\", 2), new_slice(\" b \", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a ... b \", 0), 0),\r\n            Some((new_slice(\"...\", 2), new_slice(\" b \", 5)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_touching_after() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a .b c\", 0), 0),\r\n            Some((new_slice(\".\", 3), new_slice(\"b c\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a !b c\", 0), 0),\r\n            Some((new_slice(\"!\", 3), new_slice(\"b c\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a ...b c\", 0), 0),\r\n            Some((new_slice(\"...\", 3), new_slice(\"b c\", 6)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_touching_before() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a. b c\", 0), 0),\r\n            Some((new_slice(\".\", 2), new_slice(\" b c\", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a! b c\", 0), 0),\r\n            Some((new_slice(\"!\", 2), new_slice(\" b c\", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\" a... b c\", 0), 0),\r\n            Some((new_slice(\"...\", 2), new_slice(\" b c\", 5)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_touching_both() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b.c d\", 0), 0),\r\n            Some((new_slice(\".\", 3), new_slice(\"c d\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b!c d\", 0), 0),\r\n            Some((new_slice(\"!\", 3), new_slice(\"c d\", 4)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b...c d\", 0), 0),\r\n            Some((new_slice(\"...\", 3), new_slice(\"c d\", 6)))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_find_close_slice_newline() {\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"\\n . a\", 0), 0),\r\n            Some((new_slice(\".\", 2), new_slice(\" a\", 3)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"\\n a .\", 0), 0),\r\n            Some((new_slice(\".\", 4), new_slice(\"\", 5)))\r\n        );\r\n        assert_eq!(\r\n            find_close_slice(\u0026new_slice(\"a b \\n c . d\", 0), 0),\r\n            Some((new_slice(\".\", 8), new_slice(\" d\", 9)))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_end_close_fails() {\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"\", 0), 0), None);\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a b c d\", 0), 0), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_end_close_out() {\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a \", 0), 2), None);\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a \", 0), 3), None);\r\n        assert_eq!(find_close_slice(\u0026new_slice(\"a \", 0), 4), None);\r\n    }\r\n\r\n    // get_next_slice\r\n    #[test]\r\n    fn test_get_next_slice_space_end() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"asdf   \", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"   \", 6))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" asdf  \", 1), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"  \", 6))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  asdf \", 0), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\" \", 6))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_no_space_end() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 2), new_slice(\"\", 6))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 3), new_slice(\"\", 7))\r\n        );\r\n\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  asdf\", 2), 0),\r\n            (new_slice(\"asdf\", 4), new_slice(\"\", 8))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_fails() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"\", 2), 0),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" \", 4), 0),\r\n            (new_slice(\"\", 5), new_slice(\"\", 5))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" \", 8), 0),\r\n            (new_slice(\"\", 9), new_slice(\"\", 9))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_out() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a \", 0), 2),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a \", 0), 3),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a \", 0), 4),\r\n            (new_slice(\"\", 2), new_slice(\"\", 2))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_close() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\".a\", 2), 0),\r\n            (new_slice(\".\", 2), new_slice(\"a\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" .a \", 1), 0),\r\n            (new_slice(\".\", 2), new_slice(\"a \", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  .a  \", 0), 0),\r\n            (new_slice(\".\", 2), new_slice(\"a  \", 3))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_next_slice_double_close() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"..a\", 2), 0),\r\n            (new_slice(\".\", 2), new_slice(\".a\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" ..a \", 1), 0),\r\n            (new_slice(\".\", 2), new_slice(\".a \", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  ..a  \", 0), 0),\r\n            (new_slice(\".\", 2), new_slice(\".a  \", 3))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_triple_close() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"...a\", 0), 0),\r\n            (new_slice(\"...\", 0), new_slice(\"a\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\" ...a \", 0), 0),\r\n            (new_slice(\"...\", 1), new_slice(\"a \", 4))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"  ...a  \", 0), 0),\r\n            (new_slice(\"...\", 2), new_slice(\"a  \", 5))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_close_only() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\".\", 0), 0),\r\n            (new_slice(\".\", 0), new_slice(\"\", 1))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"!\", 0), 0),\r\n            (new_slice(\"!\", 0), new_slice(\"\", 1))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"...\", 0), 0),\r\n            (new_slice(\"...\", 0), new_slice(\"\", 3))\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_get_next_slice_newline() {\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"a\\na\", 0), 0),\r\n            (new_slice(\"a\", 0), new_slice(\"\\na\", 1))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"\\naa\", 0), 0),\r\n            (new_slice(\"aa\", 1), new_slice(\"\", 3))\r\n        );\r\n        assert_eq!(\r\n            get_next_slice(\u0026new_slice(\"\\n a a\", 0), 0),\r\n            (new_slice(\"a\", 2), new_slice(\" a\", 3))\r\n        );\r\n    }\r\n    // #[test]\r\n    // fn test_get_next_slice_quotes() {\r\n    //     assert_eq!(\r\n    //         get_next_slice(\u0026new_slice(\"\\\" b\", 0), 0),\r\n    //         (new_slice(\"\\\"\", 0), new_slice(\" b\", 1))\r\n    //     );\r\n    //     assert_eq!(\r\n    //         get_next_slice(\u0026new_slice(\"\\n \\\"\\' a\", 0), 0),\r\n    //         (new_slice(\"\\\"\", 2), new_slice(\"\\' a\", 3))\r\n    //     );\r\n    //     assert_eq!(\r\n    //         get_next_slice(\u0026new_slice(\"a'b\", 0), 0),\r\n    //         (new_slice(\"a\", 0), new_slice(\"'b\", 1))\r\n    //     );\r\n    // }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","testing","testing.rs"],"content":"#![allow(dead_code)]\r\n#![allow(unused_macros)]\r\n#![allow(unused_imports)]\r\n\r\n#[cfg(test)]\r\npub mod test_lib {\r\n\r\n    use crate::commands::{Expr, ExprArena};\r\n\r\n    use crate::parser::{Parser, *};\r\n    use crate::writers::lisp_like_writer;\r\n    use alias_data::AliasData;\r\n    use std::collections::HashSet;\r\n    use std::hint;\r\n\r\n    pub fn assert_step_inner(\r\n        parser: \u0026mut Parser,\r\n        exp_result: ParserResult,\r\n        exp_state: \u0026str,\r\n        exp_word: \u0026str,\r\n        file: \u0026str,\r\n        line: u32,\r\n    ) {\r\n        let result = parser.step();\r\n        let state = parser.get_last_state_name();\r\n        let word = std::str::from_utf8(parser.get_last_word().0).unwrap();\r\n        let message = \u0026format!(\r\n            \"result was {:?}(\\\"{}\\\",\\\"{}\\\"). expected {:?}(\\\"{}\\\",\\\"{}\\\") at {}:{}\",\r\n            result, state, word, exp_result, exp_state, exp_word, file, line\r\n        );\r\n\r\n        assert_eq!(result, exp_result, \"{}\", message);\r\n        assert_eq!(state, exp_state, \"{}\", message);\r\n        assert_eq!(word, exp_word, \"{}\", message);\r\n    }\r\n\r\n    pub fn new_slice(str: \u0026str, start: usize) -\u003e Slice {\r\n        Slice {\r\n            str: str.as_ref(),\r\n            pos: start,\r\n        }\r\n    }\r\n\r\n    pub fn new_sub_slice(str: \u0026str, start: usize) -\u003e Slice {\r\n        let bytes: \u0026[u8] = str.as_ref();\r\n        Slice {\r\n            str: \u0026bytes[start..],\r\n            pos: start,\r\n        }\r\n    }\r\n\r\n    // pub fn new_env\u003c'a\u003e(\r\n    //     vars: \u0026'a mut VarSet,\r\n    //     expr: \u0026'a mut Expr,\r\n    //     locs: Option\u003cVec\u003cusize\u003e\u003e,\r\n    //     aliases: \u0026'a AliasData,\r\n    //     last_stat:Option\u003c\u0026'a mut Expr\u003e\r\n    // ) -\u003e Environment\u003c'a\u003e {\r\n    //     Environment {\r\n    //         vars,\r\n    //         expr,\r\n    //         last_stat,\r\n    //         locs,\r\n    //         global_index: 0,\r\n    //         aliases,\r\n    //     }\r\n    // }\r\n\r\n    pub fn assert_result(parser: \u0026mut Parser) -\u003e ParserResult {\r\n        loop {\r\n            let result = parser.step();\r\n            if result.is_end() {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    pub fn run_to_completion(parser: \u0026mut Parser) -\u003e ParserResult {\r\n        loop {\r\n            let result = parser.step();\r\n            if matches!(result, ParserResult::NoInput) {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn run_parser(input: Vec\u003cu8\u003e, title: bool) -\u003e ParsedData\u003c'static\u003e {\r\n        let text = hint::black_box(input).to_vec();\r\n        let mut parser = Parser::new(ParserSource::from_string(text), ParserFlags { title });\r\n        run_to_completion(\u0026mut parser);\r\n        parser.into_data()\r\n    }\r\n\r\n    pub fn get_lisp(data: \u0026ParsedData) -\u003e String {\r\n        lisp_like_writer::write(\u0026data.exprs, \u0026data.stat_starts)\r\n    }\r\n}\r\n\r\n// use crate::testing::test_lib::*;\r\n\r\nmacro_rules! add_vars {\r\n    ($parser:ident, $var:expr) =\u003e {\r\n        $parser.vars.insert($var.as_bytes().to_vec());\r\n    };\r\n    ($parser:ident, $var:expr, $($vars:expr),+) =\u003e {\r\n        $crate::testing::add_vars! ($parser, $var );\r\n        $crate::testing::add_vars! ($parser, $($vars), + );\r\n    };\r\n}\r\npub(crate) use add_vars;\r\n\r\nmacro_rules! assert_step {\r\n    ($parser:ident,$step_result:ident,$state:expr,$word:expr) =\u003e {\r\n        $crate::testing::test_lib::assert_step_inner(\r\n            \u0026mut $parser,\r\n            ParserResult::$step_result,\r\n            $state,\r\n            $word,\r\n            file!(),\r\n            line!(),\r\n        );\r\n    };\r\n}\r\n\r\npub(crate) use assert_step;\r\n\r\nmacro_rules! run_parser {\r\n    ($input:expr) =\u003e {{\r\n        $crate::testing::test_lib::run_parser($input.to_vec(), false)\r\n    }};\r\n    ($input:expr, $title:expr) =\u003e {{\r\n        $crate::testing::test_lib::run_parser($input.to_vec(), $title)\r\n    }};\r\n}\r\n\r\npub(crate) use run_parser;\r\n\r\nmacro_rules! check_lisp {\r\n    ($data:expr,$result:expr) =\u003e {{\r\n        assert_eq!($crate::testing::test_lib::get_lisp(\u0026$data), $result);\r\n    }};\r\n    ($data:expr,$result:expr,$error:expr) =\u003e {{\r\n        assert_eq!(\r\n            $crate::testing::test_lib::get_lisp(\u0026$data),\r\n            $result,\r\n            \"{}\",\r\n            $error\r\n        );\r\n    }};\r\n}\r\n\r\npub(crate) use check_lisp;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","error_messages.rs"],"content":"//#[allow(dead_code)]\r\n\r\n// const MSG_ZERO_TO_TWELVE:[\u0026str;13]=[];\r\n\r\n// const MSG_TEEN :\u0026str = \"\";\r\n\r\n// const TWENTY_TO_NINETY :\u0026str = [8]=[];\r\n\r\n// pub fn get_error_str(number:usize){\r\n\r\n// }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","javascript_writer.rs"],"content":"use crate::{\r\n    commands::*,\r\n    parser::{multi_lit_num::VarOrInt, string_lit::VarOrStr},\r\n};\r\n\r\n#[allow(dead_code)]\r\npub fn write(exprs: \u0026ExprArena, line_starts: \u0026Vec\u003cusize\u003e) -\u003e String {\r\n    let mut str = \"\".to_string();\r\n    let mut indent: usize = 0;\r\n    for statement in line_starts {\r\n        str += \u0026write_expr(exprs, *statement, \u0026mut indent);\r\n        str += \"\\n\";\r\n    }\r\n    str\r\n}\r\n\r\nfn get_indent(indent: \u0026usize) -\u003e String {\r\n    let mut str = \"\".to_string();\r\n    for _ in 0..*indent {\r\n        str += \"\\t\"\r\n    }\r\n    str\r\n}\r\n\r\nfn write_expr(exprs: \u0026ExprArena, index: usize, indent: \u0026mut usize) -\u003e String {\r\n    match \u0026exprs[index] {\r\n        Expr::NoneStat =\u003e \"(todo stat)\".to_string(),\r\n        Expr::NoneExpr =\u003e \"(todo expr)\".to_string(),\r\n        Expr::Title { data } =\u003e {\r\n            let author_str = data\r\n                .authors\r\n                .iter()\r\n                .map(|name| String::from_utf8_lossy(\u0026name.0))\r\n                .collect::\u003cVec\u003c_\u003e\u003e()\r\n                .join(\", \");\r\n            format!(\r\n                \"`{}`;\\n\\\"By {}\\\";\\n\",\r\n                String::from_utf8_lossy(\u0026data.title),\r\n                author_str\r\n            )\r\n        }\r\n        Expr::Assign {\r\n            var,\r\n            value_index,\r\n            first,\r\n            ..\r\n        } =\u003e format!(\r\n            \"{}{}{}_var = {};\",\r\n            get_indent(indent),\r\n            if *first { \"let \" } else { \"\" },\r\n            String::from_utf8_lossy(\u0026var.name),\r\n            write_expr(exprs, *value_index, indent)\r\n        ),\r\n        Expr::Line {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_line({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Bezier {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_bezier({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Arc {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_ellipse({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Rect {\r\n            locs: _,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            format!(\r\n                \"{}draw_rect({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Var { var } =\u003e format!(\"{}_var\", String::from_utf8_lossy(\u0026var.name).to_string()),\r\n        Expr::WordNum {\r\n            locs: _,\r\n            str_start: _,\r\n            str_len,\r\n            end: _,\r\n        } =\u003e str_len.to_string(),\r\n        Expr::Operator {\r\n            locs: _,\r\n            func_type,\r\n            indexes,\r\n            end: _,\r\n        } =\u003e {\r\n            let ret = match func_type {\r\n                OperatorType::Log =\u003e {\r\n                    format!(\"log_base({})\", write_exprs(exprs, indexes, \", \", indent))\r\n                }\r\n                OperatorType::Exp =\u003e {\r\n                    if indexes.len() == 1 {\r\n                        format!(\"(Math.E ** {})\", write_expr(exprs, indexes[0], indent))\r\n                    } else {\r\n                        format!(\"({})\", write_exprs(exprs, indexes, \" ** \", indent))\r\n                    }\r\n                }\r\n                OperatorType::Equals =\u003e {\r\n                    let first_exp = write_expr(exprs, indexes[0], indent);\r\n                    let mut r;\r\n                    if indexes.len() \u003e 2 {\r\n                        r = format!(\r\n                            \"({} == {}\",\r\n                            first_exp,\r\n                            write_expr(exprs, indexes[1], indent)\r\n                        );\r\n                        for index in \u0026indexes[2..] {\r\n                            if *index != usize::MAX {\r\n                                r += \" \u0026\u0026 \";\r\n                                r += format!(\r\n                                    \"{} == {}\",\r\n                                    first_exp,\r\n                                    write_expr(exprs, *index, indent)\r\n                                )\r\n                                .as_str();\r\n                            }\r\n                        }\r\n                        r += \")\";\r\n                    } else {\r\n                        r = format!(\"{} == {}\", first_exp, write_expr(exprs, indexes[1], indent));\r\n                    }\r\n                    r\r\n                }\r\n                _ =\u003e \"\".to_string(),\r\n            };\r\n            if ret != \"\" {\r\n                return ret;\r\n            }\r\n            let name = match func_type {\r\n                OperatorType::Add =\u003e \"+\",\r\n                OperatorType::Sub =\u003e \"-\",\r\n                OperatorType::Mult =\u003e \"*\",\r\n                OperatorType::Div =\u003e \"/\",\r\n                OperatorType::Mod =\u003e \"%\",\r\n                OperatorType::Exp =\u003e \"**\",\r\n                OperatorType::Log =\u003e \"log\",\r\n                OperatorType::LessThan =\u003e \"\u003c\",\r\n                OperatorType::GreaterThan =\u003e \"\u003e\",\r\n                OperatorType::And =\u003e \"\u0026\u0026\",\r\n                OperatorType::Or =\u003e \"||\",\r\n                OperatorType::Equals =\u003e \"==\",\r\n                OperatorType::Not =\u003e \"!\",\r\n            };\r\n            match indexes.len() {\r\n                1 =\u003e format!(\"{}{}\", name, write_expr(exprs, indexes[0], indent)),\r\n                2 =\u003e format!(\r\n                    \"({} {} {})\",\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    name,\r\n                    write_expr(exprs, indexes[1], indent)\r\n                ),\r\n                _ =\u003e {\r\n                    let mut ret = String::new();\r\n                    ret += \"(\";\r\n                    ret += write_expr(exprs, indexes[0], indent).as_str();\r\n                    for i in \u0026indexes[1..] {\r\n                        ret += \" \";\r\n                        ret += name;\r\n                        ret += \" \";\r\n                        ret += write_expr(exprs, *i, indent).as_str();\r\n                    }\r\n                    ret += \")\";\r\n                    ret\r\n                }\r\n            }\r\n            // format!(\"{} {}\", name, write_exprs(exprs, indexes))\r\n        }\r\n        Expr::LitNum {\r\n            str_start: _,\r\n            str_length: _,\r\n            value,\r\n        } =\u003e value.to_string(),\r\n        Expr::MultiLitNum {\r\n            values,\r\n            single_value,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(intval) = single_value {\r\n                format!(\"{}\", intval)\r\n            } else {\r\n                let mut output_vals = \"\".to_string();\r\n                let mut is_first = true;\r\n                for val in values {\r\n                    if !is_first {\r\n                        output_vals += \", \";\r\n                    } else {\r\n                        is_first = false;\r\n                    }\r\n                    if let VarOrInt::Var(var) = val {\r\n                        output_vals += \u0026format!(\"{}_var\", String::from_utf8_lossy(\u0026var.name));\r\n                    } else if let VarOrInt::Int(intval) = val {\r\n                        output_vals += \u0026format!(\"{}\", intval);\r\n                    }\r\n                }\r\n                format!(\"get_concat_value({})\", output_vals)\r\n            }\r\n        }\r\n        Expr::Print {\r\n            indexes,\r\n            single_word,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(word) = single_word {\r\n                format!(\r\n                    \"{}print_console(\\\"{}\\\");\",\r\n                    get_indent(indent),\r\n                    String::from_utf8_lossy(word)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}print_console({});\",\r\n                    get_indent(indent),\r\n                    write_exprs(exprs, indexes, \", \", indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::If { indexes, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}if ({}) {{\\n{}\\n{}}}\",\r\n                ind,\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_exprs(exprs, \u0026indexes[1..], \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::While { indexes, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}while ({}) {{\\n{}\\n{}}}\",\r\n                ind,\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_exprs(exprs, \u0026indexes[1..], \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::Else { indexes, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}else {{\\n{}\\n{}}}\",\r\n                ind,\r\n                write_exprs(exprs, indexes, \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::LitCol { value, .. } =\u003e {\r\n            format!(\"\\\"{}\\\"\", String::from_utf8_lossy(\u0026value))\r\n        }\r\n        Expr::Stroke { indexes, .. } =\u003e {\r\n            if indexes[1] == usize::MAX {\r\n                format!(\r\n                    \"{}set_stroke({});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}set_stroke({});\",\r\n                    get_indent(indent),\r\n                    write_exprs(exprs, indexes, \", \", indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Fill { indexes, .. } =\u003e {\r\n            if indexes[1] == usize::MAX {\r\n                format!(\r\n                    \"{}set_fill({});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}set_fill({});\",\r\n                    get_indent(indent),\r\n                    write_exprs(exprs, indexes, \", \", indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Color { indexes, .. } =\u003e {\r\n            format!(\"get_color({})\", write_exprs(exprs, indexes, \", \", indent))\r\n        }\r\n        Expr::LitString { str, .. } =\u003e {\r\n            let mut output: String = String::new();\r\n            for val in str.iter() {\r\n                if let VarOrStr::Var(var) = val {\r\n                    let new_val = format!(\"${{{}_var}}\", String::from_utf8_lossy(\u0026var.name));\r\n                    output += \u0026new_val[..];\r\n                } else if let VarOrStr::Str(str) = val {\r\n                    let new_val = String::from_utf8_lossy(str);\r\n                    output += \u0026new_val[..];\r\n                }\r\n            }\r\n            format!(\"`{}`\", output)\r\n        }\r\n        Expr::MoveTo { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}move_to({});\",\r\n                get_indent(indent),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::LineWidth { child_index, .. } =\u003e {\r\n            format!(\r\n                \"{}set_line_width({});\",\r\n                get_indent(indent),\r\n                write_expr(exprs, *child_index, indent)\r\n            )\r\n        }\r\n        Expr::Rotate { index, .. } =\u003e {\r\n            format!(\r\n                \"{}rotate_delta({});\",\r\n                get_indent(indent),\r\n                write_expr(exprs, *index, indent)\r\n            )\r\n        }\r\n        Expr::Append { indexes, .. } =\u003e {\r\n            if indexes[2] == usize::MAX {\r\n                format!(\r\n                    \"{}{}.push({});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    write_expr(exprs, indexes[1], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}{}.splice({}, 0, {});\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    write_expr(exprs, indexes[2], indent),\r\n                    write_expr(exprs, indexes[1], indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Delete { indexes, .. } =\u003e {\r\n            if indexes[1] == usize::MAX {\r\n                format!(\r\n                    \"{}{}.splice(0,1);\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent)\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{}{}.splice({},1);\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, indexes[0], indent),\r\n                    write_expr(exprs, indexes[1], indent)\r\n                )\r\n            }\r\n        }\r\n        Expr::Replace { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}{}[{}]={};\",\r\n                get_indent(indent),\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_expr(exprs, indexes[1], indent),\r\n                write_expr(exprs, indexes[2], indent)\r\n            )\r\n        }\r\n        Expr::Find { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}{}.indexOf({})\",\r\n                get_indent(indent),\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_expr(exprs, indexes[1], indent)\r\n            )\r\n        }\r\n        Expr::Index { indexes, .. } =\u003e {\r\n            format!(\r\n                \"{}[{}]\",\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_expr(exprs, indexes[1], indent)\r\n            )\r\n        }\r\n        Expr::List { indexes, .. } =\u003e {\r\n            format!(\"[{}]\", write_exprs(exprs, indexes, \", \", indent))\r\n        }\r\n        Expr::ForEach { indexes, var, .. } =\u003e {\r\n            let ind = get_indent(indent);\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"{}for(let {}_var of {}) {{\\n{}\\n{}}}\",\r\n                ind,\r\n                String::from_utf8_lossy(\u0026var.name),\r\n                write_expr(exprs, indexes[0], indent),\r\n                write_exprs(exprs, \u0026indexes[1..], \"\\n\", indent),\r\n                ind\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::Function {\r\n            func,\r\n            args,\r\n            indexes,\r\n            ..\r\n        } =\u003e {\r\n            let args_str = args\r\n                .into_iter()\r\n                .map(|data| String::from_utf8_lossy(\u0026data.name) + \"_var\")\r\n                .collect::\u003cVec\u003c_\u003e\u003e()\r\n                .join(\", \");\r\n\r\n            *indent += 1;\r\n            let str = format!(\r\n                \"function {}_var({}) {{\\n{}\\n}}\",\r\n                String::from_utf8_lossy(\u0026func.name),\r\n                args_str,\r\n                write_exprs(exprs, indexes, \"\\n\", indent)\r\n            );\r\n            *indent -= 1;\r\n            return str;\r\n        }\r\n        Expr::FunctionCall { func, indexes, .. } =\u003e {\r\n            //Trying without a semicolon since JS lets you forget them sometimes and function calls can be either expressions or statements\r\n            format!(\r\n                \"{}_var({})\",\r\n                String::from_utf8_lossy(\u0026func.name),\r\n                write_exprs(exprs, indexes, \", \", indent)\r\n            )\r\n        }\r\n        Expr::Return { index, .. } =\u003e {\r\n            if let Some(ind) = index {\r\n                format!(\r\n                    \"{}return {};\",\r\n                    get_indent(indent),\r\n                    write_expr(exprs, *ind, indent)\r\n                )\r\n            } else {\r\n                format!(\"{}return;\", get_indent(indent))\r\n            }\r\n        }\r\n        Expr::Length { index, .. } =\u003e {\r\n            format!(\"{}.length\", write_expr(exprs, *index, indent))\r\n        }\r\n        Expr::Not { .. } =\u003e {\r\n            format!(\"\")\r\n        }\r\n    }\r\n}\r\n\r\nfn write_exprs(\r\n    exprs: \u0026ExprArena,\r\n    indexes: \u0026[usize],\r\n    delimeter: \u0026str,\r\n    indent: \u0026mut usize,\r\n) -\u003e String {\r\n    if indexes.len() == 0 {\r\n        return \"\".to_string();\r\n    }\r\n    let mut ret = String::new();\r\n    ret += write_expr(exprs, indexes[0], indent).as_str();\r\n    for index in \u0026indexes[1..] {\r\n        if *index != usize::MAX {\r\n            ret += delimeter;\r\n            ret += write_expr(exprs, *index, indent).as_str();\r\n        }\r\n    }\r\n    ret\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":300},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","lisp_like_writer.rs"],"content":"use std::usize;\r\n\r\nuse crate::{\r\n    commands::*,\r\n    parser::{multi_lit_num::VarOrInt, string_lit::VarOrStr, End, SubStrData},\r\n};\r\n\r\nfn write_end(end: End) -\u003e String {\r\n    let mut ret = String::new();\r\n    if end.index != usize::MAX {\r\n        ret += \"$\";\r\n        ret += \u0026end.index.to_string();\r\n        if end.count != 1 {\r\n            ret += \"$$\";\r\n            ret += \u0026end.count.to_string();\r\n        }\r\n    }\r\n    ret\r\n}\r\n\r\nfn join_locs(locs: \u0026Vec\u003cusize\u003e, end: Option\u003cEnd\u003e) -\u003e String {\r\n    if locs.is_empty() {\r\n        \"\".to_string()\r\n    } else {\r\n        let mut iter = locs.into_iter();\r\n        let first = iter.next().unwrap();\r\n        let mut ret = iter.fold(\"@\".to_string() + \u0026first.to_string(), |a, b| {\r\n            a + \u0026\",\" + \u0026b.to_string()\r\n        });\r\n        if let Some(end) = end {\r\n            ret += \u0026write_end(end);\r\n        }\r\n        ret\r\n    }\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn write(exprs: \u0026ExprArena, line_starts: \u0026Vec\u003cusize\u003e) -\u003e String {\r\n    let mut str = \"\".to_string();\r\n    for statement in line_starts {\r\n        str += \u0026write_expr(exprs, *statement, 0);\r\n        str += \"\\n\";\r\n    }\r\n    str.pop();\r\n    str\r\n}\r\n#[allow(dead_code)]\r\npub fn write_first(exprs: \u0026ExprArena) -\u003e String {\r\n    write_expr(exprs, 0, 0)\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn write_one(exprs: \u0026ExprArena, index: usize) -\u003e String {\r\n    write_expr(exprs, index, 0)\r\n}\r\n\r\nfn write_expr(exprs: \u0026ExprArena, index: usize, indent: usize) -\u003e String {\r\n    match \u0026exprs[index] {\r\n        Expr::NoneStat =\u003e \"(todo stat)\".to_string(),\r\n        Expr::NoneExpr =\u003e \"(todo expr)\".to_string(),\r\n        Expr::Title { data } =\u003e {\r\n            let author_str = data.authors.iter().fold(String::new(), |str, author| {\r\n                format!(\r\n                    \"{str} \\\"{}\\\"@{}$${}\",\r\n                    String::from_utf8_lossy(\u0026author.0),\r\n                    author.1,\r\n                    author.2\r\n                )\r\n            });\r\n\r\n            let imports_str = data.imports.iter().fold(String::new(), |str, import| {\r\n                format!(\"{str} {}@{}$${}\", import.0.get_name(), import.1, import.2)\r\n            });\r\n\r\n            format!(\r\n                \"(title \\\"{}\\\" (authors{author_str})@{} (imports{imports_str}))\",\r\n                String::from_utf8_lossy(\u0026data.title),\r\n                data.by_start\r\n            )\r\n        }\r\n        Expr::Assign {\r\n            locs,\r\n            var,\r\n            value_index,\r\n            end,\r\n            first,\r\n        } =\u003e format!(\r\n            \"(assign{} {}{} {})\",\r\n            join_locs(locs, Some(*end)),\r\n            if *first { \"\" } else { \"mut \" },\r\n            write_var(var),\r\n            write_expr(exprs, *value_index, 0)\r\n        ),\r\n        Expr::Bezier { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(bezier{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Line { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(line{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Arc { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(arc{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Rect { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(rect{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Var { var } =\u003e format!(\"(var {})\", write_var(var)),\r\n        Expr::WordNum {\r\n            locs,\r\n            str_start,\r\n            str_len,\r\n            end,\r\n        } =\u003e format!(\r\n            \"(wordnum{} {}@{})\",\r\n            join_locs(locs, Some(*end)),\r\n            *str_len,\r\n            *str_start,\r\n        ),\r\n        Expr::Operator {\r\n            locs,\r\n            func_type,\r\n            indexes,\r\n            end,\r\n        } =\u003e {\r\n            let name = match func_type {\r\n                OperatorType::Add =\u003e \"+\",\r\n                OperatorType::Sub =\u003e \"-\",\r\n                OperatorType::Mult =\u003e \"*\",\r\n                OperatorType::Div =\u003e \"/\",\r\n                OperatorType::Mod =\u003e \"%\",\r\n                OperatorType::Exp =\u003e \"exp\",\r\n                OperatorType::Log =\u003e \"log\",\r\n                OperatorType::LessThan =\u003e \"\u003c\",\r\n                OperatorType::GreaterThan =\u003e \"\u003e\",\r\n                OperatorType::And =\u003e \"\u0026\",\r\n                OperatorType::Or =\u003e \"||\",\r\n                OperatorType::Equals =\u003e \"==\",\r\n                OperatorType::Not =\u003e \"!\",\r\n            };\r\n            format!(\r\n                \"({}{} {})\",\r\n                name,\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::LitNum {\r\n            str_start,\r\n            str_length,\r\n            value,\r\n        } =\u003e format!(\"(litnum {}@{}$${})\", value, str_start, str_length),\r\n        Expr::MultiLitNum {\r\n            locs,\r\n            single_value,\r\n            values,\r\n            end,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(intval) = single_value {\r\n                format!(\"(litnum{} {})\", join_locs(locs, Some(*end)), intval)\r\n            } else {\r\n                let mut output_vals = \"\".to_string();\r\n                let mut is_first = true;\r\n                for val in values {\r\n                    if !is_first {\r\n                        output_vals += \" \";\r\n                    } else {\r\n                        is_first = false;\r\n                    }\r\n                    if let VarOrInt::Var(var) = val {\r\n                        output_vals += \u0026format!(\"{}\", String::from_utf8_lossy(\u0026var.name));\r\n                    } else if let VarOrInt::Int(intval) = val {\r\n                        output_vals += \u0026format!(\"{}\", intval);\r\n                    }\r\n                }\r\n                format!(\r\n                    \"(multilitnum{} {})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    output_vals\r\n                )\r\n            }\r\n        }\r\n        Expr::Print {\r\n            locs,\r\n            indexes,\r\n            end,\r\n            single_word,\r\n            single_word_start,\r\n            ..\r\n        } =\u003e {\r\n            if let Some(word) = single_word {\r\n                format!(\r\n                    \"(print{} \\\"{}\\\"@{})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    String::from_utf8_lossy(word),\r\n                    single_word_start\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"(print{} {})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    write_exprs(exprs, indexes)\r\n                )\r\n            }\r\n        }\r\n        Expr::If {\r\n            locs, indexes, end, ..\r\n        } =\u003e {\r\n            let split = indexes.split_at_checked(1).unwrap_or_default();\r\n            format!(\r\n                \"(if{} {} then:\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *split.0.first().unwrap_or(\u0026usize::MAX), 0),\r\n                write_stats(exprs, split.1, indent + 1)\r\n            )\r\n        }\r\n        Expr::While {\r\n            locs, indexes, end, ..\r\n        } =\u003e {\r\n            let split = indexes.split_at_checked(1).unwrap_or_default();\r\n            format!(\r\n                \"(while{} {} then:\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *split.0.first().unwrap_or(\u0026usize::MAX), 0),\r\n                write_stats(exprs, split.1, indent + 1),\r\n            )\r\n        }\r\n        Expr::Else { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(else{}\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                write_stats(exprs, indexes, indent + 1)\r\n            )\r\n        }\r\n        Expr::LitCol {\r\n            str_start,\r\n            str_length,\r\n            value,\r\n        } =\u003e {\r\n            format!(\r\n                \"(litcol {}@{}$${})\",\r\n                String::from_utf8_lossy(value),\r\n                str_start,\r\n                str_length\r\n            )\r\n        }\r\n        Expr::Color { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(color{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Stroke { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(stroke{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::Fill { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(fill{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::LitString { str, str_start, .. } =\u003e {\r\n            let mut output: String = String::new();\r\n            for val in str.iter() {\r\n                if let VarOrStr::Var(var) = val {\r\n                    let new_val = format!(\"{}\", String::from_utf8_lossy(\u0026var.name));\r\n                    output += \u0026new_val[..];\r\n                } else if let VarOrStr::Str(str) = val {\r\n                    let new_val = String::from_utf8_lossy(str);\r\n                    output += \u0026new_val[..];\r\n                }\r\n            }\r\n            format!(\"\\\"{}\\\"@{}\", output, str_start)\r\n        }\r\n        Expr::MoveTo { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(moveto{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes),\r\n            )\r\n        }\r\n        Expr::LineWidth {\r\n            locs,\r\n            child_index,\r\n            end,\r\n        } =\u003e {\r\n            format!(\r\n                \"(linewidth{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *child_index, 0)\r\n            )\r\n        }\r\n        Expr::Rotate { locs, index, end } =\u003e {\r\n            format!(\r\n                \"(rotate{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *index, 0)\r\n            )\r\n        }\r\n        Expr::Append { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(append{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Delete { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(delete{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Replace { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(replace{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Find { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(find{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Index { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(index{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::List { locs, indexes, end } =\u003e {\r\n            format!(\r\n                \"(list{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::ForEach {\r\n            locs,\r\n            indexes,\r\n            end,\r\n            var,\r\n            ..\r\n        } =\u003e {\r\n            let split = indexes.split_at_checked(1).unwrap_or_default();\r\n            format!(\r\n                \"(foreach{} {} {} then:\\n{}\\n)\",\r\n                join_locs(locs, Some(*end)),\r\n                String::from_utf8_lossy(\u0026var.name),\r\n                write_expr(exprs, *split.0.first().unwrap_or(\u0026usize::MAX), 0),\r\n                write_stats(exprs, split.1, indent + 1),\r\n            )\r\n        }\r\n        Expr::Function {\r\n            locs,\r\n            func,\r\n            args,\r\n            indexes,\r\n            end,\r\n            ..\r\n        } =\u003e {\r\n            let args_str = args\r\n                .into_iter()\r\n                .fold(String::new(), |str, arg| str + \u0026\" \" + \u0026write_var(arg));\r\n            format!(\r\n                \"(function{} {} (args{}) {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_var(func),\r\n                args_str,\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::FunctionCall {\r\n            locs,\r\n            func,\r\n            indexes,\r\n            end,\r\n            ..\r\n        } =\u003e {\r\n            format!(\r\n                \"({}{} {})\",\r\n                write_var(func),\r\n                join_locs(locs, Some(*end)),\r\n                write_exprs(exprs, indexes)\r\n            )\r\n        }\r\n        Expr::Return { locs, index, end } =\u003e {\r\n            if let Some(ind) = index {\r\n                format!(\r\n                    \"(return{} {})\",\r\n                    join_locs(locs, Some(*end)),\r\n                    write_expr(exprs, *ind, 0)\r\n                )\r\n            } else {\r\n                format!(\"(return{})\", join_locs(locs, Some(*end)))\r\n            }\r\n        }\r\n        Expr::Length { locs, index, end } =\u003e {\r\n            format!(\r\n                \"(length{} {})\",\r\n                join_locs(locs, Some(*end)),\r\n                write_expr(exprs, *index, 0)\r\n            )\r\n        }\r\n        Expr::Not {\r\n            locs,\r\n            word,\r\n            str_start,\r\n            str_len,\r\n            end,\r\n        } =\u003e {\r\n            format!(\r\n                \"(not{} @{}$${} \\\"{}\\\")\",\r\n                join_locs(locs, Some(*end)),\r\n                *str_start,\r\n                *str_len,\r\n                String::from_utf8_lossy(word)\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\nfn write_exprs(exprs: \u0026ExprArena, indexes: \u0026[usize]) -\u003e String {\r\n    write_mult_exprs(exprs, indexes, b' ', 0)\r\n}\r\nfn write_stats(exprs: \u0026ExprArena, indexes: \u0026[usize], indent: usize) -\u003e String {\r\n    write_mult_exprs(exprs, indexes, b'\\n', indent)\r\n}\r\nfn write_mult_exprs(exprs: \u0026ExprArena, indexes: \u0026[usize], char: u8, indent: usize) -\u003e String {\r\n    let mut ret = String::new();\r\n    for index in indexes {\r\n        if *index != usize::MAX {\r\n            for _ in 0..indent {\r\n                ret += \"  \";\r\n            }\r\n            ret += \u0026write_expr(exprs, *index, indent);\r\n            ret.push(char as char);\r\n        }\r\n    }\r\n    ret.pop();\r\n    ret\r\n}\r\n\r\nfn write_var(var: \u0026SubStrData) -\u003e String {\r\n    let mut skips_str = String::new();\r\n    if !var.skip_indexes.is_empty() {\r\n        skips_str += \"|\";\r\n        skips_str += \u0026var\r\n            .skip_indexes\r\n            .iter()\r\n            .map(|f| f.to_string())\r\n            .collect::\u003cVec\u003cString\u003e\u003e()\r\n            .join(\",\");\r\n    }\r\n\r\n    format!(\r\n        \"\\\"{}\\\"@{}{}\",\r\n        String::from_utf8_lossy(\u0026var.name),\r\n        var.start,\r\n        skips_str\r\n    )\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":9,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":10,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":11,"address":[],"length":0,"stats":{"Line":2377900603251621890}},{"line":12,"address":[],"length":0,"stats":{"Line":2377900603251621890}},{"line":13,"address":[],"length":0,"stats":{"Line":4899916394579099652}},{"line":14,"address":[],"length":0,"stats":{"Line":2522015791327477762}},{"line":15,"address":[],"length":0,"stats":{"Line":2522015791327477762}},{"line":18,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":21,"address":[],"length":0,"stats":{"Line":2810246167479189505}},{"line":22,"address":[],"length":0,"stats":{"Line":2810246167479189505}},{"line":23,"address":[],"length":0,"stats":{"Line":432345564227567618}},{"line":25,"address":[],"length":0,"stats":{"Line":2377900603251621887}},{"line":26,"address":[],"length":0,"stats":{"Line":2377900603251621887}},{"line":27,"address":[],"length":0,"stats":{"Line":7133701809754865664}},{"line":28,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":30,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":31,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":33,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":38,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":39,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":40,"address":[],"length":0,"stats":{"Line":14987979559889010693}},{"line":41,"address":[],"length":0,"stats":{"Line":18086456103519911937}},{"line":42,"address":[],"length":0,"stats":{"Line":18086456103519911937}},{"line":44,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":45,"address":[],"length":0,"stats":{"Line":16068843470457929730}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":2377900603251621889}},{"line":58,"address":[],"length":0,"stats":{"Line":2377900603251621889}},{"line":59,"address":[],"length":0,"stats":{"Line":18446744073709551611}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":83,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":84,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":85,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":86,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":87,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":89,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":90,"address":[],"length":0,"stats":{"Line":12105675798371893249}},{"line":91,"address":[],"length":0,"stats":{"Line":15276209936040722433}},{"line":92,"address":[],"length":0,"stats":{"Line":15276209936040722433}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":118,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":119,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":122,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":130,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":135,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":136,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":137,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":138,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":140,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":164,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":165,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":166,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":168,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":169,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":170,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":171,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":174,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":177,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":178,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":179,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":180,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":181,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":183,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":188,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":191,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":193,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":194,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":199,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":200,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":201,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":202,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":203,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":206,"address":[],"length":0,"stats":{"Line":3386706919782612993}},{"line":207,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":209,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":210,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":211,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":214,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":216,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":217,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":222,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":223,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":224,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":225,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":227,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":228,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":229,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":233,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":234,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":235,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":236,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":238,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":239,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":240,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":243,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":244,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":246,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":247,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":251,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":252,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":253,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":254,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":255,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":257,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":258,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":259,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":284,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":285,"address":[],"length":0,"stats":{"Line":576460752303423489}},{"line":286,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":289,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":294,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":357,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":359,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":360,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":364,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":365,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":366,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":367,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":368,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":369,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":370,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":371,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":373,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":374,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":375,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":376,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":380,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":381,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":382,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":383,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":384,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":385,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":386,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":387,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":389,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":390,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":392,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":393,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":394,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":395,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":399,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":400,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":401,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":402,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":403,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":404,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":405,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":407,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":408,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":409,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":412,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":413,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":414,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":416,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":417,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":449,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":451,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":452,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":454,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":455,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":456,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":458,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":459,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":461,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":462,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":465,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":466,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":469,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":470,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":471,"address":[],"length":0,"stats":{"Line":17942340915444056063}},{"line":472,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":473,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":474,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":475,"address":[],"length":0,"stats":{"Line":792633534417207295}},{"line":476,"address":[],"length":0,"stats":{"Line":1873497444986126335}},{"line":481,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":483,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":484,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":485,"address":[],"length":0,"stats":{"Line":17149707381026848768}}],"covered":205,"coverable":300},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","processing_writer.rs"],"content":"use crate::commands::*;\r\nuse bitflags::bitflags;\r\n#[allow(dead_code)]\r\n\r\n//from\r\n//https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html\r\n// Operator Precedence\r\n// additive -\u003e 10 * 2\r\n// multiplicative -\u003e 11*2\r\n\r\nconst TODO_FUNC: \u0026str = r#\"\r\n\u003cT\u003e T todo(){\r\n    throw new java.lang.UnsupportedOperationException(\"Not parsed yet\");\r\n}\"#;\r\n\r\nconst CIRCLE_FUNC: \u0026str = r#\"\r\nvoid pcircle(int x,int y,int r){\r\n    circle(x,y,r*2);\r\n}\"#;\r\n\r\nconst FUNCS: [\u0026str; 2] = [TODO_FUNC, CIRCLE_FUNC];\r\n\r\nbitflags! {\r\n    /// Represents a set of flags.\r\n    #[derive(Debug, Default)]\r\n    struct FuncFlags: u32 {\r\n        const uses_todo = 1;\r\n        const uses_circle = 2;\r\n    }\r\n}\r\n\r\nfn write_functions(flags: FuncFlags, str: \u0026mut String) {\r\n    for flag in flags {\r\n        *str += FUNCS[flag.bits() as usize];\r\n    }\r\n}\r\n\r\npub fn write(exprs: \u0026ExprArena, line_starts: \u0026Vec\u003cusize\u003e) -\u003e String {\r\n    let mut flags = Default::default();\r\n    let mut str = \"void setup(){\r\n        size(400, 400);\r\n    }\"\r\n    .to_string();\r\n\r\n    let mut code = \"\r\nvoid draw(){ \r\n    background(255);\r\n\"\r\n    .to_string();\r\n    for statement in line_starts {\r\n        code += \"    \";\r\n        code += \u0026write_stat(exprs, *statement, \u0026mut flags);\r\n    }\r\n\r\n    write_functions(flags, \u0026mut str);\r\n\r\n    str + \u0026code + \"}\"\r\n}\r\n\r\nfn write_stat(exprs: \u0026ExprArena, start: usize, flags: \u0026mut FuncFlags) -\u003e String {\r\n    match \u0026exprs[start] {\r\n        Expr::NoneStat =\u003e \";\\n\".to_string(),\r\n        Expr::Set {\r\n            name, value_index, ..\r\n        } =\u003e format!(\r\n            \"var {}={};\\n\",\r\n            String::from_utf8_lossy(\u0026name),\r\n            write_expr(exprs, *value_index, 0, flags)\r\n        ),\r\n        Expr::Line { indexes, .. } =\u003e format!(\r\n            \"line({},{},{},{});\\n\",\r\n            write_expr(exprs, indexes[0], 0, flags),\r\n            write_expr(exprs, indexes[1], 0, flags),\r\n            write_expr(exprs, indexes[2], 0, flags),\r\n            write_expr(exprs, indexes[3], 0, flags)\r\n        ),\r\n        Expr::Arc { indexes, .. } =\u003e {\r\n            *flags |= FuncFlags::uses_circle;\r\n            format!(\r\n                \"pcircle({},{},{});\\n\",\r\n                write_expr(exprs, indexes[0], 0, flags),\r\n                write_expr(exprs, indexes[1], 0, flags),\r\n                write_expr(exprs, indexes[2], 0, flags)\r\n            )\r\n        }\r\n        expr =\u003e panic!(\"found non starting expresion {expr:?} in starting position\"),\r\n    }\r\n}\r\n\r\nfn write_expr(\r\n    exprs: \u0026ExprArena,\r\n    index: usize,\r\n    last_precedence: u8,\r\n    flags: \u0026mut FuncFlags,\r\n) -\u003e String {\r\n    match \u0026exprs[index] {\r\n        Expr::NoneExpr =\u003e {\r\n            *flags |= FuncFlags::uses_todo;\r\n            \"todo()\".to_string()\r\n        }\r\n        Expr::Var { name, .. } =\u003e String::from_utf8_lossy(\u0026name).to_string(),\r\n        Expr::WordNum { str, .. } =\u003e format!(\"\\\"{}\\\".length()\", String::from_utf8_lossy(\u0026str)),\r\n        Expr::Operator {\r\n            func_type, indexes, ..\r\n        } =\u003e {\r\n            let func_data = match func_type {\r\n                OperatorType::Add =\u003e (\"+\", 10 * 2),\r\n                OperatorType::Sub =\u003e (\"-\", 10 * 2),\r\n                OperatorType::Mult =\u003e (\"*\", 11 * 2),\r\n                OperatorType::Div =\u003e (\"/\", 11 * 2),\r\n                OperatorType::Mod =\u003e (\"%\", 11 * 2),\r\n            };\r\n            write_var_len_operator(\r\n                exprs,\r\n                indexes,\r\n                func_data.0,\r\n                last_precedence,\r\n                func_data.1,\r\n                flags,\r\n            )\r\n        }\r\n\r\n        Expr::LitNum { value, .. } =\u003e format!(\"{}\", value),\r\n        expr =\u003e panic!(\"found starting expresion {expr:?} in non starting position\"),\r\n    }\r\n}\r\n\r\nfn write_var_len_operator(\r\n    exprs: \u0026ExprArena,\r\n    indexes: \u0026Vec\u003cusize\u003e,\r\n    operator: \u0026str,\r\n    last_precedence: u8,\r\n    current_precedence: u8,\r\n    flags: \u0026mut FuncFlags,\r\n) -\u003e String {\r\n    if indexes.len() \u003c 2 {\r\n        panic!(\"operator {operator} had less than two arguments\");\r\n    }\r\n    let add_paren = last_precedence \u003e current_precedence;\r\n    let mut ret = String::new();\r\n    if add_paren {\r\n        ret += \"(\";\r\n    }\r\n\r\n    ret += \u0026write_expr(exprs, indexes[0], current_precedence, flags);\r\n\r\n    for index in indexes.iter().skip(1) {\r\n        ret += operator;\r\n        ret += \u0026write_expr(exprs, *index, current_precedence + 1, flags);\r\n    }\r\n\r\n    if add_paren {\r\n        ret += \")\";\r\n    }\r\n    ret\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","runner.rs"],"content":"// use std::{collections::HashMap, default};\r\n\r\n// use crate::{commands::*, parser::State};\r\n\r\n// pub enum ValueType {\r\n//     // type , index\r\n//     Error(ErrorData),\r\n//     Number(i64),\r\n//     Float(f64),\r\n// }\r\n\r\n// impl ValueType {\r\n//     pub fn get_i64(\u0026self) -\u003e Option\u003ci64\u003e {\r\n//         match \u0026self {\r\n//             ValueType::Error(_) =\u003e None,\r\n//             ValueType::Number(i) =\u003e Some(*i),\r\n//             ValueType::Float(_) =\u003e None,\r\n//         }\r\n//     }\r\n\r\n//     pub fn get_f64(\u0026self) -\u003e Option\u003cf64\u003e {\r\n//         match \u0026self {\r\n//             ValueType::Error(_) =\u003e None,\r\n//             ValueType::Number(i) =\u003e Some(*i as f64),\r\n//             ValueType::Float(i) =\u003e Some(*i),\r\n//         }\r\n//     }\r\n\r\n//     // pub fn get_i64_cast(\u0026self) -\u003e Option\u003ci64\u003e {\r\n//     //     match \u0026self {\r\n//     //         ValueType::Error(_) =\u003e None,\r\n//     //         ValueType::Number(i) =\u003e Some(*i),\r\n//     //         ValueType::Float(i) =\u003e f64_to_i64(*i),\r\n//     //     }\r\n//     // }\r\n// }\r\n\r\n// // fn f64_to_i64(val:f64)-\u003eOption\u003ci64\u003e{\r\n// //     if val.is_nan() || val\u003ei64::MAX as f64||val\u003ci64::MIN  as f64{\r\n// //         None\r\n// //     }else {\r\n// //         val.round().\r\n// //     }\r\n// // }\r\n// #[derive(Debug)]\r\n\r\n// pub enum Error {\r\n//     Malformed,\r\n//     NotParsed,\r\n//     Div0,\r\n//     Log,\r\n//     TypeError,\r\n//     NoVarible,\r\n// }\r\n\r\n// pub struct ErrorData {\r\n//     error: Error,\r\n// }\r\n\r\n// pub struct Bounds {\r\n//     x1: f64,\r\n//     y1: f64,\r\n//     x2: f64,\r\n//     y2: f64,\r\n// }\r\n\r\n// pub enum Statement {\r\n//     Error(ErrorData, usize),\r\n//     Circle([f64; 3]),\r\n//     Ellipse([f64; 4]),\r\n//     Line([f64; 4]),\r\n//     Assign(Vec\u003cu8\u003e, ValueType),\r\n//     Square([f64; 3]),\r\n//     Rect([f64; 4]),\r\n//     Print(Vec\u003cPrints\u003e),\r\n// }\r\n// // name, index\r\n// type Vars = HashMap\u003cVec\u003cu8\u003e, ValueType\u003e;\r\n// pub struct ProgramRunner {\r\n//     pub bounds: Option\u003cBounds\u003e,\r\n//     pub vars: Vars,\r\n//     pub statements: Vec\u003cStatement\u003e,\r\n// }\r\n\r\n// #[allow(dead_code)]\r\n// impl ProgramRunner {\r\n//     pub fn new() -\u003e Self {\r\n//         Self {\r\n//             bounds: None,\r\n//             vars: Vars::new(),\r\n//             statements: Vec::new(),\r\n//         }\r\n//     }\r\n\r\n//     pub fn run(\u0026mut self, exprs: \u0026ExprArena, line_starts: \u0026[usize]) {\r\n//         let mut vars = Vars::new();\r\n//         let mut global_index = 0;\r\n//         for statement in line_starts {\r\n//             let stat;\r\n//             (stat, global_index) = run_statement(exprs, \u0026vars, *statement, global_index);\r\n//             self.run_statement_bounds(stat);\r\n//         }\r\n//     }\r\n// }\r\n\r\n// impl ProgramRunner {\r\n//     fn run_statement_bounds(\u0026mut self, stat: Statement) {\r\n//         match stat {\r\n//             Statement::Error(error, index) =\u003e {\r\n//                 println!(\"{:?} Error occured at {}\", error.error, index);\r\n//             }\r\n//             Statement::Assign(name, data) =\u003e {\r\n//                 self.vars.insert(name, data);\r\n//             }\r\n//             s @ Statement::Circle([x, y, r]) =\u003e {\r\n//                 self.add_to_bounds((x - r, y));\r\n//                 self.add_to_bounds((x + r, y));\r\n//                 self.add_to_bounds((x, y - r));\r\n//                 self.add_to_bounds((x, y + r));\r\n//                 self.statements.push(s);\r\n//             }\r\n//             s @ Statement::Ellipse([x, y, w, h]) =\u003e {\r\n//                 self.add_to_bounds((x - w, y));\r\n//                 self.add_to_bounds((x + w, y));\r\n//                 self.add_to_bounds((x, y - h));\r\n//                 self.add_to_bounds((x, y + h));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Line([x, y, x2, y2]) =\u003e {\r\n//                 self.add_to_bounds((x, y));\r\n//                 self.add_to_bounds((x2, y2));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Square([x, y, w]) =\u003e {\r\n//                 self.add_to_bounds((x, y));\r\n//                 self.add_to_bounds((x + w, y));\r\n//                 self.add_to_bounds((x, y + w));\r\n//                 self.add_to_bounds((x + w, y + w));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Rect([x, y, w, h]) =\u003e {\r\n//                 self.add_to_bounds((x, y));\r\n//                 self.add_to_bounds((x + w, y));\r\n//                 self.add_to_bounds((x, y + h));\r\n//                 self.add_to_bounds((x + w, y + h));\r\n//                 self.statements.push(s)\r\n//             }\r\n//             s @ Statement::Print(_) =\u003e self.statements.push(s),\r\n//         };\r\n//     }\r\n\r\n//     fn add_to_bounds(\u0026mut self, point: (f64, f64)) {\r\n//         if let Some(bounds) = \u0026mut self.bounds {\r\n//             *bounds = Bounds {\r\n//                 x1: bounds.x1.min(point.0),\r\n//                 y1: bounds.y1.min(point.1),\r\n//                 x2: bounds.x2.max(point.0),\r\n//                 y2: bounds.y2.max(point.1),\r\n//             };\r\n//         } else {\r\n//             self.bounds = Some(Bounds {\r\n//                 x1: point.0,\r\n//                 y1: point.1,\r\n//                 x2: point.0,\r\n//                 y2: point.1,\r\n//             });\r\n//         }\r\n//     }\r\n// }\r\n// fn run_statement(\r\n//     exprs: \u0026ExprArena,\r\n//     vars: \u0026Vars,\r\n//     index: usize,\r\n//     mut global_index: usize,\r\n// ) -\u003e (Statement, usize) {\r\n//     match \u0026exprs[index] {\r\n//         Expr::NoneStat | Expr::NoneExpr =\u003e (\r\n//             Statement::Error(\r\n//                 ErrorData {\r\n//                     error: Error::NotParsed,\r\n//                 },\r\n//                 global_index,\r\n//             ),\r\n//             global_index,\r\n//         ),\r\n//         Expr::Arc { locs, indexes, end } =\u003e {\r\n//             let data;\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             (data, _) = run_varible_length_args(exprs, vars, indexes, global_index, |vec| {\r\n//                 match (vec.len(), vec) {\r\n//                     (0..=2, ..) =\u003e None,\r\n//                     (3, [a, b, c]) =\u003e Some((Statement::Circle([*a, *b, *c]), false)),\r\n//                     (4, [a, b, c, d]) =\u003e Some((Statement::Ellipse([*a, *b, *c, *d]), true)),\r\n//                     _ =\u003e unreachable!(),\r\n//                 }\r\n//             });\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         Expr::Line { locs, indexes, end } =\u003e {\r\n//             let data;\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             (data, _) = run_varible_length_args(exprs, vars, indexes, global_index, |vec| {\r\n//                 match (vec.len(), vec) {\r\n//                     (0..=3, ..) =\u003e None,\r\n//                     (4, [a, b, c, d]) =\u003e Some((Statement::Line([*a, *b, *c, *d]), true)),\r\n//                     _ =\u003e unreachable!(),\r\n//                 }\r\n//             });\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         Expr::Assign {\r\n//             locs,\r\n//             name_start,\r\n//             name,\r\n//             value_index,\r\n//             end,\r\n//         } =\u003e todo!(),\r\n//         Expr::Rect { locs, indexes, end } =\u003e {\r\n//             let data;\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             (data, _) = run_varible_length_args(exprs, vars, indexes, global_index, |vec| {\r\n//                 match (vec.len(), vec) {\r\n//                     (0..=2, ..) =\u003e None,\r\n//                     (3, [a, b, c]) =\u003e Some((Statement::Square([*a, *b, *c]), false)),\r\n//                     (4, [a, b, c, d]) =\u003e Some((Statement::Rect([*a, *b, *c, *d]), true)),\r\n//                     _ =\u003e unreachable!(),\r\n//                 }\r\n//             });\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         Expr::Print { locs, data, end } =\u003e {\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             set_global_to_end(\u0026mut global_index, *end);\r\n//             (data, global_index)\r\n//         }\r\n//         // this should never run - but if it does than error\r\n//         _ =\u003e (\r\n//             Statement::Error(\r\n//                 ErrorData {\r\n//                     error: Error::Malformed,\r\n//                 },\r\n//                 global_index,\r\n//             ),\r\n//             global_index,\r\n//         ),\r\n//     }\r\n// }\r\n\r\n// fn run_expr(\r\n//     exprs: \u0026ExprArena,\r\n//     vars: \u0026Vars,\r\n//     index: usize,\r\n//     mut global_index: usize,\r\n// ) -\u003e (ValueType, usize) {\r\n//     match \u0026exprs[index] {\r\n//         Expr::NoneStat | Expr::NoneExpr =\u003e (\r\n//             ValueType::Error(ErrorData {\r\n//                 error: Error::NotParsed,\r\n//             }),\r\n//             global_index,\r\n//         ),\r\n//         Expr::Var { name_start, name } =\u003e todo!(),\r\n//         Expr::WordNum { str_len, end, .. } =\u003e (ValueType::Number(*str_len as i64), *end + 1),\r\n//         Expr::Operator {\r\n//             locs,\r\n//             func_type,\r\n//             indexes,\r\n//             end,\r\n//         } =\u003e match func_type {\r\n//             OperatorType::Add =\u003e todo!(),\r\n//             OperatorType::Sub =\u003e todo!(),\r\n//             OperatorType::Mult =\u003e todo!(),\r\n//             OperatorType::Div =\u003e todo!(),\r\n//             OperatorType::Mod =\u003e todo!(),\r\n//             OperatorType::Exp =\u003e todo!(),\r\n//             OperatorType::Log =\u003e todo!(),\r\n//         },\r\n//         Expr::LitNum {\r\n//             str_start,\r\n//             str_length,\r\n//             value,\r\n//         } =\u003e (ValueType::Number(*value), *str_start + *str_length),\r\n//         Expr::MultiLitNum {\r\n//             locs,\r\n//             num_indexes,\r\n//             end,\r\n//         } =\u003e todo!(),\r\n//         Expr::Skip {\r\n//             locs,\r\n//             index,\r\n//             start,\r\n//             end,\r\n//         } =\u003e {\r\n//             set_global_to_loc(\u0026mut global_index, locs);\r\n//             run_expr(exprs, vars, *index, global_index)\r\n//         }\r\n\r\n//         // this should never run - but if it does than error\r\n//         _ =\u003e (\r\n//             ValueType::Error(ErrorData {\r\n//                 error: Error::Malformed,\r\n//             }),\r\n//             global_index,\r\n//         ),\r\n//     }\r\n// }\r\n\r\n// // None = cant closes\r\n// // Some(..,0) = can close\r\n// // Some(..,1) = must close\r\n// type VaribleLengthFn = fn(\u0026[f64]) -\u003e Option\u003c(Statement, bool)\u003e;\r\n// fn run_varible_length_args(\r\n//     exprs: \u0026ExprArena,\r\n//     vars: \u0026Vars,\r\n//     indexes: \u0026[usize],\r\n//     mut global_index: usize,\r\n//     close_fn: VaribleLengthFn,\r\n// ) -\u003e (Statement, usize) {\r\n//     let mut last_statement = None;\r\n//     let mut vec = Vec::with_capacity(indexes.len());\r\n//     for j in indexes {\r\n//         // end of arguments\r\n//         if *j == usize::MAX {\r\n//             break;\r\n//         }\r\n//         let data;\r\n//         (data, global_index) = run_expr(exprs, vars, *j, global_index);\r\n//         // get the value inside\r\n//         if let Some(val) = data.get_f64() {\r\n//             vec.push(val);\r\n//             // if error than return\r\n//         } else if let ValueType::Error(data) = data {\r\n//             return (Statement::Error(data, global_index), global_index);\r\n//             // else make error - type couldn't convert\r\n//         } else {\r\n//             return (\r\n//                 Statement::Error(\r\n//                     ErrorData {\r\n//                         error: Error::TypeError,\r\n//                     },\r\n//                     global_index,\r\n//                 ),\r\n//                 global_index,\r\n//             );\r\n//         }\r\n//         let close = (close_fn)(\u0026vec);\r\n//         if let Some((stat, must_close)) = close {\r\n//             if must_close {\r\n//                 return (stat, global_index);\r\n//             } else {\r\n//                 last_statement = Some(stat);\r\n//             }\r\n//         } else {\r\n//             last_statement = None;\r\n//         }\r\n//     }\r\n//     (\r\n//         last_statement.unwrap_or(Statement::Error(\r\n//             ErrorData {\r\n//                 error: Error::Malformed,\r\n//             },\r\n//             global_index,\r\n//         )),\r\n//         global_index,\r\n//     )\r\n// }\r\n\r\n// fn set_global_to_loc(global_index: \u0026mut usize, locs: \u0026[usize]) {\r\n//     if let Some(last) = locs.last() {\r\n//         *global_index = last + 1;\r\n//     }\r\n// }\r\n\r\n// fn set_global_to_end(global_index: \u0026mut usize, end: usize) {\r\n//     if end != usize::MAX {\r\n//         *global_index = end + 1;\r\n//     }\r\n// }\r\n// // fn run_3_or_4_args(exprs: \u0026ExprArena, indexes: [usize; 4], mut global_index: usize,checker:fn()-\u003eOptional\u003c(Statement,bool)\u003e)-\u003e (Result\u003cStatement,ErrorData\u003e, usize) {\r\n// //     let data = [0i64; 4];\r\n// //     let has_last = false;\r\n\r\n// // first 3\r\n// // for j in 0..3 {\r\n// //     if indexes[j] == usize::MAX {\r\n// //         return (Err(ErrorData {\r\n// //             error: Error::NotParsed,\r\n// //             index: global_index,\r\n// //         }),global_index);\r\n// //     }\r\n// //     if self.write_expr(exprs) {\r\n\r\n// //     }\r\n// // }\r\n// //     match (j==3,indexes[j] == usize::MAX){\r\n// //         (true, true) =\u003e {},\r\n// //         (true, false) =\u003e {has_last = false;},\r\n// //         (false, true) =\u003e { return (Statement::Error(ErrorData {\r\n// //             error: Error::NotParsed,\r\n// //             index: global_index,\r\n// //         }),global_index);\r\n// //     },\r\n// //         (false, false) =\u003e todo!(),\r\n// //     }\r\n// //     // if indexes[j] == usize::MAX {\r\n// //     //     if j!=3{\r\n// //     //         return Statement::Error(ErrorData {\r\n// //     //             error: Error::NotParsed,\r\n// //     //             index: global_index,\r\n// //     //         }),\r\n// //     //     }\r\n// //     // }\r\n\r\n// // (Ok((data,has_last)),global_index)\r\n// // todo!()\r\n// // }\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_lint.rs"],"content":"use std::usize;\r\n\r\nuse crate::{\r\n    commands::*,\r\n    parser::{End, ParserSourceIter, SubStrData},\r\n};\r\n\r\nuse super::syntax_renderers::{Renderer, TermColor};\r\n\r\n//colors\r\nconst BASE_COLOR: (TermColor, bool) = (TermColor::White, true);\r\n// const IGNORE_COLOR: (TermColor, bool) = (TermColor::White, false);\r\n\r\nconst LOC_COLOR: [(TermColor, bool); 3] = [\r\n    (TermColor::Yellow, true),\r\n    (TermColor::Purple, true),\r\n    (TermColor::Blue, true),\r\n];\r\n\r\nconst STRING_COLOR: (TermColor, bool) = (TermColor::Black, true);\r\n\r\nconst VAR_COLOR: (TermColor, bool) = (TermColor::Cyan, true);\r\nconst NUM_COLOR: (TermColor, bool) = (TermColor::Green, true);\r\n\r\npub struct SyntaxLinter\u003cT: Renderer\u003e {\r\n    /// the renderer\r\n    renderer: T,\r\n    /// the current writing index\r\n    index: usize,\r\n    /// the length of ending characters and vec of ending colors if they exist\r\n    ends: Option\u003c(u8, Vec\u003c(TermColor, bool)\u003e)\u003e,\r\n}\r\n\r\n#[allow(dead_code)]\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            renderer: Default::default(),\r\n            index: 0,\r\n            ends: None,\r\n        }\r\n    }\r\n    pub fn into_data(self) -\u003e \u003cT as Renderer\u003e::Output {\r\n        self.renderer.into_data()\r\n    }\r\n}\r\n\r\n#[allow(dead_code)]\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    pub fn write(\r\n        \u0026mut self,\r\n        exprs: \u0026ExprArena,\r\n        line_starts: \u0026[usize],\r\n        mut source: ParserSourceIter,\r\n    ) {\r\n        for statement in line_starts {\r\n            self.write_expr(\u0026mut source, exprs, *statement, 0);\r\n            self.write_end(\u0026mut source);\r\n        }\r\n        self.write_rest(\u0026mut source);\r\n    }\r\n}\r\n\r\nfn get_n(source: \u0026mut ParserSourceIter, num: usize) -\u003e Result\u003cVec\u003cu8\u003e, Vec\u003cu8\u003e\u003e {\r\n    let ret: Vec\u003cu8\u003e = source.take(num).cloned().collect();\r\n    if ret.len() == num {\r\n        Ok(ret)\r\n    } else {\r\n        Err(ret)\r\n    }\r\n}\r\n\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    fn write_rest(\u0026mut self, source: \u0026mut ParserSourceIter) {\r\n        let buf = get_n(source, usize::MAX).map_or_else(|e| e, |o| o);\r\n        self.index += buf.len();\r\n        self.renderer.add_with(\u0026buf, BASE_COLOR);\r\n    }\r\n    fn write_up_to(\u0026mut self, source: \u0026mut ParserSourceIter, index: usize) {\r\n        self.write_up_to_as(source, index, BASE_COLOR);\r\n    }\r\n    fn get_n_or_error(source: \u0026mut ParserSourceIter, num: usize) -\u003e Vec\u003cu8\u003e {\r\n        get_n(source, num).expect(\"writing should not find end of buffer\")\r\n    }\r\n    fn write_up_to_as(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        index: usize,\r\n        color: (TermColor, bool),\r\n    ) {\r\n        let num = index.checked_sub(self.index).expect(\u0026format!(\r\n            \"index {} should be after the writing index {}\",\r\n            index, self.index\r\n        ));\r\n        let buf = Self::get_n_or_error(source, num);\r\n        self.renderer.add_with(\u0026buf, color);\r\n        self.index = index;\r\n    }\r\n    // fn write_num(\u0026mut self, source: \u0026mut ParserSourceIter, index: usize) {\r\n    //     self.write_as(source, index, BASE_COLOR);\r\n    // }\r\n    fn write_as(\u0026mut self, source: \u0026mut ParserSourceIter, num: usize, color: (TermColor, bool)) {\r\n        let buf: Vec\u003cu8\u003e = Self::get_n_or_error(source, num);\r\n        self.renderer.add_with(\u0026buf, color);\r\n        self.index += num;\r\n    }\r\n\r\n    fn write_end(\u0026mut self, source: \u0026mut ParserSourceIter) {\r\n        if let Some(end) = self.ends.take() {\r\n            // let num = index\r\n            //     .checked_sub(self.index)\r\n            //     .expect(\"index is before the end index\");\r\n            let buf = Self::get_n_or_error(source, end.0 as usize);\r\n            self.renderer.add_with_mult(\u0026buf, end.1);\r\n            self.index += end.0 as usize;\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Renderer\u003e SyntaxLinter\u003cT\u003e {\r\n    fn write_var(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        var: \u0026SubStrData,\r\n        color: (TermColor, bool),\r\n    ) {\r\n        self.write_up_to(source, var.start);\r\n        for \u0026index in \u0026var.skip_indexes {\r\n            self.write_up_to_as(source, var.start + index as usize, color);\r\n            self.write_as(source, 1, BASE_COLOR);\r\n        }\r\n        let len = var.name.len() + var.skip_indexes.len();\r\n        self.write_up_to_as(source, var.start + len, color);\r\n    }\r\n\r\n    fn write_locs(\u0026mut self, source: \u0026mut ParserSourceIter, locs: \u0026Vec\u003cusize\u003e, stack_index: usize) {\r\n        let color = LOC_COLOR[stack_index % 3];\r\n        for loc in locs {\r\n            self.write_up_to(source, *loc);\r\n            self.write_as(source, 1, color);\r\n        }\r\n    }\r\n\r\n    fn add_end(\u0026mut self, source: \u0026mut ParserSourceIter, end: End, stack_index: usize) {\r\n        let color = LOC_COLOR[stack_index % 3];\r\n        if end.index != usize::MAX {\r\n            //let close_index = self.index - end.count as usize;\r\n\r\n            // if close_index == self.index {\r\n\r\n            // } else {\r\n            //     //different close character\r\n            // }\r\n\r\n            // if passed close\r\n            if self.ends.is_some() \u0026\u0026 end.index \u003e self.index {\r\n                self.write_end(source);\r\n                self.write_up_to(source, end.index);\r\n            //close is before index\r\n            } else if end.index \u003c self.index {\r\n                unreachable!(\r\n                    \"close index {} should be after writing index {}\",\r\n                    end.index, self.index\r\n                );\r\n            }\r\n            // setup close\r\n            if let Some((_, vec)) = \u0026mut self.ends {\r\n                vec.push(color);\r\n            } else {\r\n                self.write_up_to(source, end.index);\r\n                self.ends = Some((end.count, vec![color]));\r\n            }\r\n        }\r\n    }\r\n\r\n    fn write_exprs(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        exprs: \u0026ExprArena,\r\n        indexes: \u0026[usize],\r\n        stack_index: usize,\r\n    ) {\r\n        for index in indexes {\r\n            self.write_expr(source, exprs, *index, stack_index);\r\n        }\r\n    }\r\n\r\n    fn write_expr(\r\n        \u0026mut self,\r\n        source: \u0026mut ParserSourceIter,\r\n        exprs: \u0026ExprArena,\r\n        index: usize,\r\n        stack_index: usize,\r\n    ) {\r\n        if index == usize::MAX {\r\n            return;\r\n        }\r\n        self.write_end(source);\r\n        match \u0026exprs[index] {\r\n            Expr::Title { data } =\u003e {\r\n                self.write_up_to_as(source, data.by_start, STRING_COLOR);\r\n                // color by\r\n                self.write_as(source, 2, LOC_COLOR[0]);\r\n                //write authors\r\n                let mut authors = data.authors.iter().peekable();\r\n                let mut imports = data.imports.iter().peekable();\r\n                let mut delims = data.delim.iter().peekable();\r\n                loop {\r\n                    // get lowest indexed thing or break -- this is atrocious\r\n                    let Some((write_delim, index, length)) = (match (delims.peek(), authors.peek())\r\n                    {\r\n                        (None, None) =\u003e None,\r\n                        (Some(delim), None) =\u003e Some((true, delim.0, delim.1.into())),\r\n                        (None, Some(author)) =\u003e Some((false, author.1, author.2)),\r\n                        (Some(delim), Some(author)) =\u003e Some(if delim.0 \u003c author.1 {\r\n                            (true, delim.0, delim.1.into())\r\n                        } else {\r\n                            (false, author.1, author.2)\r\n                        }),\r\n                    }) else {\r\n                        break;\r\n                    };\r\n\r\n                    // write delim\r\n                    if write_delim {\r\n                        self.write_up_to(source, index);\r\n                        self.write_as(source, length, LOC_COLOR[1]);\r\n                        delims.next();\r\n                    //write name\r\n                    } else {\r\n                        self.write_up_to(source, index);\r\n                        while let Some(\u0026\u0026(_, imp_index, imp_length)) = imports.peek() {\r\n                            // if import before end -- write that\r\n                            if imp_index \u003c index + length {\r\n                                self.write_up_to_as(source, imp_index, VAR_COLOR);\r\n                                self.write_as(source, imp_length.into(), LOC_COLOR[2]);\r\n                                imports.next();\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        self.write_up_to_as(source, index + length, VAR_COLOR);\r\n                        authors.next();\r\n                    }\r\n                }\r\n            }\r\n\r\n            Expr::Assign {\r\n                locs,\r\n                var,\r\n                value_index,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, var, VAR_COLOR);\r\n                self.write_expr(source, exprs, *value_index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Bezier { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Line { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Arc { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Rect { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Var { var } =\u003e self.write_var(source, var, VAR_COLOR),\r\n            Expr::WordNum {\r\n                locs,\r\n                str_start,\r\n                str_len,\r\n                end,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_len, STRING_COLOR);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Operator {\r\n                locs, indexes, end, ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LitNum {\r\n                str_start,\r\n                str_length,\r\n                ..\r\n            } =\u003e {\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_length, NUM_COLOR);\r\n            }\r\n            Expr::MultiLitNum {\r\n                locs,\r\n                end,\r\n                str_start,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, end.index - str_start, NUM_COLOR);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Print {\r\n                locs, indexes, end, ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::If {\r\n                locs,\r\n                // body_end ,\r\n                indexes,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::While {\r\n                locs,\r\n                // body_end ,\r\n                indexes,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LitCol {\r\n                str_start,\r\n                str_length,\r\n                ..\r\n            } =\u003e {\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_length, STRING_COLOR);\r\n            }\r\n            Expr::Stroke { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Fill { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Color { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n\r\n            Expr::Else {\r\n                locs, indexes, end, ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LitString {\r\n                str_start, str_end, ..\r\n            } =\u003e {\r\n                self.write_up_to(source, *str_start);\r\n                //one for each quote\r\n                //TODO: different color for variables\r\n                self.write_as(source, str_end - str_start + 1, STRING_COLOR);\r\n            }\r\n            Expr::MoveTo { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::LineWidth {\r\n                locs,\r\n                child_index,\r\n                end,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_expr(source, exprs, *child_index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Rotate { locs, index, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_expr(source, exprs, *index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Function {\r\n                locs,\r\n                indexes,\r\n                end,\r\n                func,\r\n                args,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, func, VAR_COLOR);\r\n                for arg in args {\r\n                    self.write_var(source, arg, VAR_COLOR);\r\n                }\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Append { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::FunctionCall {\r\n                locs,\r\n                indexes,\r\n                end,\r\n                func,\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, func, VAR_COLOR);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Delete { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Return { locs, index, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                if let Some(ind) = index {\r\n                    self.write_expr(source, exprs, *ind, stack_index + 1);\r\n                }\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Replace { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Find { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Index { indexes, locs, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::List { locs, indexes, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::ForEach {\r\n                locs,\r\n                indexes,\r\n                var,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_var(source, var, VAR_COLOR);\r\n                self.write_exprs(source, exprs, indexes, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Length { locs, index, end } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_expr(source, exprs, *index, stack_index + 1);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::Not {\r\n                locs,\r\n                str_start,\r\n                str_len,\r\n                end,\r\n                ..\r\n            } =\u003e {\r\n                self.write_locs(source, locs, stack_index);\r\n                self.write_up_to(source, *str_start);\r\n                self.write_as(source, *str_len, STRING_COLOR);\r\n                self.add_end(source, *end, stack_index);\r\n            }\r\n            Expr::NoneExpr | Expr::NoneStat =\u003e {}\r\n        };\r\n    }\r\n}\r\n\r\n//The wizards were literally nine at most!\r\n\r\n//list[line_num, index, color,length]\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":297},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers","html_renderer.rs"],"content":"use super::{Renderer, TermColor};\r\nuse bstr::ByteSlice;\r\n\r\npub struct HTMLRenderer {\r\n    str: Vec\u003cu8\u003e,\r\n    old_color: (TermColor, bool),\r\n    new_color: (TermColor, bool),\r\n}\r\n\r\nimpl Default for HTMLRenderer {\r\n    fn default() -\u003e Self {\r\n        let color = (TermColor::White, true);\r\n        Self {\r\n            str: Vec::new(),\r\n            old_color: color,\r\n            new_color: color,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Renderer for HTMLRenderer {\r\n    type Output = Vec\u003cu8\u003e;\r\n\r\n    fn add(\u0026mut self, text: \u0026[u8]) {\r\n        let vec = text.replace(b\"\\n\", b\"\u003cbr\u003e\");\r\n        self.check_color();\r\n        self.str.extend_from_slice(\u0026vec);\r\n    }\r\n\r\n    fn push(\u0026mut self, char: u8) {\r\n        self.check_color();\r\n        self.str.push(char);\r\n    }\r\n\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.add(text);\r\n    }\r\n\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], colors: Vec\u003c(TermColor, bool)\u003e) {\r\n        for color in \u0026colors[..colors.len() - 1] {\r\n            self.set_color(*color);\r\n            self.push(b'_');\r\n        }\r\n        self.set_color(*colors.last().unwrap());\r\n        self.add(text);\r\n    }\r\n\r\n    fn push_with(\u0026mut self, char: u8, color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.push(char);\r\n    }\r\n\r\n    fn into_data(self) -\u003e Vec\u003cu8\u003e {\r\n        self.str\r\n    }\r\n}\r\n\r\nconst BASE_COLOR: (TermColor, bool) = (TermColor::White, true);\r\n\r\nimpl HTMLRenderer {\r\n    fn set_color(\u0026mut self, color: (TermColor, bool)) {\r\n        self.new_color = color;\r\n    }\r\n    fn check_color(\u0026mut self) {\r\n        if self.old_color != self.new_color {\r\n            Self::change_color(\u0026mut self.str, self.new_color, self.old_color);\r\n            self.old_color = self.new_color;\r\n        }\r\n    }\r\n\r\n    fn change_color(str: \u0026mut Vec\u003cu8\u003e, new_color: (TermColor, bool), old_color: (TermColor, bool)) {\r\n        if old_color != BASE_COLOR {\r\n            str.extend_from_slice(b\"\u003c/span\u003e\");\r\n        }\r\n        if new_color != BASE_COLOR {\r\n            str.extend_from_slice(b\"\u003cspan class=\\\"term_\");\r\n            if new_color.1 {\r\n                str.extend_from_slice(b\"b_\");\r\n            }\r\n            str.extend_from_slice(match new_color.0 {\r\n                TermColor::Black =\u003e b\"black\",\r\n                TermColor::Red =\u003e b\"red\",\r\n                TermColor::Green =\u003e b\"green\",\r\n                TermColor::Yellow =\u003e b\"yellow\",\r\n                TermColor::Blue =\u003e b\"blue\",\r\n                TermColor::Purple =\u003e b\"purple\",\r\n                TermColor::Cyan =\u003e b\"cyan\",\r\n                TermColor::White =\u003e b\"white\",\r\n            });\r\n            str.extend_from_slice(b\"\\\"\u003e\")\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers","line_renderer.rs"],"content":"use super::{Renderer, TermColor};\r\nuse bstr::ByteSlice;\r\n\r\npub struct LineRenderer {\r\n    vec: Vec\u003cHighlight\u003e,\r\n    curr_line: usize,\r\n    curr_index: usize,\r\n    old_color: Vec\u003c(TermColor, bool)\u003e,\r\n    new_color: Vec\u003c(TermColor, bool)\u003e,\r\n    force: bool,\r\n}\r\n\r\nimpl Default for LineRenderer {\r\n    fn default() -\u003e Self {\r\n        let color = vec![(TermColor::White, true)];\r\n        Self {\r\n            vec: Vec::new(),\r\n            old_color: color.clone(),\r\n            new_color: color,\r\n            curr_line: 0,\r\n            curr_index: 0,\r\n            force: false,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(feature = \"wasm\")]\r\nuse wasm_bindgen::prelude::*;\r\n#[allow(dead_code)]\r\n#[cfg_attr(feature = \"wasm\", wasm_bindgen(getter_with_clone))]\r\n#[derive(PartialEq, Eq, Clone, Debug)]\r\npub struct Highlight {\r\n    pub line: usize,\r\n    pub index: usize,\r\n    pub length: usize,\r\n    pub color: Vec\u003cString\u003e,\r\n}\r\n\r\n// #[cfg(feature = \"wasm\")]\r\n// use serde_wasm_bindgen::to_value;\r\n// #[cfg(feature = \"wasm\")]\r\n// use wasm_bindgen::JsValue;\r\n// #[cfg(feature = \"wasm\")]\r\n// #[allow(dead_code)]\r\n// #[wasm_bindgen]\r\n// impl Highlight {\r\n//     pub fn get_colors(\u0026self) -\u003e JsValue {\r\n//         serde_wasm_bindgen::to_value(\u0026self.color).unwrap()\r\n//     }\r\n// }\r\n\r\nimpl Renderer for LineRenderer {\r\n    type Output = Vec\u003cHighlight\u003e;\r\n\r\n    fn add(\u0026mut self, text: \u0026[u8]) {\r\n        let splited = text.split_str(b\"\\n\");\r\n        let mut first = true;\r\n        for line in splited {\r\n            if !first {\r\n                self.curr_line += 1;\r\n                self.curr_index = 0;\r\n                self.force = true;\r\n            }\r\n            self.change_or_add(line);\r\n            first = false;\r\n        }\r\n    }\r\n\r\n    fn push(\u0026mut self, char: u8) {\r\n        if char == b'\\n' {\r\n            self.curr_line += 1;\r\n            self.curr_index = 0;\r\n        } else {\r\n            self.change_or_add(\u0026[char]);\r\n        }\r\n    }\r\n\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool)) {\r\n        self.new_color = vec![color];\r\n        self.add(text);\r\n    }\r\n\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], colors: Vec\u003c(TermColor, bool)\u003e) {\r\n        self.new_color = colors;\r\n        self.add(text);\r\n    }\r\n\r\n    fn push_with(\u0026mut self, char: u8, color: (TermColor, bool)) {\r\n        self.new_color = vec![color];\r\n        self.push(char);\r\n    }\r\n\r\n    fn into_data(self) -\u003e Vec\u003cHighlight\u003e {\r\n        self.vec\r\n    }\r\n}\r\n\r\nconst BASE_COLOR: (TermColor, bool) = (TermColor::White, true);\r\n\r\nimpl LineRenderer {\r\n    fn change_or_add(\u0026mut self, str: \u0026[u8]) {\r\n        //if length 0, color shouldn't change either\r\n        if str.len() == 0 {\r\n            return;\r\n        }\r\n        // if color changed to base, nothing is needed\r\n        if self.new_color != vec![BASE_COLOR] {\r\n            // colors are same -- add to last\r\n            if self.old_color == self.new_color \u0026\u0026 !self.force {\r\n                // should always be safe due to the not BASE_COLOR check\r\n                let highlight = self.vec.last_mut().unwrap();\r\n                highlight.length += str.len();\r\n            // colors have changed\r\n            } else {\r\n                self.force = false;\r\n                self.vec.push(Highlight {\r\n                    line: self.curr_line,\r\n                    index: self.curr_index,\r\n                    length: str.len(),\r\n                    color: self.new_color.iter().map(Self::get_color_str).collect(),\r\n                });\r\n            }\r\n        }\r\n        self.curr_index += str.len();\r\n        self.old_color = self.new_color.clone();\r\n    }\r\n    fn get_color_str(color: \u0026(TermColor, bool)) -\u003e String {\r\n        match color {\r\n            (TermColor::Black, false) =\u003e \"term_black\",\r\n            (TermColor::Black, true) =\u003e \"term_b_black\",\r\n            (TermColor::Red, false) =\u003e \"term_red\",\r\n            (TermColor::Red, true) =\u003e \"term_b_red\",\r\n            (TermColor::Green, false) =\u003e \"term_green\",\r\n            (TermColor::Green, true) =\u003e \"term_b_green\",\r\n            (TermColor::Yellow, false) =\u003e \"term_yellow\",\r\n            (TermColor::Yellow, true) =\u003e \"term_b_yellow\",\r\n            (TermColor::Blue, false) =\u003e \"term_blue\",\r\n            (TermColor::Blue, true) =\u003e \"term_b_blue\",\r\n            (TermColor::Purple, false) =\u003e \"term_purple\",\r\n            (TermColor::Purple, true) =\u003e \"term_b_purple\",\r\n            (TermColor::Cyan, false) =\u003e \"term_cyan\",\r\n            (TermColor::Cyan, true) =\u003e \"term_b_cyan\",\r\n            (TermColor::White, false) =\u003e \"term_white\",\r\n            (TermColor::White, true) =\u003e \"term_b_white\",\r\n        }\r\n        .to_string()\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":63},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers","wind_renderer.rs"],"content":"use super::{Renderer, TermColor};\r\n\r\npub struct WindowsRenderer {\r\n    str: Vec\u003cu8\u003e,\r\n    old_color: (TermColor, bool),\r\n    new_color: (TermColor, bool),\r\n}\r\n\r\nimpl Default for WindowsRenderer {\r\n    fn default() -\u003e Self {\r\n        let color = (TermColor::White, true);\r\n        Self {\r\n            str: Vec::new(),\r\n            old_color: color,\r\n            new_color: color,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Renderer for WindowsRenderer {\r\n    type Output = Vec\u003cu8\u003e;\r\n\r\n    fn add(\u0026mut self, text: \u0026[u8]) {\r\n        self.check_color();\r\n        self.str.extend_from_slice(text);\r\n    }\r\n\r\n    fn push(\u0026mut self, char: u8) {\r\n        self.check_color();\r\n        self.str.push(char);\r\n    }\r\n\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.add(text);\r\n    }\r\n\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], colors: Vec\u003c(TermColor, bool)\u003e) {\r\n        for color in \u0026colors[..colors.len() - 1] {\r\n            self.set_color(*color);\r\n            self.push(b'_');\r\n        }\r\n        self.set_color(*colors.last().unwrap());\r\n        self.add(text);\r\n    }\r\n\r\n    fn push_with(\u0026mut self, char: u8, color: (TermColor, bool)) {\r\n        self.set_color(color);\r\n        self.push(char);\r\n    }\r\n\r\n    fn into_data(self) -\u003e Vec\u003cu8\u003e {\r\n        self.str\r\n    }\r\n}\r\nimpl WindowsRenderer {\r\n    fn set_color(\u0026mut self, color: (TermColor, bool)) {\r\n        self.new_color = color;\r\n    }\r\n    \r\n    fn check_color(\u0026mut self) {\r\n        if self.old_color != self.new_color {\r\n            Self::change_color(\u0026mut self.str, self.new_color);\r\n            self.old_color = self.new_color;\r\n        }\r\n    }\r\n\r\n    fn change_color(str: \u0026mut Vec\u003cu8\u003e, color: (TermColor, bool)) {\r\n        str.extend_from_slice(b\"\\x1b[\");\r\n        str.extend_from_slice(match color {\r\n            (TermColor::Black, false) =\u003e b\"30\",\r\n            (TermColor::Red, false) =\u003e b\"31\",\r\n            (TermColor::Green, false) =\u003e b\"32\",\r\n            (TermColor::Yellow, false) =\u003e b\"33\",\r\n            (TermColor::Blue, false) =\u003e b\"34\",\r\n            (TermColor::Purple, false) =\u003e b\"35\",\r\n            (TermColor::Cyan, false) =\u003e b\"36\",\r\n            (TermColor::White, false) =\u003e b\"37\",\r\n            (TermColor::Black, true) =\u003e b\"90\",\r\n            (TermColor::Red, true) =\u003e b\"91\",\r\n            (TermColor::Green, true) =\u003e b\"92\",\r\n            (TermColor::Yellow, true) =\u003e b\"93\",\r\n            (TermColor::Blue, true) =\u003e b\"94\",\r\n            (TermColor::Purple, true) =\u003e b\"95\",\r\n            (TermColor::Cyan, true) =\u003e b\"96\",\r\n            (TermColor::White, true) =\u003e b\"97\",\r\n        });\r\n        str.push(b'm');\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers","syntax_renderers.rs"],"content":"pub(crate) mod html_renderer;\r\npub(crate) mod wind_renderer;\r\npub(crate) mod line_renderer;\r\n\r\n#[allow(dead_code)]\r\n#[derive(PartialEq, Clone, Copy)]\r\npub enum TermColor {\r\n    Black,\r\n    Blue,\r\n    Cyan,\r\n    Green,\r\n    Purple,\r\n    Red,\r\n    White,\r\n    Yellow,\r\n}\r\n\r\n#[allow(dead_code)]\r\npub trait Renderer: Default {\r\n    type Output;\r\n    // fn set_color(\u0026mut self, color: (TermColor, bool));\r\n    fn add(\u0026mut self, text: \u0026[u8]);\r\n    fn push(\u0026mut self, text: u8);\r\n    fn add_with(\u0026mut self, text: \u0026[u8], color: (TermColor, bool));\r\n    fn add_with_mult(\u0026mut self, text: \u0026[u8], color: Vec\u003c(TermColor, bool)\u003e);\r\n    fn push_with(\u0026mut self, text: u8, color: (TermColor, bool));\r\n    fn into_data(self) -\u003e Self::Output;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Git","Prosetta","Rust Interpreter","src","writers.rs"],"content":"pub(crate) mod javascript_writer;\r\npub(crate) mod lisp_like_writer;\r\n\r\npub(crate) mod syntax_lint;\r\npub(crate) mod syntax_renderers;\r\n\r\npub(crate) mod error_messages;\r\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>